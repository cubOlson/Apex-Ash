<head>
    <title>POE Production</title>
    <meta description="Path of Exile RGB." />
    <meta publisher="SignalRGB" />
    <meta property="Brightness" label="Screen ambiance brightness" type="number" min="0" max="100" default="100" />
  
    <!-- #region Screen Meter Declarations -->
    <meta meter="inGame" tags="VLC,path of exile" type="linear" x="0.0820" y="0.9736" width="0.0029" height="0.0007" h="0-45" s="25-50" l="25-50" >
    </meta> 
    <meta meter="hp1" tags="VLC,path of exile" type="area" x="0.0390" y="0.8105" width="0.002" height="0.1632" h="340-360" s="50-100" l="20-75" >
    </meta> 
    <meta meter="hp2" tags="VLC,path of exile" type="area" x="0.0390" y="0.8105" width="0.002" height="0.1632" h="0-20" s="50-100" l="20-75" >
    </meta> 
    <meta meter="mana" tags="VLC,path of exile" type="area" x="0.9468" y="0.8146" width="0.0029" height="0.1701" h="180-230" s="50-100" l="20-75" >
    </meta> 
    <meta meter="skill1" tags="VLC,path of exile" type="colormean"  x="0.8465" y="0.8819" width="0.0084" height="0.0194" h="189-209" s="80-100" l="66-100" >
    </meta>
    <meta meter="skill2" tags="VLC,path of exile" type="colormean" x="0.8683" y="0.8819" width="0.0084" height="0.0194" h="189-209" s="80-100" l="66-100" >
    </meta> 
    <meta meter="skill3" tags="VLC,path of exile" type="colormean" x="0.8892" y="0.8819" width="0.0084" height="0.0194" h="189-209" s="80-100" l="66-100" >
    </meta> 
    <meta meter="skill4" tags="VLC,path of exile" type="colormean" x="0.8029" y="0.9458" width="0.0192" height="0.005" h="189-209" s="80-100" l="66-100" >
    </meta> 
    <meta meter="skill5" tags="VLC,path of exile" type="colormean" x="0.8247" y="0.9458" width="0.0192" height="0.005" h="189-209" s="80-100" l="66-100" >
    </meta> 
    <meta meter="skill6" tags="VLC,path of exile" type="colormean" x="0.8471" y="0.9458" width="0.0192" height="0.005" h="189-209" s="80-100" l="66-100" >
    </meta> 
    <meta meter="skill7" tags="VLC,path of exile" type="colormean" x="0.8686" y="0.9458" width="0.0192" height="0.005" h="189-209" s="80-100" l="66-100" >
    </meta>
    <meta meter="skill8" tags="VLC,path of exile" type="colormean" x="0.8907" y="0.9458" width="0.0192" height="0.005" h="189-209" s="80-100" l="66-100" >
    </meta>  
    <meta meter="lvlUpBar" tags="VLC,path of exile" type="area" x="0.2436" y="0.9917" width="0.0253" height="0.0014" h="20-45" s="25-75" l="60-100" >
    </meta> 
    <!-- #endregion -->
</head>
  
  <body style="margin: 0; padding: 0; background: #000">
    <canvas id="exCanvas" width="320" height="200"></canvas>
  </body>
  
  <script>
  
    var canvas, ctx;
    var stateHdlr = new StateHandler();
    var effects = [];
    var currentHealth = 100;
    var currentMana = 100;
    var skillCount = 0;

    var inGameMeter = new Meter(1, inGameHelp);
    var hp1Meter = new Meter(3, healthEffects);
    var hp2Meter = new Meter(3, healthEffects);
    var manaMeter = new Meter(3, manaEffects);
    var skill1LitMeter = new Meter(2, skillEffects);
    var skill2LitMeter = new Meter(2, skillEffects);
    var skill3LitMeter = new Meter(2, skillEffects);
    var skill4LitMeter = new Meter(2, skillEffects);
    var skill5LitMeter = new Meter(2, skillEffects);
    var skill6LitMeter = new Meter(2, skillEffects);
    var skill7LitMeter = new Meter(2, skillEffects);
    var skill8LitMeter = new Meter(2, skillEffects);
    var lvlConfirmMeter = new Meter(3, lvlEffects);
  
  //#region Update Function
    function update() {
      if (Brightness != 0) {
        IdleState();
      } else {
        ctx.fillStyle = "black"
        ctx.fillRect(0, 0, 320, 200)
      }

      inGameMeter.setValue(engine.vision.inGame)
      if(inGameMeter.value == 1){
        hp1Meter.setValue(engine.vision.hp1)
        hp2Meter.setValue(engine.vision.hp2)
        manaMeter.setValue(engine.vision.mana)
        skill1LitMeter.setValue(engine.vision.skill1[2])
        skill2LitMeter.setValue(engine.vision.skill2[2])
        skill3LitMeter.setValue(engine.vision.skill3[2])
        skill4LitMeter.setValue(engine.vision.skill4[2])
        skill5LitMeter.setValue(engine.vision.skill5[2])
        skill6LitMeter.setValue(engine.vision.skill6[2])
        skill7LitMeter.setValue(engine.vision.skill7[2])
        skill8LitMeter.setValue(engine.vision.skill8[2])
        lvlConfirmMeter.setValue(engine.vision.lvlUpBar)
      }
  
      //Effect handler 
      for (let i = 0; i < effects.length; i++) {
        effects[i].draw();
        if (effects[i].lifetime <= 0) { 
          effects.splice(i, 1);
        }
      }

      skillCount > 0 ? skillCount-=.5 : null;
  
      stateHdlr.Process();
      window.requestAnimationFrame(update);
    }
    //#endregion

    function inGameHelp(){
      if(inGameMeter.value == 1){
        console.log("IN-GAME")
      } else {
        console.log("OUT-GAME")
      }
    }

    function healthEffects(){
      var current = Math.ceil((hp1Meter.value + hp2Meter.value) * 100);
      if (Math.abs(current - currentHealth) > 1){
        currentHealth = current;
      }
      console.log("HEALTH " + currentHealth)
    }

    function manaEffects(){
      currentMana = manaMeter.value * 100;
      console.log("MANA " + currentMana)
    }

    function skillEffects(){
      (skill1LitMeter.decreased && skill1LitMeter.diff > 15) ? skillCount += 10 : null;
      (skill2LitMeter.decreased && skill2LitMeter.diff > 15) ? skillCount += 10 : null;
      (skill3LitMeter.decreased && skill3LitMeter.diff > 15) ? skillCount += 10 : null;
      (skill4LitMeter.decreased && skill4LitMeter.diff > 15) ? skillCount += 10 : null;
      (skill5LitMeter.decreased && skill5LitMeter.diff > 15) ? skillCount += 10 : null;
      (skill6LitMeter.decreased && skill6LitMeter.diff > 15) ? skillCount += 10 : null;
      (skill7LitMeter.decreased && skill7LitMeter.diff > 15) ? skillCount += 10 : null;
      (skill8LitMeter.decreased && skill8LitMeter.diff > 15) ? skillCount += 10 : null;
      
    }

    function lvlEffects(){
      if(lvlConfirmMeter.value < .1 && lvlConfirmMeter.decreased){
        console.log("LEVEL UP")
      }
    }
  
    function IdleState() {
    let lightness = new Int8Array(engine.zone.lightness);
    let sat = new Int8Array(engine.zone.saturation);
    let hue = new Int16Array(engine.zone.hue);

    for (var iZone = 0; iZone < 560; iZone++) {
      ctx.fillStyle = 'hsl(' + hue[iZone] + ',' + sat[iZone] + '%,' + lightness[iZone] * Brightness / 100 + '%)'
      var iRow = Math.floor(iZone / 28);
      var iCol = iZone % 28;
      var iWidth = 320 / 28;
      var iHeight = 200 / 20;
      var iZx = iCol * iWidth;
      var iZy = iRow * iHeight;

      ctx.fillRect(iZx, iZy, iWidth, iHeight);

    }
  }
  
    function StateHandler() {
      var stack = [];
      var state = null;
  
      // Set current state to the top item in the stack
      var updateState = function () {
        if (stack.length > 0) {
          state = stack[stack.length - 1];
        } else {
          state = null;
        }
      };
  
      // Allows dev to add effect to state handler
      this.Push = function (newState) {
        stack.push(newState);
        updateState();
      };
      // Allows dev to remove effect from handler
      this.Pop = function () {
        stack.pop();
        updateState();
      };
      // Call the Process function of the current state (effect)
      this.Process = function () {
        if (state != null) {
          state.Process();
        }
      };
    }
  
    function Meter(count, callback) {
      this.size = count;
      this.value = 0;
      this.diff = 0;
      this.increased = false;
      this.decreased = false;
      var values = [];
  
      this.setValue = function (updatedValue) {
        // Add and shift.
        values.push(updatedValue);
        if (values.length > this.size) {
          values.shift();
        }
  
        // Exit early if we've got a long-term match.
        for (var i = 0; i < values.length - 1; i++) {
          if (values[i] !== values[i + 1]) return;
        }
  
        // We got here, so we've got a matching value collection.
        if (this.value !== values[0]) {
          //var fromZero = this.value === 0;
          //var toZero = values[0] === 0;
          this.diff = Math.abs(this.value - values[0]);
          this.increased = this.value < values[0];
          this.decreased = this.value > values[0];
          this.value = values[0];
  
          callback();
        }
      };
    }

    function Meter(count, callback) {
      this.size = count;
      this.value = 0;
      this.diff = 0;
      this.increased = false;
      this.decreased = false;
      var values = [];
  
      this.setValue = function (updatedValue) {
        // Add and shift.
        values.push(updatedValue);
        if (values.length > this.size) {
          values.shift();
        }
  
        // Exit early if we've got a long-term match.
        for (var i = 0; i < values.length - 1; i++) {
          if (values[i] !== values[i + 1]) return;
        }
  
        // We got here, so we've got a matching value collection.
        if (this.value !== values[0]) {
          //var fromZero = this.value === 0;
          //var toZero = values[0] === 0;
          this.diff = Math.abs(this.value - values[0]);
          this.increased = this.value < values[0];
          this.decreased = this.value > values[0];
          this.value = values[0];
  
          callback();
        }
      };
    }
  
  
  
    function onEngineReady() {
      // Grab canvas and rendering context.
      canvas = document.getElementById("exCanvas");
      ctx = canvas.getContext("2d");
      // Start updates *after* our engine is accessible and ready.
      window.requestAnimationFrame(update);
    }
  </script>
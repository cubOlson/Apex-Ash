<head>
    <title>POE FILM</title>
    <meta description="Path of Exile RGB." />
    <meta publisher="SignalRGB" />
    <meta property="Brightness" label="Screen ambiance brightness" type="number" min="0" max="100" default="100" />
    <meta property="eBrightness" label="Effects brightness" type="number" min="0" max="100" default="100" />
    <meta property="HPOn" label="HP HUD Effect" type="boolean" default="1" />
    <meta property="ManaOn" label="Mana HUD Effect" type="boolean" default="1" />
    <meta property="SkillOn" label="Skill HUD Effect" type="boolean" default="1" />
    <meta property="DeathOn" label="Death Effect" type="boolean" default="1" />
    <meta property="LevelOn" label="Level Effect" type="boolean" default="1" />
    <meta property="PortalOn" label="Portal Effect" type="boolean" default="1" />
    <meta property="LoadingOn" label="Loading Effect" type="boolean" default="1" />
    <meta property="adjustHUD" label="HUD adjust (turn off when done)" type="boolean" default="0" />
    <meta property="HPColor" label="HP HUD Color" type="color" min="0" max="360" default="#ff0000" />
    <meta property="xPos" label="HP X-Position" type="number" min="0" max="320" default="0" />
    <meta property="yPos" label="HP Y-position" type="number" min="0" max="200" default="50" />
    <meta property="HUDStyle" label="HP Shape" type="boolean" default="0" />
    <meta property="HUDHeight" label="HP height (rectangle)" type="number" min="1" max="200" default="50" />
    <meta property="HUDWidth" label="HP width (rectangle / circle)" type="number" min="1" max="320" default="320" />
    <meta property="ManaColor" label="Mana HUD Color" type="color" min="0" max="360" default="#0000ff" />
    <meta property="xPosM" label="Mana X-Position" type="number" min="0" max="320" default="0" />
    <meta property="yPosM" label="Mana Y-position" type="number" min="0" max="200" default="50" />
    <meta property="HUDStyleM" label="Mana Shape" type="boolean" default="0" />
    <meta property="HUDHeightM" label="Mana height (rectangle)" type="number" min="1" max="200" default="50" />
    <meta property="HUDWidthM" label="Mana width (rectangle / circle)" type="number" min="1" max="320" default="320" />
    <meta property="SkillUpColor" label="Skill Up HUD Color" type="color" min="0" max="360" default="#00ff00" />
    <meta property="SkillDownColor" label="Skill Down HUD Color" type="color" min="0" max="360" default="#ff0000" />
    <meta property="xPosS" label="Skillbar X-Position" type="number" min="0" max="320" default="0" />
    <meta property="yPosS" label="Skillbar Y-position" type="number" min="0" max="200" default="50" />
    <meta property="skillStyle" label="Skillbar Direction" type="boolean" default="0" />
    <meta property="skillHeight" label="Skillbar height" type="number" min="1" max="200" default="50" />
    <meta property="skillWidth" label="Skillbar Width" type="number" min="1" max="320" default="320" />
  
    <!-- #region Screen Meter Declarations -->
    <meta meter="inGame" tags="VLC,path of exile" type="linear" x="0.1115" y="0.9722" width="0.001" height="0.0007" h="0-45" s="20-50" l="25-50" >
      <resolution size="3440x1440" x="0.0820" y="0.9736" width="0.0029" height="0.0007" />
    </meta> 
    <meta meter="hp1" tags="VLC,path of exile" type="area" x="0.0468" y="0.8121" width="0.001" height="0.161" h="340-360" s="60-100" l="20-75" >
      <resolution size="3440x1440" x="0.0390" y="0.8105" width="0.002" height="0.1632" />
    </meta> 
    <meta meter="hp2" tags="VLC,path of exile" type="area" x="0.0468" y="0.8121" width="0.001" height="0.161" h="0-20" s="60-100" l="20-75" >
      <resolution size="3440x1440" x="0.0390" y="0.8105" width="0.002" height="0.1632" />
    </meta> 
    <meta meter="mana" tags="VLC,path of exile" type="area" x="0.9219" y="0.8148" width="0.0029" height="0.1701" h="180-230" s="50-100" l="20-75" >
      <resolution size="3440x1440" x="0.9468" y="0.8146" width="0.0029" height="0.1701" />
    </meta> 
    <meta meter="skill1" tags="VLC,path of exile" type="colormean" x="0.7968" y="0.888" width="0.006" height="0.005" h="189-209" s="80-100" l="66-100" >
      <resolution size="3440x1440" x="0.8493" y="0.8889" width="0.0084" height="0.005" />
    </meta>
    <meta meter="skill2" tags="VLC,path of exile" type="colormean" x="0.826" y="0.888" width="0.0084" height="0.005" h="189-209" s="80-100" l="66-100" >
      <resolution size="3440x1440" x="0.8706" y="0.8889" width="0.0084" height="0.005" />
    </meta> 
    <meta meter="skill3" tags="VLC,path of exile" type="colormean" x="0.8552" y="0.888" width="0.0084" height="0.005" h="189-209" s="80-100" l="66-100" >
      <resolution size="3440x1440" x="0.8919" y="0.8889" width="0.0084" height="0.005" />
    </meta> 
    <meta meter="skill4" tags="VLC,path of exile" type="colormean" x="0.7391" y="0.9515" width="0.0084" height="0.005" h="189-209" s="80-100" l="66-100" >
      <resolution size="3440x1440" x="0.8058" y="0.9528" width="0.0084" height="0.005" />
    </meta> 
    <meta meter="skill5" tags="VLC,path of exile" type="colormean" x="0.7677" y="0.9515" width="0.0084" height="0.005" h="189-209" s="80-100" l="66-100" >
      <resolution size="3440x1440" x="0.8276" y="0.9528" width="0.0084" height="0.005" />
    </meta> 
    <meta meter="skill6" tags="VLC,path of exile" type="colormean" x="0.7974" y="0.9515" width="0.0084" height="0.005" h="189-209" s="80-100" l="66-100" >
      <resolution size="3440x1440" x="0.8494" y="0.9528" width="0.0084" height="0.005" />
    </meta> 
    <meta meter="skill7" tags="VLC,path of exile" type="colormean" x="0.8266" y="0.9515" width="0.0084" height="0.005" h="189-209" s="80-100" l="66-100" >
      <resolution size="3440x1440" x="0.8709" y="0.9528" width="0.0084" height="0.005" />
    </meta>
    <meta meter="skill8" tags="VLC,path of exile" type="colormean" x="0.8563" y="0.9515" width="0.0084" height="0.005" h="189-209" s="80-100" l="66-100" >
      <resolution size="3440x1440" x="0.893" y="0.9528" width="0.0084" height="0.005" />
    </meta>  
    <meta meter="lvlUpBar" tags="VLC,path of exile" type="area" x="0.31" y="0.9915" width="0.015" height="0.0014" h="20-60" s="25-75" l="60-100" >
      <resolution size="3440x1440" x="0.2436" y="0.9917" width="0.0253" height="0.0014" />
    </meta> 
    <meta meter="loadYellow" tags="VLC,path of exile" type="linear" x="0.4714" y="0.7833" width="0.0025" height="0.0007" h="30-250" s="0-70" l="70-100" >
      <resolution size="3440x1440" x="0.47" y="0.7840" width="0.01" height="0.0007" />
    </meta> 
    <meta meter="loadBrown" tags="VLC,path of exile" type="area" x="0.4712" y="0.796" width="0.01" height="0.004" h="0-360" s="0-100" l="0-15" >
      <resolution size="3440x1440" x="0.47" y="0.7840" width="0.01" height="0.0007" />
    </meta> 
    <meta meter="portalYellow" tags="VLC,path of exile" type="area" x="0.1714" y="0.0241" width="0.0009" height="0.0083" h="30-60" s="15-60" l="70-100" >
      <resolution size="3440x1440" x="0.1276" y="0.0236" width="0.0009" height="0.0083" />
    </meta> 
    <meta meter="portalBlack" tags="VLC,path of exile" type="area" x="0.175" y="0.0213" width="0.0006" height="0.0042" h="0-45" s="30-70" l="0-25" >
      <resolution size="3440x1440" x="0.1305" y="0.0215" width="0.0006" height="0.0042" />
    </meta>
    <meta meter="deadOrange" tags="VLC,path of exile" type="linear" x="0.5052" y="0.2287" width="0.02" height="0.0001" h="0-40" s="0-100" l="0-100" >
      <resolution size="3440x1440" x="0.5163" y="0.2021" width="0.0224" height="0.0001" />
    </meta> 
    <meta meter="deadBlack" tags="VLC,path of exile" type="area" x="0.5047" y="0.2325" width="0.0081" height="0.005" h="0-360" s="10-70" l="0-20" >
      <resolution size="3440x1440" x="0.5212" y="0.233" width="0.0081" height="0.006" />
    </meta>
    <!-- #endregion -->
</head>
  
  <body style="margin: 0; padding: 0; background: #000">
    <canvas id="exCanvas" width="320" height="200"></canvas>
  </body>
  
  <script>
    var canvas, ctx;
    var stateHdlr = new StateHandler();
    var effects = [];
    var skillArray = [1, 1, 1, 1, 1, 1, 1, 1]
    var currentHealth = 100;
    var currentMana = 100;
    var inGameBool = false;
    var healthPushed = false;
    var manaPushed = false;
    var deathPushed = false;
    var portalPushed = false;
    var loadPushed = false;
    var skillPushed = false;
  //#region Meter Declarations
    var inGameMeter = new Meter(5, inGameHelp);
    var hp1Meter = new Meter(3, healthEffects);
    var hp2Meter = new Meter(3, healthEffects);
    var manaMeter = new Meter(3, manaEffects);
    var skill1LitMeter = new Meter(2, skillEffects);
    var skill2LitMeter = new Meter(2, skillEffects);
    var skill3LitMeter = new Meter(2, skillEffects);
    var skill4LitMeter = new Meter(2, skillEffects);
    var skill5LitMeter = new Meter(2, skillEffects);
    var skill6LitMeter = new Meter(2, skillEffects);
    var skill7LitMeter = new Meter(2, skillEffects);
    var skill8LitMeter = new Meter(2, skillEffects);
    var lvlConfirmMeter = new Meter(3, lvlEffects);
    var loadYellowMeter = new Meter(5, loadEffects);
    var loadBrownMeter = new Meter(5, loadEffects);
    var portalYellowMeter = new Meter(5, portalEffects);
    var portalBlackMeter = new Meter(5, portalEffects);
    var deadOrangeMeter = new Meter(15, deathEffects);
    var deadBlackMeter = new Meter(15, deathEffects);
    //#endregion
  //#region Update Function
    function update() {
      if (Brightness != 0) {
        IdleState();
      } else {
        ctx.fillStyle = "black"
        ctx.fillRect(0, 0, 320, 200)
      }

      inGameMeter.setValue(engine.vision.inGame)

      if(inGameBool){
        hp1Meter.setValue(engine.vision.hp1)
        hp2Meter.setValue(engine.vision.hp2)
        manaMeter.setValue(engine.vision.mana)
        skill1LitMeter.setValue(engine.vision.skill1[2])
        skill2LitMeter.setValue(engine.vision.skill2[2])
        skill3LitMeter.setValue(engine.vision.skill3[2])
        skill4LitMeter.setValue(engine.vision.skill4[2])
        skill5LitMeter.setValue(engine.vision.skill5[2])
        skill6LitMeter.setValue(engine.vision.skill6[2])
        skill7LitMeter.setValue(engine.vision.skill7[2])
        skill8LitMeter.setValue(engine.vision.skill8[2])
        lvlConfirmMeter.setValue(engine.vision.lvlUpBar)
        portalYellowMeter.setValue(engine.vision.portalYellow)
        portalBlackMeter.setValue(engine.vision.portalBlack)
        deadOrangeMeter.setValue(engine.vision.deadOrange)
        deadBlackMeter.setValue(engine.vision.deadBlack)
      }
        loadBrownMeter.setValue(engine.vision.loadBrown)
        loadYellowMeter.setValue(engine.vision.loadYellow)
  
      //Effect handler 
      ctx.globalAlpha = eBrightness / 100;
      for (let i = 0; i < effects.length; i++) {
        effects[i].draw();
        if (effects[i].lifetime <= 0) { 
          effects.splice(i, 1);
        }
      }
      
      stateHdlr.Process();
      ctx.globalAlpha = 1;

      if (adjustHUD && !inGameBool) {
        if (HPOn) {
          if(HUDStyle){
            DrawCircle(xPos, yPos, HUDWidth, HPColor)
          } else {
            DrawRect(xPos, yPos, HUDWidth, HUDHeight, HPColor)
          }
        } 
        if (ManaOn){
          if(HUDStyleM){
            DrawCircle(xPosM, yPosM, HUDWidthM, ManaColor)
          } else {
            DrawRect(xPosM, yPosM, HUDWidthM, HUDHeightM, ManaColor)
          }
        } 
        if (SkillOn){
            DrawRect(xPosS, yPosS, skillWidth, skillHeight, "grey")
        }
      }
      window.requestAnimationFrame(update);
    }
    //#endregion
  //#region Effect Handlers
    function inGameHelp(){
      if(inGameMeter.value == 1){
        inGameBool = true;
        if(!healthPushed && HPOn){
          effects.push(new basicHUD(xPos, yPos, HUDWidth, "health"))
          healthPushed = true;
        }
        if(!manaPushed && ManaOn){
          effects.push(new basicHUD(xPosM, yPosM, HUDWidthM, "mana"))
          manaPushed = true;
        }
        if(!skillPushed && SkillOn){
          effects.push(new skillHUD(xPosS, yPosS))
          skillPushed = true;
        }
      } else {
        effects = []
        inGameBool = false;
        portalPushed = false;
        deathPushed = false;
        healthPushed = false;
        manaPushed = false;
        skillPushed = false;
        loadPushed = false;
      }
    }

    function healthEffects(){
      var current = Math.ceil((hp1Meter.value + hp2Meter.value) * 100);
      if (Math.abs(current - currentHealth) > 1){
        currentHealth = current + current * .05;
      }
      // console.log("HEALTH " + currentHealth)
    }

    function manaEffects(){
      currentMana = manaMeter.value * 100;
      // console.log("MANA " + currentMana)
    }

    function skillEffects(){
      (skill1LitMeter.decreased && skill1LitMeter.diff > 10) ? skillArray[0] = 0 : null;
      skill1O = skill1LitMeter.value;
      (skill1LitMeter.increased && skill1LitMeter.diff > 4) ? skillArray[0] = 1 : null;
      (skill1LitMeter.increased && skill2LitMeter.diff > 4) ? skillArray[1] = 1 : null;
      (skill2LitMeter.decreased && skill2LitMeter.diff > 10) ? skillArray[1] = 0 : null;
      (skill1LitMeter.increased && skill3LitMeter.diff > 4) ? skillArray[2] = 1 : null;
      (skill3LitMeter.decreased && skill3LitMeter.diff > 10) ? skillArray[2] = 0 : null;
      (skill1LitMeter.increased && skill4LitMeter.diff > 4) ? skillArray[3] = 1 : null;
      (skill4LitMeter.decreased && skill4LitMeter.diff > 10) ? skillArray[3] = 0 : null;
      (skill1LitMeter.increased && skill5LitMeter.diff > 4) ? skillArray[4] = 1 : null;
      (skill5LitMeter.decreased && skill5LitMeter.diff > 10) ? skillArray[4] = 0 : null;
      (skill1LitMeter.increased && skill6LitMeter.diff > 4) ? skillArray[5] = 1 : null;
      (skill6LitMeter.decreased && skill6LitMeter.diff > 10) ? skillArray[5] = 0 : null;
      (skill1LitMeter.increased && skill7LitMeter.diff > 4) ? skillArray[6] = 1 : null;
      (skill7LitMeter.decreased && skill7LitMeter.diff > 10) ? skillArray[6] = 0 : null;
      (skill1LitMeter.increased && skill8LitMeter.diff > 4) ? skillArray[7] = 1 : null;
      (skill8LitMeter.decreased && skill8LitMeter.diff > 10) ? skillArray[7] = 0 : null;
    }

    function lvlEffects(){
      if(lvlConfirmMeter.value < .4 && lvlConfirmMeter.decreased && LevelOn){
        effects.push(new levelUp())
      }
    }

    function loadEffects(){
      if(loadBrownMeter.value == 1 && loadYellowMeter.value == 1 && !loadPushed && LoadingOn){
        effects.push(new loading())
        loadPushed = true;
      }
    }

    function portalEffects(){
      if(portalBlackMeter.value == 1 && portalYellowMeter.value == 1 && !portalPushed && PortalOn){
        effects.push(new portal())
        portalPushed = true;
      }
    }

    function deathEffects(){
      if(deathPushed && deadBlackMeter.value < .3 && deadOrangeMeter.value < .3){
        deathPushed = false;
      }
      if(deadBlackMeter.value == 1 && deadOrangeMeter.value == 1 && engine.vision.hp1 < .1 && !deathPushed && DeathOn){
        effects.push(new death())
        deathPushed = true;
      }
    }
    //#endregion
  
    function basicHUD(x, y, radius, type) {
      this.x = x;
      this.y = y;
      this.radius = radius;
      this.type = type;
      this.value = type == "health" ? currentHealth : currentMana;
      this.lifetime = 10;
      this.draw = function () {
        this.x = this.type == "health" ? xPos : xPosM;
        this.y = this.type == "health" ? yPos : yPosM
        this.radius = this.type == "health" ? HUDWidth : HUDWidthM
        this.value = this.type == "health" ? currentHealth + currentHealth / 20 : currentMana;
        if ((this.type == "health" && HUDStyle) || (this.type == "mana" && HUDStyleM)) {
          var endAngle = -Math.PI / 2 + (Math.PI * 2 / 100) * this.value
          ctx.fillStyle = this.type == "health" ? HPColor : ManaColor;
          ctx.beginPath();
          ctx.moveTo(this.x, this.y);
          ctx.arc(this.x, this.y, this.radius, -Math.PI / 2, endAngle);
          ctx.closePath();
          ctx.fill();
        } else {
          DrawRect(this.x, this.y, 320 / 100 * this.value, this.type == "health" ? HUDHeight : HUDHeightM, this.type == "health" ? HPColor : ManaColor)
        }
        if(!inGameBool || !HPOn || !ManaOn){
          if(this.type == "health" && !HPOn){
            healthPushed = false;
            this.lifetime = 0;
          } 
          if (this.type == "mana" && !ManaOn) {
            manaPushed = false;
            this.lifetime = 0;
          }
        }
      }
    }

    function skillHUD(x, y){
      this.x = xPosS
      this.y = yPosS;
      this.lifetime = 10;
      this.draw = function(){
        this.x = xPosS
        this.y = yPosS;
        skillArray.forEach((ele, i)=>{
          var x = skillStyle ? this.x : this.x + skillWidth / 8 * i
          var y = skillStyle ? this.y + skillHeight / 8 * i : this.y
          var w = skillStyle ? skillWidth : skillWidth / 8;
          var h = skillStyle ? skillHeight / 8 : skillHeight;
          var c = ele ? SkillUpColor : SkillDownColor
          DrawRect(x, y, w, h, c)
          ctx.strokeStyle = "black"
          ctx.lineWidth = skillStyle ? skillHeight * .03 : skillWidth * .03;
          ctx.rect(x, y, w, h)
          ctx.stroke();
        })
        if(!inGameBool || !SkillOn){
          this.lifetime = 0;
          skillPushed = false;
        }
      }
    }

    function levelUp(){
      this.start = Date.now();
      this.lifetime = 10;
      this.radius = 1;
      this.switch = false;
      this.count = 0;
      var grad = ctx.createRadialGradient(160, 100, 1, 160, 100, 250)
      grad.addColorStop(0, "rgba(255, 255, 255, .7)")
      grad.addColorStop(1, "rgba(255, 255, 255, .1)")
      this.draw = function(){
        DrawCircle(160, 100, this.radius, grad)
        this.switch ? this.radius-=2 : this.radius+=2;
        this.radius > 100 ? this.switch = true : null;
        this.radius < 1 ? this.radius = 1 : null;
        var elapsed = Date.now() - this.start;
        if(elapsed > 200){
          effects.push(new levelHelp(1))
          this.start = Date.now()
          this.count < 10 ? this.count++ : this.lifetime = 0;
        }
      }
    }

function levelHelp(radius){
  this.radius = radius;
  this.lifetime = 10;
  this.start = Date.now()
  this.draw = function(){
    var elapsed = Date.now() - this.start
    DrawStroke(160, 100, this.radius, `hsla(60, 100%, 50%, ${Math.abs(Math.sin(elapsed/100))})`, 20)
    this.radius < 250 ? this.radius+=3 : this.lifetime = 0;
  }
}

    function loading(){
      this.lifetime = 10;
      this.rotate = 0;
      this.draw = function(){
        ctx.save()
        ctx.translate(100, 100)
        ctx.rotate(this.rotate)
        ctx.translate(-100, -100)
        DrawGear(115, 100, 30, 20, 8, "gold")
        ctx.restore()
        ctx.save()
        ctx.translate(220, 100)
        ctx.rotate(-this.rotate)
        ctx.translate(-220, -100)
        DrawGear(205, 100, 30, 20, 8, "gold")
        ctx.restore()
        this.rotate+=.03
        if(loadBrownMeter.value < .3 || loadYellowMeter.value < .3){
          loadPushed = false;
          this.lifetime = 0;
        }
      }
    }

  function DrawGear(x, y, radius, stroke, teeth, color){
    DrawStroke(x, y, radius, color, stroke)
    for(let i = 0; i < teeth; i++){
      var ix = Math.cos(Math.PI * 2 / teeth * i) * radius + x;
      var iy = Math.sin(Math.PI * 2 / teeth * i) * radius + y;
      var rotate = Math.atan2(y - iy, x - ix) + Math.PI / 2;
      ctx.save()
      ctx.translate(ix, iy)
      ctx.rotate(rotate)
      ctx.translate(-ix, -iy)
      DrawRect(ix, iy, Math.PI * radius * 2 / teeth * .75, radius / 3 + stroke / 2, "orange")
      ctx.restore()
    }
  }

    function portal(){
    this.start = Date.now();
    this.lifetime = 10;
    this.rotate = 0;
    this.alpha = 0;
    var gradient = ctx.createRadialGradient(160, 100, 1, 160, 100, 200);
    gradient.addColorStop(0, 'rgba(25, 110, 255, 1)');
    gradient.addColorStop(.5, 'rgba(50, 110, 255, .7)');
    gradient.addColorStop(1, 'rgba(150, 150, 255, .05)');
    this.draw = function(){
      ctx.globalAlpha = this.alpha;
      var elapsed = Date.now() - this.start;
      DrawCircle(160, 100, 200, gradient)
      ctx.save()
      ctx.translate(160, 100)
      ctx.rotate(this.rotate)
      ctx.translate(-160, -100)
      DrawRect(130, 70, 60, 60, 'rgba(100, 200, 255, 1)')
      ctx.translate(160, 100)
      ctx.rotate(Math.PI / 4)
      ctx.translate(-160, -100)
      DrawRect(130, 70, 60, 60, 'rgba(100, 200, 255, 1)')
      DrawRect(140, 80, 40, 40, "blue")
      ctx.restore()
      var radius = Math.sin(Date.now() / 1000) * 10 + 80;
      DrawStroke(160, 100, radius, 'rgba(100, 200, 255, 1)', 20)
      ctx.globalAlpha = 1;
      this.alpha < 1 ? this.alpha+=.1 : null;
      if(elapsed > 300){
        effects.push(new portalFlash(160 + radius, 100, radius))
      }
      this.rotate+=.01
      if(portalBlackMeter.value < .5 && portalYellowMeter.value < .5){
        this.lifetime = 0; 
        portalPushed = false;
      }
    }
  }

  function portalFlash(x, y, radius){
    this.x = x;
    this.y = y;
    this.radius = radius;
    this.lifetime = 10;
    this.speed = 700 + 10 * Math.random()
    this.draw = function(){
      DrawCircle(this.x, this.y, 10, "rgb(100, 255, 255)")
      this.x=Math.cos(Date.now()/this.speed) * this.radius + 160;
      this.y=Math.sin(Date.now()/this.speed) * this.radius + 100;
      this.radius++;
      if(this.x > 350 || this.x < -30 || this.y > 230 || this.y < -30){
        this.lifetime = 0;
      }
    }
  }

    function death(){
      this.start = Date.now()
      this.lifetime = 10;
      this.radius = 1;
      this.checked = false;
      this.draw = function(){
        var elapsed = Date.now() - this.start;
        var grd = ctx.createRadialGradient(160, 200, 1, 160, 200, this.radius);
        grd.addColorStop(0, "red");
        grd.addColorStop(1, "rgba(255, 0, 0, .1)");
        DrawCircle(160, 200, 300, grd)
        if(elapsed > 310 - this.radius){
          effects.push(new ghost())
          this.start = Date.now()
        }
        if(!this.checked){
          this.radius < 300 ? this.radius+=5 : this.checked = true;
        } else {
          this.radius > 2 ? this.radius--: null;
        }
        if(this.checked && this.radius == 2){
          this.lifetime = 0;
          deathPushed = false;
        }
      }
    }

  function ghost(){
    this.tail = []
    this.x = 160
    this.y = 250;
    this.speed = 5 + Math.random() * 2;
    this.switch = false;
    this.rotate = (Math.PI / 6 + Math.random() * Math.PI * 2 / 3) * -1;
    this.lifetime = 10;
    this.draw = function(){
      ctx.save();
      ctx.translate(160, 250);
      ctx.rotate(this.rotate)
      ctx.translate(-160, -250)
      this.tail.forEach((ele, i) => {
        ctx.globalAlpha = .85 - .15 * i;
        DrawCircle(ele[0], ele[1], 18 - 2 * i, "black");
        ctx.globalAlpha = 1;
      })
      DrawCircle(this.x, this.y, 20, "black");
      ctx.restore();
      this.switch ? this.tail.unshift([this.x, this.y]) : this.switch = !this.switch;
      if(this.tail.length > 9){
        this.tail.pop()
      }
      this.x += this.speed;
      this.y += Math.sin(Date.now() / 100) * 5;
      this.x > 550 ? this.lifetime = 0 : null;
    }
  }

    function DrawRect(x, y, width, height, color) {
      ctx.beginPath();
      ctx.fillStyle = color;
      ctx.fillRect(x, y, width, height);
    };

    function DrawCircle(x, y, radius, color) {
      ctx.beginPath();
      ctx.fillStyle = color;
      ctx.arc(x, y, radius, 0, 2 * Math.PI)
      ctx.fill();
    };

    function DrawStroke(x, y, radius, color, stroke) {
      ctx.beginPath();
      ctx.strokeStyle = color;
      ctx.lineWidth = stroke;
      ctx.arc(x, y, radius, 0, 2 * Math.PI)
      ctx.stroke();
    };

    function IdleState() {
    let lightness = new Int8Array(engine.zone.lightness);
    let sat = new Int8Array(engine.zone.saturation);
    let hue = new Int16Array(engine.zone.hue);

    for (var iZone = 0; iZone < 560; iZone++) {
      ctx.fillStyle = 'hsl(' + hue[iZone] + ',' + sat[iZone] + '%,' + lightness[iZone] * Brightness / 100 + '%)'
      var iRow = Math.floor(iZone / 28);
      var iCol = iZone % 28;
      var iWidth = 320 / 28;
      var iHeight = 200 / 20;
      var iZx = iCol * iWidth;
      var iZy = iRow * iHeight;

      ctx.fillRect(iZx, iZy, iWidth, iHeight);

    }
  }
  
    function StateHandler() {
      var stack = [];
      var state = null;
  
      // Set current state to the top item in the stack
      var updateState = function () {
        if (stack.length > 0) {
          state = stack[stack.length - 1];
        } else {
          state = null;
        }
      };
  
      // Allows dev to add effect to state handler
      this.Push = function (newState) {
        stack.push(newState);
        updateState();
      };
      // Allows dev to remove effect from handler
      this.Pop = function () {
        stack.pop();
        updateState();
      };
      // Call the Process function of the current state (effect)
      this.Process = function () {
        if (state != null) {
          state.Process();
        }
      };
    }

    function Meter(count, callback) {
      this.size = count;
      this.value = 0;
      this.diff = 0;
      this.increased = false;
      this.decreased = false;
      var values = [];
  
      this.setValue = function (updatedValue) {
        // Add and shift.
        values.push(updatedValue);
        if (values.length > this.size) {
          values.shift();
        }
  
        // Exit early if we've got a long-term match.
        for (var i = 0; i < values.length - 1; i++) {
          if (values[i] !== values[i + 1]) return;
        }
  
        // We got here, so we've got a matching value collection.
        if (this.value !== values[0]) {
          //var fromZero = this.value === 0;
          //var toZero = values[0] === 0;
          this.diff = Math.abs(this.value - values[0]);
          this.increased = this.value < values[0];
          this.decreased = this.value > values[0];
          this.value = values[0];
  
          callback();
        }
      };
    }
  
  
  
    function onEngineReady() {
      // Grab canvas and rendering context.
      canvas = document.getElementById("exCanvas");
      ctx = canvas.getContext("2d");
      // Start updates *after* our engine is accessible and ready.
      window.requestAnimationFrame(update);
    }
  </script>
<head>
  <title>Team fight tactics </title>
  <meta description="Crush all your oponents with this team fight tactics integration" />
  <meta publisher="SignalRGB" />

  <meta property="keyScreenBrightness" label="Ambience brightness" type="number" min="0" max="100" default="100" />
  <meta property="EnablePlan" label="Enable plan effect" type="boolean" default="1" />
  <meta property="EnableCombat" label="Enable combat effect" type="boolean" default="1" />
  <meta property="EnableMoney" label="Enable money effect" type="boolean" default="1" />
  <meta property="EnableLevel" label="Enable level up effect" type="boolean" default="1" />
  <meta property="EnableLose" label="Enable lose effect" type="boolean" default="1" />
  <meta property="EnableWin" label="Enable win effect" type="boolean" default="1" />


  <meta meter="inGame" tags="VLC, league,teamfight" type="linear" x="0.9242" y="0.83402" width="0.0085" h="0-60"
    s="30-65" l="20-60">
  </meta>

  <meta meter="defautlUI" tags="VLC,league" type="area" x="0.4375" y="0.8102" width="0.001" height="0.001" h="0-60"
    s="30-65" l="20-60">
  </meta>

  <meta meter="timeBar" tags="VLC, league,teamfight" type="area" x="0.416796" y="0.04444" width="0.16484"
    height="0.0001" h="160-200" s="30-90" l="60-100">

  <resolution size="1280x800" x="0.416796" y="0.04444" width="0.17484" height="0.0001" />
  <resolution size="1440x900" x="0.416796" y="0.04444" width="0.17484" height="0.0001" />
  <resolution size="1680x1050" x="0.416796" y="0.04444" width="0.17484" height="0.0001" />
  <resolution size="2560x1600" x="0.416796" y="0.04444" width="0.17484" height="0.0001" />
  <resolution size="1920x1200" x="0.416796" y="0.04444" width="0.17484" height="0.0001" />

  <resolution size="1280x960" x="0.389453" y="0.0465277" width="0.21992" height="0.0001" />
  <resolution size="1400x1050" x="0.389453" y="0.0465277" width="0.21992" height="0.0001" />
  <resolution size="1440x1080" x="0.389453" y="0.0465277" width="0.21992" height="0.0001" />
  <resolution size="1600x1200" x="0.389453" y="0.0465277" width="0.21992" height="0.0001" />
  <resolution size="1856x1292" x="0.389453" y="0.0465277" width="0.21992" height="0.0001" />
  <resolution size="1920x1440" x="0.389453" y="0.0465277" width="0.21992" height="0.0001" />
  </meta>

  <meta meter="stateSwitch" tags="VLC, league,teamfight" type="area" x="0.5406" y="0.125" width="0.001" height="0.0001"
    h="160-200" s="30-100" l="60-100">
  </meta>

  <meta meter="stateSwitchPlanningConfirmation" tags="VLC, league,teamfight" type="area" x="0.49375" y="0.1594277"
    width="0.00390625" height="0.0001" h=" 30-70" s="0-30" l="70-100">
  <resolution size="1280x800" x="0.46875" y="0.1534722" width="0.00390625" height="0.0001" />
  <resolution size="1440x900" x="0.46875" y="0.1534722" width="0.00390625" height="0.0001" />
  <resolution size="1680x1050" x="0.46875" y="0.1534722" width="0.00390625" height="0.0001" />
  <resolution size="2560x1600" x="0.46875" y="0.1534722" width="0.00390625" height="0.0001" />
  <resolution size="1920x1200" x="0.46875" y="0.1534722" width="0.00390625" height="0.0001" />
  </meta>

  <meta meter="stateSwitchPlanningConfirmation2" tags="VLC, league,teamfight" type="area" x="0.5027" y="0.1594277"
    width="0.00390625" height="0.0001" h="30-70" s="0-30" l="70-100">
  <resolution size="1280x800" x="0.502343" y="0.160111" width="0.00390625" height="0.0001" />
  <resolution size="1440x900" x="0.502343" y="0.160111" width="0.00390625" height="0.0001" />
  <resolution size="1680x1050" x="0.502343" y="0.160111" width="0.00390625" height="0.0001" />
  <resolution size="2560x1600" x="0.502343" y="0.160111" width="0.00390625" height="0.0001" />
  <resolution size="1920x1200" x="0.502343" y="0.160111" width="0.00390625" height="0.0001" />
  </meta>

  <meta meter="stateSwitchCombat" tags="VLC, league,teamfight" type="area" x="0.5406" y="0.125" width="0.01"
    height="0.0001" h="0-360" s="0-10" l="95-100">
  </meta>

  <meta meter="stateSwitchCombat2" tags="VLC, league,teamfight" type="area" x="0.5011" y="0.10625" width="0.005"
    height="0.0001" h="30-70" s="0-25" l="75-100">
  </meta>

  <!-- <meta meter="scoreCount" tags="VLC, league,teamfight" type="ocr_numeric" x=".521975" y=".8159" width=".0069"
    height=".023" confidence="70">
  </meta>

  <meta meter="scoreCount2" tags="VLC, league,teamfight" type="ocr_numeric" x=".521975" y=".8149" width=".0071"
    height=".024" confidence="70">
  </meta> -->

  <meta meter="win" tags="VLC, league,teamfight" type="area" x="0.509" y="0.82291" width="0.0001" height="0.0001"
    h="0-50" s="60-100" l="60-100">
  <resolution size="1280x800" x="0.51054" y="0.82291" width="0.0001" height="0.0001" />
  <resolution size="1440x900" x="0.51054" y="0.82291" width="0.0001" height="0.0001" />
  <resolution size="1680x1050" x="0.51054" y="0.82291" width="0.0001" height="0.0001" />
  <resolution size="2560x1600" x="0.51054" y="0.82291" width="0.0001" height="0.0001" />
  <resolution size="1920x1200" x="0.51054" y="0.82291" width="0.0001" height="0.0001" />

  <resolution size="1280x960" x="0.5125" y="0.82222" width="0.0001" height="0.0001" />
  <resolution size="1400x1050" x="0.5125" y="0.82222" width="0.0001" height="0.0001" />
  <resolution size="1440x1080" x="0.5125" y="0.82222" width="0.0001" height="0.0001" />
  <resolution size="1600x1200" x="0.5125" y="0.82222" width="0.0001" height="0.0001" />
  <resolution size="1856x1292" x="0.5125" y="0.82222" width="0.0001" height="0.0001" />
  <resolution size="1920x1440" x="0.5125" y="0.82222" width="0.0001" height="0.0001" />
  </meta>

  <meta meter="lose" tags="VLC, league,teamfight" type="area" x="0.509" y="0.82291" width="0.0001" height="0.0001"
    h="170-220" s="40-90" l="40-100">
  <resolution size="1280x800" x="0.51054" y="0.82291" width="0.0001" height="0.0001" />
  <resolution size="1440x900" x="0.51054" y="0.82291" width="0.0001" height="0.0001" />
  <resolution size="1680x1050" x="0.51054" y="0.82291" width="0.0001" height="0.0001" />
  <resolution size="2560x1600" x="0.51054" y="0.82291" width="0.0001" height="0.0001" />
  <resolution size="1920x1200" x="0.51054" y="0.82291" width="0.0001" height="0.0001" />

  <resolution size="1280x960" x="0.5125" y="0.82222" width="0.0001" height="0.0001" />
  <resolution size="1400x1050" x="0.5125" y="0.82222" width="0.0001" height="0.0001" />
  <resolution size="1440x1080" x="0.5125" y="0.82222" width="0.0001" height="0.0001" />
  <resolution size="1600x1200" x="0.5125" y="0.82222" width="0.0001" height="0.0001" />
  <resolution size="1856x1292" x="0.5125" y="0.82222" width="0.0001" height="0.0001" />
  <resolution size="1920x1440" x="0.5125" y="0.82222" width="0.0001" height="0.0001" />
  </meta>

  <meta meter="moneyCount" tags="VLC, league,teamfight" type="ocr_numeric" x=".4573125" y=".819833" width=".014"
    height=".021" confidence="50">
  <resolution size="1280x800" x=".4523125" y=".819833" width=".014" height=".023" />
  <resolution size="1440x900" x=".4523125" y=".819833" width=".014" height=".023" />
  <resolution size="1680x1050" x=".4523125" y=".819833" width=".014" height=".023" />
  <resolution size="2560x1600" x=".4523125" y=".819833" width=".014" height=".023" />
  <resolution size="1920x1200" x=".4523125" y=".819833" width=".014" height=".023" />


  <resolution size="1280x960" x=".43828" y=".8201" width=".03319" height=".021" />
  <resolution size="1400x1050" x=".43828" y=".8201" width=".03319" height=".021" />
  <resolution size="1440x1080" x=".43828" y=".8201" width=".03319" height=".021" />
  <resolution size="1600x1200" x=".43828" y=".8201" width=".03319" height=".021" />
  <resolution size="1856x1292" x=".43828" y=".8201" width=".03319" height=".021" />
  <resolution size="1920x1440" x=".43828" y=".8201" width=".03319" height=".021" />
  </meta>

  <meta meter="lvlUp" tags="VLC, league,teamfight" x=".1654" y=".819" width=".012" height=".022" type="ocr_numeric"
    confidence="50" />
  <resolution size="1280x800" x=".126218" y=".81666" width=".018" height=".024" />
  <resolution size="1440x900" x=".126218" y=".81666" width=".018" height=".024" />
  <resolution size="1680x1050" x=".126218" y=".81666" width=".018" height=".024" />
  <resolution size="2560x1600" x=".126218" y=".81666" width=".018" height=".024" />
  <resolution size="1920x1200" x=".126218" y=".81666" width=".018" height=".024" />


  <resolution size="1280x960" x=".05256" y=".81736" width=".012" height=".023" />
  <resolution size="1400x1050" x=".05256" y=".81736" width=".012" height=".023" />
  <resolution size="1440x1080" x=".05256" y=".81736" width=".012" height=".023" />
  <resolution size="1600x1200" x=".05256" y=".81736" width=".012" height=".023" />
  <resolution size="1856x1292" x=".05256" y=".81736" width=".012" height=".023" />
  <resolution size="1920x1440" x=".05256" y=".81736" width=".012" height=".023" />
</head>

<body style="margin: 0; padding: 0; background: #000;">
  <canvas id="exCanvas" width="320" height="200"></canvas>
</body>

<script>
  var canvas, ctx;
  canvas = document.getElementById('exCanvas');
  ctx = canvas.getContext('2d');
  var width = 320;
  var height = 200;
  var stateHdlr = new StateHandler();
  var effects = [];
  var stagePlaying = false;
  var totaltime = GetTime();
  this.starttime = GetTime()
  var inGame = false;
  var timeBarMeter = new Meter(5, () => "")
  var combatMeter = new Meter(5, OnCombatChanged)
  var combatMeter2 = new Meter(5, OnCombatChanged)
  var stateMeter = new Meter(5, () => "")
  var planningConfirmationMeter = new Meter(5, OnPlanningChanged)
  var planningConfirmationMeter2 = new Meter(5, OnPlanningChanged)
  var inGameMeter = new Meter(5, OnGameChanged)
  // var scoreCounterMeter = new Meter(2, OnCounterChanged)
  // var scoreCounterMeter2 = new Meter(2, OnCounterChanged)
  var moneyMeter = new Meter(1, OnMoneyChanged)
  var UIMeter = new Meter(5, () => "")
  var winMeter = new Meter(5, () => "")
  var loseMeter = new Meter(5, () => "")
  var levelUpMeter = new Meter(5, onLevelUpChanged)
  var unkownStateMeter = new Meter(5, () => "")
  var prevScore = 0;
  var winstreak = false;
  var prevMoney = 0;
  var winTrue = null;
  var loseTrue = null;
  var PlayWinLose = false;
  var prevLVL = 0;
  const a = 2 * Math.PI / 6;
  var sword = "M5772 5963 c-18 -2 -150 -24 -294 -48 l-262 -44 -676 -678 c-372 -373 -1235 -1240 -1918 -1928 l-1242 -1249 -113 111 -112 112 -360 125 c-198 68 -362 120 -363 115 -6 -16 80 -110 429 -469 185 -190 349 -359 363 -377 l26 -31 -334 -344 c-183 -189 -383 -391 -442 -449 l-109 -105 -77 -13 c-90 -14 -147 -48 -212 -124 -64 -77 -69 -91 -74 -213 -5 -132 8 -173 85 -255 77 -82 107 -94 248 -94 140 0 171 11 247 92 56 61 76 98 99 186 13 53 29 81 72 135 79 96 822 832 841 832 8 0 202 -185 431 -410 228 -226 420 -410 426 -410 16 0 7 33 -117 403 l-114 342 -107 107 -107 107 126 133 c69 73 930 939 1912 1925 l1786 1791 20 139 c11 76 34 212 50 303 16 91 32 193 35 228 l7 62 -69 -2 c-37 0 -83 -3 -101 -5z"
  var cup = "M2225 4830 c-426 -16 -813 -62 -1139 -135 l-108 -25 -70 31 c-93 41 -184 59 -298 59 -157 0 -259 -38 -351 -129 -30 -31 -66 -78 -80 -106 -22 -45 -24 -62 -24 -180 0 -149 14 -201 93 -360 103 -206 252 -396 540 -685 l214 -215 -16 -45 c-37 -104 -8 -199 78 -257 41 -28 57 -33 108 -33 88 0 146 35 196 118 l19 33 64 -127 c206 -411 471 -683 850 -875 59 -29 61 -31 40 -45 -36 -26 -27 -53 27 -76 26 -11 49 -22 51 -24 2 -2 -12 -21 -31 -42 -57 -63 -81 -140 -76 -242 5 -103 36 -173 105 -236 l45 -41 -49 -12 c-106 -27 -124 -70 -43 -104 28 -11 50 -24 50 -28 0 -12 -81 -75 -126 -97 -22 -12 -83 -33 -135 -47 -201 -57 -446 -165 -590 -261 -72 -48 -144 -120 -159 -160 -6 -14 -10 -56 -10 -94 0 -83 -1 -82 161 -130 272 -81 808 -140 1139 -126 378 16 847 93 996 163 l39 18 3 77 c3 88 -6 113 -65 172 -115 115 -398 257 -673 336 -63 18 -132 41 -153 52 -38 19 -117 85 -117 97 0 4 20 17 45 29 73 35 56 76 -42 102 -50 12 -53 21 -17 40 14 8 40 35 59 60 91 125 87 314 -10 427 -19 23 -35 44 -35 47 0 3 20 14 45 25 49 21 56 42 28 73 -9 10 -14 20 -12 22 2 1 54 29 115 60 320 165 603 466 784 834 30 62 58 112 61 112 4 0 16 -16 28 -35 11 -19 42 -49 68 -66 44 -28 54 -30 119 -27 78 4 120 27 166 90 30 43 37 146 14 203 l-16 38 178 176 c368 365 555 620 644 884 27 80 31 106 31 197 0 135 -22 196 -100 280 -89 97 -201 140 -363 140 -112 0 -233 -26 -317 -68 -46 -23 -64 -27 -87 -21 -115 32 -664 109 -956 133 -157 14 -256 18 -625 30 -60 2 -200 0 -310 -4z m-1557 -297 c-43 -85 -51 -112 -50 -180 1 -82 21 -139 71 -196 95 -107 277 -122 394 -33 19 15 37 26 40 26 4 0 7 -22 7 -49 0 -54 25 -298 40 -400 25 -163 67 -346 128 -555 10 -37 -41 5 -184 149 -377 381 -612 694 -679 908 -54 170 -15 266 128 317 53 19 112 26 105 13z m3937 -29 c77 -36 108 -80 113 -159 11 -165 -129 -414 -423 -755 -119 -137 -432 -456 -441 -448 -3 4 10 67 30 140 62 230 103 473 125 736 5 63 12 116 15 119 3 4 14 -1 23 -9 78 -68 216 -84 309 -35 148 76 204 248 129 396 l-27 54 46 -6 c26 -4 71 -18 101 -33z"
  var stopBackground = false
  var isCombatStage = false;

  function update() {
    totaltime = GetTime() - this.starttime;
    if (!stopBackground) {
      copyScreen(1);
    }

    inGameMeter.setValue(engine.vision.inGame)
    planningConfirmationMeter.setValue(engine.vision.stateSwitchPlanningConfirmation)
    planningConfirmationMeter2.setValue(engine.vision.stateSwitchPlanningConfirmation2)
    stateMeter.setValue(engine.vision.stateSwitch)
    combatMeter.setValue(engine.vision.stateSwitchCombat)
    combatMeter2.setValue(engine.vision.stateSwitchCombat2)
    // scoreCounterMeter.setValue(engine.vision.scoreCount);
    // scoreCounterMeter2.setValue(engine.vision.scoreCount2);
    winMeter.setValue(engine.vision.win)
    loseMeter.setValue(engine.vision.lose)
    moneyMeter.setValue(engine.vision.moneyCount)
    UIMeter.setValue(engine.vision.defautlUI)
    timeBarMeter.setValue(engine.vision.timeBar)
    levelUpMeter.setValue(engine.vision.lvlUp)
    unkownStateMeter.setValue(engine.vision.unkownState)

    for (let i = 0; i < effects.length; i++) {
      effects[i].draw();
      if (effects[i].lifetime <= 0) {
        effects.splice(i, 1);
      }
    };

    //use TimebarMeter for HUD effect?

    if (timeBarMeter.value < 0.1 && isCombatStage) {
      OnScoreUp()
    }

    stateHdlr.Process();
    window.requestAnimationFrame(update);
  };

  function onLevelUpChanged() {

    if (levelUpMeter.value > prevLVL && levelUpMeter.value != -1 && inGame && UIMeter.value == 1 && EnableLevel) {
      console.log(engine.vision.lvlUp)
      effects.push(new ArrowEffect("up", "blue", levelUpMeter.value, 5, 4000))
      prevLVL = levelUpMeter.value

    } else if (levelUpMeter.value == 2) {
      prevLVL = 2;
    } else if (levelUpMeter.value == prevLVL - 1) {
      prevLVL = levelUpMeter.value
    }
  }


  // callbacks
  // function OnCounterChanged() {

  //   if (scoreCounterMeter.value != -1 && UIMeter.value == 1) {
  //     if (scoreCounterMeter.value > prevScore || scoreCounterMeter2.value > prevScore) {
  //       prevScore = scoreCounterMeter.value;
  //       setTimeout(() => {
  //         PlayWinLose = true;
  //       }, 100);
  //     } else if (scoreCounterMeter.value == 1 && prevScore > 1 || scoreCounterMeter.value == 1 && prevScore == 0) {
  //       prevScore = scoreCounterMeter.value;
  //       setTimeout(() => {
  //         PlayWinLose = true;
  //       }, 100);

  //     }
  //   }
  // }


  // function OnWinLoseChanged() {
  //   if (!winTrue) {
  //     if (UIMeter.value == 1 && inGame) {
  //       if (winMeter.value == 1) {
  //         winTrue = true;
  //         loseTrue = false;
  //         prevScore = 0;
  //         setTimeout(() => {
  //           PlayWinLose = true;
  //         }, 100);
  //       }
  //     } else if (!loseTrue) {
  //       if (loseMeter.value > winMeter.value) {
  //         winTrue = false;
  //         loseTrue = true;
  //         prevScore = 0;
  //         setTimeout(() => {
  //           PlayWinLose = true;
  //         }, 100);
  //       }
  //     } else if (unkownStateMeter.value == 1) {
  //       prevScore = 0;
  //     }
  //   }

  // }

  function OnScoreUp() {
    if (isCombatStage) {
      if (winMeter.value == 1 && EnableWin) {
        effects.push(new WinEffect())
      } else if (loseMeter.value == 1 && EnableLose) {
        effects.push(new FadetoBlack());
        setTimeout(() => {
          effects.length = 0;
          effects.push(new loseEffect())
        }, 800);
      }
      isCombatStage = false;
    }

  }

  function OnMoneyChanged() {
    if (UIMeter.value == 1) {
      if (moneyMeter.value != -1) {
        if (moneyMeter.value < prevMoney && EnableMoney) {
          effects.push(new moneyEffect())
        }
        prevMoney = moneyMeter.value;
      }

    }
  }

  function OnGameChanged() {
    if (inGameMeter.value == 1) {
      console.log(`in game, time=${totaltime}`)
      inGame = true;
      onLevelUpChanged()
    } else {
      inGame = false;
    }
  }

  function OnCombatChanged() {
    if (inGame) {
      if (combatMeter.value == 1 || combatMeter2.value == 1 && stateMeter.value == 1 && EnableCombat) {
        if (!stagePlaying) {
          stagePlaying = true;
          setTimeout(() => {
            stagePlaying = false;
            setTimeout(() => {
              isCombatStage = true;
            }, 4500);
          }, 2000);
          effects.push(new CombatEffect())
        }

      }
    }
  }

  function OnPlanningChanged() {
    if (inGame) {
      if (planningConfirmationMeter.value == 1 && stateMeter.value == 1 && planningConfirmationMeter2.value == 1 && EnablePlan) {
        if (stagePlaying == false) {
          stagePlaying = true;
          setTimeout(() => {
            stagePlaying = false;
          }, 3000);
          effects.push(new FadetoBlack());
          setTimeout(() => {
            effects.push(new PlanEffect())
          }, 800);

        }

      }
    }
  }


  function WinEffect() {
    this.elapsed;
    this.start = GetTime();
    this.draw = function () {
      this.elapsed = GetTime() - this.start
      this.moveVal = this.elapsed / 8

      ctx.fillStyle = "black"
      ctx.fillRect(0, 0, 320, 200)
      copyScreen(1 - this.moveVal / 100)
      ctx.beginPath();
      ctx.save();
      ctx.translate(230, 500 - this.moveVal)
      effects.push(new ballPhysics(160, 260 - this.moveVal, Math.random() * 40, "yellow"))
      ctx.rotate(180 * Math.PI / 180)
      renderPath(0, 0, cup, "yellow", 0.3)
      ctx.restore();
      if (this.elapsed > 2000) {
        copyScreen(0 + (this.moveVal - 250) / 200)
        if (this.elapsed > 3000) {
          this.lifetime = 0
        }
      }
    }
  }

  function loseEffect() {
    this.elapsed;
    this.drops = []
    stopBackground = true;
    this.start = GetTime();
    for (let index = 0; index < 30; index++) {
      setTimeout(() => {
        this.drops.push(new drop(20, "blue"))
      }, 100 * index);

      this.draw = function () {
        stopBackground = true;
        this.elapsed = GetTime() - this.start

        this.moveVal = this.elapsed / 5
        ctx.beginPath()
        ctx.fillStyle = "black"
        ctx.globalAlpha = 0.01
        ctx.fillRect(0, 0, 320, 200)
        ctx.globalAlpha = 1
        this.drops.forEach(element => {
          element.draw()
        });
        if (this.elapsed > 5000) {

          copyScreen(0 + (this.elapsed - 5000) / 200)
        } else if (this.elapsed > 7000) {
          this.lifetime = 0;
          stopBackground = false;
        }
      }
    }
  }


  function ballPhysics(x, y, radius, color) {
    this.radius = radius;
    this.color = color;
    this.x = x;
    this.vx = 7 * Math.sin(radius);
    this.y = y;
    this.vy = -15;
    this.ay = 1;
    this.lifetime = 10;
    this.draw = function () {
      ctx.beginPath();
      ctx.fillStyle = this.color;
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
      ctx.fill();
      this.x += this.vx;
      this.y += this.vy;
      this.vy += this.ay;
      if (this.y > height) {
        this.lifetime = 0;
      }
    }
  };

  function PlanEffect() {
    this.grid = MakeGrid(8, 5, 30)
    this.glowingHexagons = [];
    this.elapsed = 1;
    this.alpha = 0;
    this.start = GetTime();
    for (let index = 0; index < 100; index++) {
      let TimedGlow = {
        time: Math.random() * 4000 + this.elapsed,
        x: Math.floor(Math.random() * 9),
        y: Math.floor(Math.random() * 6),
        glowTime: 0
      }
      this.glowingHexagons.push(TimedGlow)
    }
    this.draw = function () {
      this.elapsed = GetTime() - this.start;
      this.grid.forEach((hexagon, index) => {
        this.glowingHexagons.forEach((glow, glowloc) => {
          if (hexagon.xpos == glow.x && hexagon.ypos == glow.y) {
            if (glow.time < this.elapsed) {
              glow.glowTime = this.elapsed - glow.time;
              hexagon.color = `hsl(${235 - Math.sin((glow.glowTime / 300)) * 60}, 100%, 50%)`
              if (235 - Math.sin((glow.glowTime / 300)) * 60 > 240) {
                this.glowingHexagons.splice(glowloc, 1);
                let TimedGlow = {
                  time: Math.random() * 1000 + this.elapsed,
                  x: Math.ceil(Math.random() * 9),
                  y: Math.ceil(Math.random() * 6),
                  glowTime: 0
                }
                this.glowingHexagons.push(TimedGlow)
              }
            }
          }
        });

        hexagon.draw();
      });
      if (this.elapsed > 4000) {
        this.alpha += 0.02;
        copyScreen(this.alpha)
        if (this.alpha > 1) {
          this.lifetime = 0;
        }
      }
    }
  }

  function CombatEffect() {
    this.start = GetTime();
    this.elapsed = 0;
    this.moveVal = 0;
    this.alpha = 0;
    this.particleActive = false;
    this.firstSwordLoc = {
      x: 0,
      y: 230
    }
    this.secondSwordLoc = {
      x: 150,
      y: 300
    }
    this.draw = function () {
      if (this.elapsed < 1000) {
        ctx.globalAlpha = this.elapsed / 1000
      }
      this.elapsed = GetTime() - this.start;
      ctx.beginPath();
      ctx.fillStyle = "black"
      ctx.fillRect(0, 0, 320, 200);
      this.moveVal = Math.sin(this.elapsed / 200);
      ctx.save();
      ctx.translate(this.firstSwordLoc.x, this.firstSwordLoc.y)
      ctx.rotate(this.moveVal / 2 + 4.1)
      renderPath(0, 0, sword, "blue", 0.3)
      ctx.restore();
      ctx.save();
      ctx.translate(this.secondSwordLoc.x, this.secondSwordLoc.y)
      ctx.rotate(-this.moveVal / 2 + 4.1)
      renderPath(0, 0, sword, "red", 0.3)
      ctx.restore();
      if (this.moveVal > 0.97 && this.particleActive == false) {
        effects.push(new ParticleExplosion(160, 100, "orange", 10, 1000, 10, 10, 1))
        this.particleActive = true;
      } else if (this.moveVal < 9) {
        this.particleActive = false
      }

      if (this.elapsed > 4000) {
        this.alpha += 0.01;
        copyScreen(this.alpha)
        if (this.alpha > 1) {
          this.lifetime = 0;
        }
      }
    }
  }


  function ArrowEffect(direction, color, amount, speed, duration) {
    this.start = GetTime();
    this.speed = speed;
    this.duration = duration;
    this.lifetime = this.duration;
    this.direction = direction;
    this.color = color;
    this.amount = amount;
    this.draw = function () {
      if (this.direction == 'up') {
        this.speed = -this.speed;
        ctx.fillStyle = this.color;
        for (let i = 0; i < this.amount; i++) {
          ctx.beginPath();
          ctx.moveTo(160, this.lifetime / 1.5 - 150 - (200 * i));
          ctx.lineTo(320, this.lifetime / 1.5 - (200 * i));
          ctx.lineTo(320, this.lifetime / 1.5 - (200 * i) + 100);
          ctx.lineTo(160, this.lifetime / 1.5 - (200 * i) - 100);
          ctx.lineTo(0, this.lifetime / 1.5 - (200 * i) + 100);
          ctx.lineTo(0, this.lifetime / 1.5 - (200 * i));
          ctx.lineTo(160, this.lifetime / 1.5 - (200 * i) - 150);
          ctx.fill();
        }
      } else {
        ctx.fillStyle = this.color;
        for (let i = 0; i < this.amount; i++) {
          ctx.beginPath();
          ctx.moveTo(160, 300 - this.lifetime / 1.5 + (200 * i));
          ctx.lineTo(320, 240 - this.lifetime / 1.5 + (200 * i));
          ctx.lineTo(320, 180 - this.lifetime / 1.5 + (200 * i));
          ctx.lineTo(160, 240 - this.lifetime / 1.5 + (200 * i));
          ctx.lineTo(0, 180 - this.lifetime / 1.5 + (200 * i));
          ctx.lineTo(0, 240 - this.lifetime / 1.5 + (200 * i));
          ctx.lineTo(160, 300 - this.lifetime / 1.5 + (200 * i));
          ctx.fill();
        }
      }
      this.Ymin += this.speed;
      this.elapsed = new Date().getTime() - this.start;
      this.lifetime = this.duration - this.elapsed;
      if (this.lifetime <= 0) {
        speedAnim = false
      }
    }
  }

  function moneyEffect() {
    this.elapsed;
    this.moneyArray = [];
    this.start = GetTime();
    for (let index = 0; index < 30; index++) {
      setTimeout(() => {
        this.moneyArray.push(new drop(20, "red"))
      }, 100 * index);
    }
    this.draw = function () {
      this.elapsed = GetTime() - this.start
      this.moneyArray.forEach(coin => {
        coin.draw()
      });
      if (this.elapsed > 4000) {
        this.lifetime = 0
      }
    }
  }

  class drop {
    constructor(radius, col) {
      this.x = Math.random() * 320
      this.y = Math.random() * -50
      this.radius = radius
      this.col = col
    }

    draw() {
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2)
      ctx.fillStyle = this.col
      ctx.fill()
      this.y += 5
    }
  }

  function renderPath(x, y, path, color, size) {
    ctx.fillStyle = color;
    ctx.save();
    ctx.transform(size / 10, 0, 0, size / 10, 160 - 10 * 16.5, 79 - size * 7.5);
    ctx.translate(x, y);
    let ex = new Path2D(path);
    ctx.fill(ex);
    ctx.restore();
  }

  function DrawCircle(x, y, radius, color) {
    ctx.beginPath();
    ctx.fillStyle = color;
    ctx.arc(x, y, radius, 0, 2 * Math.PI)
    ctx.fill();
  };

  function DrawStrokeCircle(x, y, radius, color, stroke) {
    ctx.beginPath();
    ctx.strokeStyle = color;
    ctx.lineWidth = stroke;
    ctx.arc(x, y, radius, 0, 2 * Math.PI)
    ctx.stroke();
  };

  function drawRect(x, y, height, width, color) {
    ctx.beginPath();
    ctx.fillStyle = color;
    ctx.fillRect(x, y, height, width);
  }

  function hexagon(x, y, color, size, xpos, ypos) {
    this.x = x;
    this.y = y;
    this.color = color;
    this.size = size;
    this.xpos = xpos;
    this.ypos = ypos;


    this.draw = function () {
      ctx.beginPath();
      for (var i = 0; i < 7; i++) {
        ctx.lineTo(this.x + this.size * Math.cos(a * i), this.y + this.size * 0.9 * Math.sin(a * i));
      }
      ctx.fillStyle = this.color;
      ctx.fill();
      ctx.strokeStyle = "black"
      ctx.stroke()
    }
  }

  function MakeGrid(width, height, size) {
    this.hexagons = []

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        if (x % 2 != 1) {
          this.offset = size * 0.8;
        } else {
          this.offset = 0;
        }
        this.hexagons.push(new hexagon(x * (size * 1.5), y * (size * 1.5) + this.offset, "hsl(230,50%,0%)", size, x, y))
      }
    }
    return this.hexagons;
  }

  function FadetoBlack() {
    this.alpha = 0;
    this.draw = function () {
      ctx.fillStyle = `hsla(0,0%,0%,${this.alpha})`
      ctx.fillRect(0, 0, 320, 200)
      this.alpha += 0.05;
      if (this.alpha > 10) {
        this.lifetime = 0;
      }
    }
  }

  function ParticleExplosion(x, y, color, speed, duration, particleAmount, particleSize, fadeSpeed) {
    this.start = GetTime();
    this.col = color;
    this.speed = speed;
    this.duration = duration;
    this.lifetime = 2000;
    this.amount = particleAmount;
    this.size = particleSize
    this.x = x;
    this.y = y;
    this.fadeSpeed = fadeSpeed;
    this.particles = [];

    while (this.particles.length < this.amount) {

      this.yspeed = ((Math.random() - 0.5) * this.speed);


      this.particles.push(new ExplosionParticle(this.x, this.y, this.size, this.col, this.fadeSpeed,
        {
          x: ((Math.random() - 0.5) * this.speed),
          y: this.yspeed
        }))



      this.draw = function () {
        this.lifetime = this.duration - (GetTime() - this.start)
        this.particles.forEach((Particle, index) => {
          Particle.draw()
        })
      }
    }
  };

  class ExplosionParticle {
    constructor(x, y, radius, color, fadeSpeed, velocity) {
      this.x = x;
      this.y = y;
      this.color = color;
      this.radius = radius;
      this.velocity = velocity;
      this.alpha = 1 * fadeSpeed;
    }
    draw() {
      ctx.globalAlpha = this.alpha;
      ctx.beginPath()
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false)
      ctx.fillStyle = this.color
      ctx.fill()
      this.x += this.velocity.x
      this.y += this.velocity.y
      this.alpha -= 0.01
      ctx.globalAlpha = 1;
    }
  }

  function copyScreen(alpha) {
    var shine = engine.vision.ShineMeter
    let lightness = new Int8Array(engine.zone.lightness);
    let sat = new Int8Array(engine.zone.saturation);
    let hue = new Int16Array(engine.zone.hue);
    for (var iZone = 0; iZone < 560; iZone++) {
      var iRow = Math.floor(iZone / 28);
      var iCol = iZone % 28;
      var iWidth = 320 / 28;
      var iHeight = 200 / 20;
      var iZx = iCol * iWidth;
      var iZy = iRow * iHeight;
      ctx.fillStyle =
        "hsla(" +
        hue[iZone] +
        "," +
        sat[iZone] +
        "%," +
        lightness[iZone] * keyScreenBrightness / 100 +
        "%, " +
        `${alpha}` +
        ")";

      ctx.fillRect(iZx, iZy, iWidth, iHeight);
    }

  }

  function GetTime() {
    return new Date().getTime()
  }

  function StateHandler() {
    var stack = [];
    var state = null;

    var updateState = function () {
      if (stack.length > 0) {
        state = stack[stack.length - 1];
      } else {
        state = null;
      }
    };

    this.Push = function (newState) {
      stack.push(newState);
      updateState();
    };

    this.Pop = function () {
      stack.pop();
      updateState();
    };

    this.Process = function () {
      if (state != null) {
        state.Process();
      }
    };
  }

  function Meter(size, callback) {
    this.size = size;
    this.value = 0;
    this.diff = 0;
    this.increased = false;
    this.decreased = false;
    var values = [];

    this.setValue = function (updatedValue) {
      values.push(updatedValue);
      if (values.length > this.size) {
        values.shift();
      }

      for (var i = 0; i < values.length - 1; i++) {
        if (values[i] !== values[i + 1]) return;
      }
      if (this.value !== values[0]) {
        this.diff = Math.abs(this.value - values[0]);
        this.increased = this.value < values[0];
        this.decreased = this.value > values[0];
        this.value = values[0];
        callback();
      }
    }
  }

  window.requestAnimationFrame(update);
</script>
<head>
  <title>Team fight tactics </title>
  <meta description="Crush all your oponents with this team fight tactics integration" />
  <meta publisher="SignalRGB" />

  <meta property="keyScreenBrightness" label="Ambience brightness" type="number" min="0" max="100" default="100" />


  <meta meter="inGame" tags="VLC, league,teamfight" type="linear" x="0.9242" y="0.83402" width="0.0085" h="0-60"
    s="30-65" l="20-60">
  </meta>

  <meta meter="defautlUI" tags="VLC, league,teamfight" type="linear" x="0.1378906" y="0.81041" width="0.0085" h="0-60"
    s="30-65" l="20-60">
  </meta>

  <meta meter="timeBar" tags="VLC, league,teamfight" type="area" x="0.416796" y="0.04444" width="0.16484"
    height="0.0001" h="160-200" s="30-90" l="60-100">
  </meta>

  <meta meter="stateSwitch" tags="VLC, league,teamfight" type="area" x="0.5406" y="0.125" width="0.001" height="0.0001"
    h="160-200" s="30-90" l="60-100">
  </meta>

  <meta meter="stateSwitchPlanningConfirmation" tags="VLC, league,teamfight" type="area" x="0.49375" y="0.1594277"
    width="0.00390625" height="0.0001" h="30-70" s="0-20" l="85-95">
  </meta>

  <meta meter="stateSwitchPlanningConfirmation2" tags="VLC, league,teamfight" type="area" x="0.5027" y="0.1594277"
    width="0.00390625" height="0.0001" h="30-70" s="0-20" l="85-95">
  </meta>

  <meta meter="stateSwitchCombat" tags="VLC, league,teamfight" type="area" x="0.5406" y="0.125" width="0.01"
    height="0.0001" h="0-360" s="0-10" l="95-100">
  </meta>

  <meta meter="stateSwitchCombat2" tags="VLC, league,teamfight" type="area" x="0.5011" y="0.10625" width="0.005"
    height="0.0001" h="30-70" s="0-20" l="85-95">
  </meta>

  <meta meter="scoreCount" tags="VLC, league,teamfight" type="ocr_numeric" x=".521975" y=".8159" width=".0069"
    height=".023" confidence="70">
  </meta>

  <meta meter="scoreCount2" tags="VLC, league,teamfight" type="ocr_numeric" x=".521975" y=".8149" width=".0071"
    height=".024" confidence="70">
  </meta>

  <meta meter="win" tags="VLC, league,teamfight" type="area" x="0.509" y="0.82291" width="0.0001" height="0.0001"
    h="0-50" s="60-100" l="60-100">
  </meta>

  <meta meter="lose" tags="VLC, league,teamfight" type="area" x="0.509" y="0.82291" width="0.0001" height="0.0001"
    h="170-220" s="40-90" l="40-100">
  </meta>

  <meta meter="moneyCount" tags="VLC, league,teamfight" type="ocr_numeric" x=".4573125" y=".819833" width=".014"
    height=".021" confidence="50">
  </meta>

  <meta meter="lvlUp" tags="VLC, league,teamfight" x=".1654" y=".819" width=".012" height=".022" type="ocr_numeric"
    confidence="50" />

</head>

<body style="margin: 0; padding: 0; background: #000;">
  <canvas id="exCanvas" width="320" height="200"></canvas>
</body>

<script>
  var canvas, ctx;
  canvas = document.getElementById('exCanvas');
  ctx = canvas.getContext('2d');
  var width = 320;
  var height = 200;
  var stateHdlr = new StateHandler();
  var effects = [];
  var stagePlaying = false;
  var totaltime = GetTime();
  this.starttime = GetTime()
  var inGame = false;
  var timeBarMeter = new Meter(5, () => "")
  var combatMeter = new Meter(5, OnCombatChanged)
  var combatMeter2 = new Meter(5, OnCombatChanged)
  var stateMeter = new Meter(5, () => "")
  var planningConfirmationMeter = new Meter(5, OnPlanningChanged)
  var planningConfirmationMeter2 = new Meter(5, OnPlanningChanged)
  var inGameMeter = new Meter(5, OnGameChanged)
  var scoreCounterMeter = new Meter(2, OnCounterChanged)
  var scoreCounterMeter2 = new Meter(2, OnCounterChanged)
  var moneyMeter = new Meter(1, OnMoneyChanged)
  var UIMeter = new Meter(5, () => "")
  var winMeter = new Meter(5, OnWinLoseChanged)
  var loseMeter = new Meter(5, OnWinLoseChanged)
  var prevScore = 0;
  var winstreak = false;
  var prevMoney = 0;
  var winTrue = true;
  var loseTrue = false;
  const a = 2 * Math.PI / 6;


  function update() {
    totaltime = GetTime() - this.starttime;
    copyScreen(1);
    console.log(engine.vision.lvlUp)
    inGameMeter.setValue(engine.vision.inGame)
    planningConfirmationMeter.setValue(engine.vision.stateSwitchPlanningConfirmation)
    planningConfirmationMeter2.setValue(engine.vision.stateSwitchPlanningConfirmation2)
    stateMeter.setValue(engine.vision.stateSwitch)
    combatMeter.setValue(engine.vision.stateSwitchCombat)
    combatMeter2.setValue(engine.vision.stateSwitchCombat2)
    scoreCounterMeter.setValue(engine.vision.scoreCount);
    scoreCounterMeter2.setValue(engine.vision.scoreCount2);
    winMeter.setValue(engine.vision.win)
    loseMeter.setValue(engine.vision.lose)
    moneyMeter.setValue(engine.vision.moneyCount)
    UIMeter.setValue(engine.vision.defautlUI)
    timeBarMeter.setValue(engine.vision.timeBar)

    for (let i = 0; i < effects.length; i++) {
      effects[i].draw();
      if (effects[i].lifetime <= 0) {
        effects.splice(i, 1);
      }
    };

    //use TimebarMeter for HUD effect?

    stateHdlr.Process();
    window.requestAnimationFrame(update);
  };




  //callbacks
  function OnCounterChanged() {

    if (scoreCounterMeter.value != -1) {
      if (scoreCounterMeter.value > prevScore || scoreCounterMeter2.value > prevScore) {
        prevScore = scoreCounterMeter.value;
        setTimeout(() => {
          OnScoreUp();
        }, 100);
      } else if (scoreCounterMeter.value == 1 && prevScore > 1 || scoreCounterMeter.value == 1 && prevScore == 0) {
        prevScore = scoreCounterMeter.value;
        setTimeout(() => {
          OnScoreUp();
        }, 100);

      }
    }
  }
  function OnWinLoseChanged() {
    if (!winTrue) {
      if (UIMeter.value == 1) {
        if (winMeter.value == 1) {
          winTrue = true;
          loseTrue = false;
          prevScore = 0;
          setTimeout(() => {
            OnScoreUp();
          }, 100);
        }
      } else if (!loseTrue) {
        if (loseMeter.value > winMeter.value) {
          winTrue = false;
          loseTrue = true;
          prevScore = 0;
          setTimeout(() => {
            OnScoreUp();
          }, 100);
        }
      }
    }

  }

  function OnScoreUp() {
    if (winMeter.value == 1) {
      console.log("Play round win effect")
    } else if (loseMeter.value == 1) {
      console.log("Play round lost effect")
    }
  }

  function OnMoneyChanged() {
    if (UIMeter.value == 1) {
      if (moneyMeter.value != -1) {

        if (moneyMeter.value < prevMoney) {
          console.log("Play money decreased effect")
        }
        prevMoney = moneyMeter.value;
      }

    }

  }

  function OnGameChanged() {
    if (inGameMeter.value == 1) {
      console.log(`in game, time=${totaltime}`)
      inGame = true;
    } else {
      inGame = false;
    }
  }

  function OnCombatChanged() {
    if (inGame) {
      if (combatMeter.value == 1 || combatMeter2.value == 1 && stateMeter.value == 1) {
        if (!stagePlaying) {
          stagePlaying = true;
          setTimeout(() => {
            stagePlaying = false;
          }, 2000);


          console.log(`play combat stage effect, time=${totaltime}`)
        }

      }
    }
  }

  function OnPlanningChanged() {
    if (inGame) {
      if (planningConfirmationMeter.value == 1 && stateMeter.value == 1 && planningConfirmationMeter2.value == 1) {
        if (stagePlaying == false) {
          stagePlaying = true;
          setTimeout(() => {
            stagePlaying = false;
          }, 2000);
          effects.push(new FadetoBlack());
          setTimeout(() => {
            effects.push(new PlanEffect())
          }, 800);

        }

      }
    }
  }

  function PlanEffect() {

    this.grid = MakeGrid(8, 5, 30)
    this.glowingHexagons = [];
    this.elapsed = 1;
    this.alpha = 0;
    this.start = GetTime();
    for (let index = 0; index < 100; index++) {
      let TimedGlow = {
        time: Math.random() * 4000 + this.elapsed,
        x: Math.floor(Math.random() * 9),
        y: Math.floor(Math.random() * 6),
        glowTime: 0
      }
      this.glowingHexagons.push(TimedGlow)
    }
    this.draw = function () {
      this.elapsed = GetTime() - this.start;
      this.grid.forEach((hexagon, index) => {
        this.glowingHexagons.forEach((glow, glowloc) => {
          if (hexagon.xpos == glow.x && hexagon.ypos == glow.y) {
            if (glow.time < this.elapsed) {
              glow.glowTime = this.elapsed - glow.time;
              hexagon.color = `hsl(${235 - Math.sin((glow.glowTime / 300)) * 60}, 100%, 50%)`
              if (235 - Math.sin((glow.glowTime / 300)) * 60 > 240) {
                this.glowingHexagons.splice(glowloc, 1);
                let TimedGlow = {
                  time: Math.random() * 1000 + this.elapsed,
                  x: Math.ceil(Math.random() * 8),
                  y: Math.ceil(Math.random() * 5),
                  glowTime: 0
                }
                this.glowingHexagons.push(TimedGlow)
              }
            }
          }
        });

        hexagon.draw();
      });
      if (this.elapsed > 7000) {
        this.alpha += 0.02;
        copyScreen(this.alpha)
        if (this.alpha > 1) {
          this.lifetime = 0;
        }
      }
    }

  }



  function renderPath(x, y, path, color) {
    ctx.fillStyle = color;
    ctx.save();
    ctx.translate(x, y);
    let ex = new Path2D(path);
    ctx.fill(ex);
    ctx.restore();
  }

  function DrawCircle(x, y, radius, color) {
    ctx.beginPath();
    ctx.fillStyle = color;
    ctx.arc(x, y, radius, 0, 2 * Math.PI)
    ctx.fill();
  };

  function DrawStrokeCircle(x, y, radius, color, stroke) {
    ctx.beginPath();
    ctx.strokeStyle = color;
    ctx.lineWidth = stroke;
    ctx.arc(x, y, radius, 0, 2 * Math.PI)
    ctx.stroke();
  };

  function drawRect(x, y, height, width, color) {
    ctx.beginPath();
    ctx.fillStyle = color;
    ctx.fillRect(x, y, height, width);
  }

  function hexagon(x, y, color, size, xpos, ypos) {
    this.x = x;
    this.y = y;
    this.color = color;
    this.size = size;
    this.xpos = xpos;
    this.ypos = ypos;


    this.draw = function () {
      ctx.beginPath();
      for (var i = 0; i < 7; i++) {
        ctx.lineTo(this.x + this.size * Math.cos(a * i), this.y + this.size * 0.9 * Math.sin(a * i));
      }
      ctx.fillStyle = this.color;
      ctx.fill();
      ctx.strokeStyle = "black"
      ctx.stroke()
    }
  }

  function MakeGrid(width, height, size) {
    this.hexagons = []

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        if (x % 2 != 1) {
          this.offset = size * 0.8;
        } else {
          this.offset = 0;
        }
        this.hexagons.push(new hexagon(x * (size * 1.5), y * (size * 1.5) + this.offset, "hsl(230,50%,0%)", size, x, y))
      }
    }
    return this.hexagons;
  }

  function FadetoBlack() {
    this.alpha = 0;
    this.draw = function () {
      ctx.fillStyle = `hsla(0,0%,0%,${this.alpha})`
      ctx.fillRect(0, 0, 320, 200)
      this.alpha += 0.05;
      if (this.alpha > 10) {
        this.lifetime = 0;
      }
    }

  }

  function copyScreen(alpha) {
    var shine = engine.vision.ShineMeter
    let lightness = new Int8Array(engine.zone.lightness);
    let sat = new Int8Array(engine.zone.saturation);
    let hue = new Int16Array(engine.zone.hue);
    for (var iZone = 0; iZone < 560; iZone++) {
      var iRow = Math.floor(iZone / 28);
      var iCol = iZone % 28;
      var iWidth = 320 / 28;
      var iHeight = 200 / 20;
      var iZx = iCol * iWidth;
      var iZy = iRow * iHeight;
      ctx.fillStyle =
        "hsla(" +
        hue[iZone] +
        "," +
        sat[iZone] +
        "%," +
        lightness[iZone] * keyScreenBrightness / 100 +
        "%, " +
        `${alpha}` +
        ")";

      ctx.fillRect(iZx, iZy, iWidth, iHeight);
    }

  }

  function GetTime() {
    return new Date().getTime()
  }

  function StateHandler() {
    var stack = [];
    var state = null;

    var updateState = function () {
      if (stack.length > 0) {
        state = stack[stack.length - 1];
      } else {
        state = null;
      }
    };

    this.Push = function (newState) {
      stack.push(newState);
      updateState();
    };

    this.Pop = function () {
      stack.pop();
      updateState();
    };

    this.Process = function () {
      if (state != null) {
        state.Process();
      }
    };
  }

  function Meter(size, callback) {
    this.size = size;
    this.value = 0;
    this.diff = 0;
    this.increased = false;
    this.decreased = false;
    var values = [];

    this.setValue = function (updatedValue) {
      values.push(updatedValue);
      if (values.length > this.size) {
        values.shift();
      }

      for (var i = 0; i < values.length - 1; i++) {
        if (values[i] !== values[i + 1]) return;
      }
      if (this.value !== values[0]) {
        this.diff = Math.abs(this.value - values[0]);
        this.increased = this.value < values[0];
        this.decreased = this.value > values[0];
        this.value = values[0];
        callback();
      }
    };
  }
  window.requestAnimationFrame(update);
</script>
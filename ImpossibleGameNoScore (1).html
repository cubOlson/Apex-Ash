<head>
  <Title>Mk11</Title>
  <meta description="Test" />
  <meta publisher="WhirlwindFX" />
  <meta property="PlayKillEffects" label="Play kill effect" type="boolean" default="0" />
<meta property="PlayAmplifieEffect" label="Play amplify effect" type="boolean" default="0" />

</head>

<body style="margin: 0; padding: 0;">
  <canvas id="exCanvas" width="320" height="200"></canvas>
</body>

<script>
  // Get the canvas element from the DOM
  var c = document.getElementById("exCanvas");
  var ctx = c.getContext("2d");

  var width = 320;
  var height = 200;
  var hue = 0;
  var speed = 2;

  var KillEffectDone = false;
  var cubeX = 1;
  var cubeY = 1;
  var effectTime;
  var killAnim = false;
  let effects = [];
  var amplifieAnim = false;

  var stateHdlr = new StateHandler();

  function StateHandler() {
          var stack = [];
          var state = null;

          // Set current state to the top item in the stack
          var updateState = function () {
              if (stack.length > 0) {
                  state = stack[stack.length - 1];
              } else {
                  state = null;
              }
          };

          // Allows dev to add effect to state handler
          this.Push = function (newState) {
              stack.push(newState);
              updateState();
          };
          // Allows dev to remove effect from handler
          this.Pop = function () {
              stack.pop();
              updateState();
          };
          // Call the Process function of the current state (effect)
          this.Process = function () {
              if (state != null) {
                  state.Process();
              }
          };
      }


  class blood {
      constructor(x, y, radius, color, fade) {
          this.x = x;
          this.y = y;
          this.radius = radius;
          this.color = color;
          this.fade = fade;
          this.speed = (Math.random()+0.1) *4
      }
      Draw() {
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI)
          ctx.strokeStyle = 'red'
          ctx.stroke();
           this.y += this.speed*Math.random();
           this.x += (Math.random()-0.5) *8;
      }

  }


  function copyScreen() {

      var shine = engine.vision.ShineMeter
      let lightness = new Int8Array(engine.zone.lightness);
      let sat = new Int8Array(engine.zone.saturation);
      let hue = new Int16Array(engine.zone.hue);
      for (var iZone = 0; iZone < 560; iZone++) {
          var iRow = Math.floor(iZone / 28);
          var iCol = iZone % 28;
          var iWidth = 320 / 28;
          var iHeight = 200 / 20;
          var iZx = iCol * iWidth;
          var iZy = iRow * iHeight;
          ctx.fillStyle =
              "hsla(" +
              hue[iZone] +
              "," +
              sat[iZone] +
              "%," +
              lightness[iZone] +
              "%, " +
              1 +
              ")";

          ctx.fillRect(iZx, iZy, iWidth, iHeight);
      }

  }

  function PlayKillEffect() {
       this.start = new Date().getTime();
       this.elapsed = 0;
       this.bloodDrip = [];  
       this.state = 0;
       
      this.Process = function () 
      { 
          if (this.bloodDrip.length < 20) {
           this.bloodDrip.push(new blood(Math.random() * c.width, 0, 5, 'red', 0.01))
          }

          this.elapsed = new Date().getTime() - this.start;
              
          if (this.elapsed >= 5000){
            stateHdlr.Pop();
            killAnim = false;
          } 

          this.Draw();
      };

 


      this.Draw = function() {
          if (this.state == 0) {
              ctx.beginPath();
              ctx.fillStyle = 'black'
              ctx.fillRect(0, 0, cubeX, cubeY);
              this.bloodDrip.length = 0;
              cubeX += 15;
              cubeY += 10;
              effectTime = Date.now();
              if (cubeX >= c.width+30) {
                this.state = 1;
              }
          }
          if(this.state == 1){
              this.bloodDrip.forEach(blood => {
                  blood.Draw();
              } 
          );
      }
  }
}

        function AmplifyEffect() {
            this.start = new Date().getTime();
            this.elapsed = 0;
            this.speed = 8;
            this.duration = 2000;
            this.lifetime = this.duration;
             this.Ymin = 0;
            this.draw = function () {
                this.Ymin += this.speed;
                ctx.beginPath();
                ctx.rect(0,  -200 + this.Ymin, c.width, 30);
                ctx.fillStyle = 'yellow';
                ctx.fill();
                ctx.beginPath();
                ctx.rect(0,  -125 + this.Ymin, c.width, 30);
                ctx.fillStyle = 'yellow';
                ctx.fill();
                ctx.beginPath();
                ctx.rect(0, -50 + this.Ymin, c.width, 30);
                ctx.fillStyle = 'yellow';
                ctx.fill();
                this.elapsed = new Date().getTime() - this.start;
                this.lifetime = this.duration - this.elapsed;
                if(this.lifetime <= 0){
                    amplifieAnim = false
                }
                
            }
           
        }

  function update() {
      if (PlayKillEffects == true && killAnim == false) {
          stateHdlr.Push(new PlayKillEffect());
          killAnim = true;
      } else if (!PlayKillEffects) {
        cubeX = 0;
        cubeY = 0;
        copyScreen();
      } 
      if (PlayAmplifieEffect && amplifieAnim == false){
          amplifieAnim = true;
        effects.push(new AmplifyEffect());
      }


      for (let i = 0; i < effects.length; i++) {
          effects[i].draw();
          // Remove effect if the lifetime has ended
          if (effects[i].lifetime <= 0) {
              effects.splice(i, 1);
              
          }
      }
      stateHdlr.Process();
      window.requestAnimationFrame(update);
  }

  window.requestAnimationFrame(update);
</script>
<head>
  <title>Hexagons</title>
  <meta description="Effect description goes here." />
  <meta publisher="Jack Pendleton" />
  <meta
    property="bgColor"
    label="Background Color"
    type="color"
    min="0"
    max="360"
    default="#000000"
  />
  <meta
    property="speed"
    label="Speed"
    type="number"
    min="0"
    max="100"
    default="50"
  />
  <meta
    property="color_mode"
    label="Color Mode"
    type="combobox"
    values="Static,Color Cycle,Rainbow"
    default="Color Cycle"
  />
  <meta
    property="color1"
    label="Static Color"
    type="color"
    min="0"
    max="360"
    default="#0055ff"
  />
</head>

<body style="margin: 0; padding: 0; background: #000">
  <canvas id="exCanvas" width="320" height="200"></canvas>
</body>

<script>
  var w = (exCanvas.width = window.innerWidth),
    h = (exCanvas.height = window.innerHeight),
    ctx = exCanvas.getContext("2d"),
    opts = {
      len: 20,
      count: 50,
      baseTime: 10,
      addedTime: 10,
      dieChance: 0.05,
      spawnChance: 1,
      sparkChance: 0.1,
      sparkDist: 10,
      sparkSize: 2,

      color: "hsl(hue,100%,light%)",
      baseLight: 50,
      addedLight: 10, // [50-10,50+10]
      shadowToTimePropMult: 6,
      baseLightInputMultiplier: 0.01,
      addedLightInputMultiplier: 0.02,

      cx: w / 2,
      cy: h / 2,
      repaintAlpha: 0.04,
      hueChange: 0.1,
    },
    speed = 50,
    color_mode = "Color Cycle",
    color1 = "#0055ff",
    tick = 0,
    lines = [],
    hueTick = 1,
    dieX = w / 2 / opts.len,
    dieY = h / 2 / opts.len,
    baseRad = (Math.PI * 2) / 6;

  ctx.fillStyle = "black";
  ctx.fillRect(0, 0, w, h);

  function loop() {
    window.requestAnimationFrame(loop);

    tick++;

    if (hueTick < 360) {
      hueTick++;
    } else {
      hueTick = 0;
    }

    if (speed > 0) {
      ctx.globalCompositeOperation = "source-over";
      ctx.shadowBlur = 0;
      ctx.fillStyle = bgColor + "11";
      ctx.fillRect(0, 0, w, h);
      ctx.globalCompositeOperation = "lighter";
    }

    if (lines.length < opts.count && Math.random() < opts.spawnChance)
      lines.push(new Line());

    lines.map(function (line) {
      if (speed > 0) {
        line.step();
      }
    });
  }
  function Line() {
    this.reset();
  }
  Line.prototype.reset = function () {
    this.x = 0;
    this.y = 0;
    this.addedX = 0;
    this.addedY = 0;

    this.rad = 0;

    this.lightInputMultiplier =
      opts.baseLightInputMultiplier +
      opts.addedLightInputMultiplier * Math.random();

    this.color = opts.color.replace("hue", tick * opts.hueChange);
    this.cumulativeTime = 0;

    this.beginPhase();
  };
  Line.prototype.beginPhase = function () {
    this.x += this.addedX;
    this.y += this.addedY;

    this.time = 0;
    this.targetTime = (opts.baseTime + opts.addedTime * Math.random()) | 0;

    this.rad += baseRad * (Math.random() < 0.5 ? 1 : -1);
    this.addedX = Math.cos(this.rad);
    this.addedY = Math.sin(this.rad);

    if (
      Math.random() < opts.dieChance ||
      this.x > dieX ||
      this.x < -dieX ||
      this.y > dieY ||
      this.y < -dieY
    )
      this.reset();
  };
  Line.prototype.step = function () {
    this.time += speed / 50;
    this.cumulativeTime++;

    if (this.time >= this.targetTime) this.beginPhase();

    var prop = this.time / this.targetTime,
      wave = Math.sin((prop * Math.PI) / 2),
      x = this.addedX * wave,
      y = this.addedY * wave;

    ctx.shadowBlur = prop * opts.shadowToTimePropMult;
    if (color_mode == "Color Cycle") {
      ctx.fillStyle = ctx.shadowColor = "hsl(" + hueTick + ",100%,50%)";
    } else if (color_mode == "Rainbow") {
      var xColor = ((opts.cx + (this.x + x) * opts.len) / 320) * 360 + hueTick;
      ctx.fillStyle = ctx.shadowColor = "hsl(" + xColor + ",100%,50%)";
    } else {
      ctx.fillStyle = ctx.shadowColor = color1;
    }

    ctx.fillRect(
      opts.cx + (this.x + x) * opts.len,
      opts.cy + (this.y + y) * opts.len,
      2,
      2
    );

    if (Math.random() < opts.sparkChance)
      ctx.fillRect(
        opts.cx +
          (this.x + x) * opts.len +
          Math.random() * opts.sparkDist * (Math.random() < 0.5 ? 1 : -1) -
          opts.sparkSize / 2,
        opts.cy +
          (this.y + y) * opts.len +
          Math.random() * opts.sparkDist * (Math.random() < 0.5 ? 1 : -1) -
          opts.sparkSize / 2,
        opts.sparkSize,
        opts.sparkSize
      );
  };
  loop();

  window.addEventListener("resize", function () {
    w = c.width = window.innerWidth;
    h = c.height = window.innerHeight;
    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, w, h);

    opts.cx = w / 2;
    opts.cy = h / 2;

    dieX = w / 2 / opts.len;
    dieY = h / 2 / opts.len;
  });

  // https://codepen.io/towc/pen/mJzOWJ
</script>

<head>
    <title>Basic Effects</title>
    <meta description="Basic Effects" />
    <meta publisher="SignalRgb" />

    <meta property="Bar" label="BarEffect" type="boolean" default="0" />
    <meta property="Ripple" label="RippleEffect" type="boolean" default="0" />
    <meta
    property="theY"
    label="Ambiance brightness"
    type="number"
    min="-200"
    max="200"
    default="100"
  />

</head>

<body style="margin: 0; padding: 0;">
    <canvas id="exCanvas" width="320" height="200"></canvas>
</body>

<script>
    var c = document.getElementById("exCanvas");
    var ctx = c.getContext("2d");

    var width = 320;
    var height = 200;
    var hue = 0;
    var effects = [];
    var animPlaying = false;

    function update() {
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, 320, 200);

        if (effects.length < 1){
            effects.push(new LuxR());
        }

        for (let i = 0; i < effects.length; i++) {
            effects[i].draw();
            if (effects[i].lifetime <= 0) {
                effects.splice(i, 1);
            }
        }

        window.requestAnimationFrame(update);
    }

    function LuxR(){
      this.lifetime = 20;
      this.start = GetTime();
      this.elapsed = 0;
      this.colors = ["blank", "red", "yellow", "cyan", "white"];
      
      this.draw = function () {
        this.elapsed = GetTime() - this.start;
        for(let i = 1; i < 5; i++){
          var width = 100 - 10 * i - (this.elapsed / 20 * i);
          if (width <= 0){
            width = 0;
          }
          ctx.fillStyle = this.colors[i];
          ctx.fillRect(0, 100 - width, 320, width * 2)
        }
        if(this.elapsed > 4000){
          this.lifetime = 0;
        }
      }
    };

    function DrawCircle(x,y,radius,color){
        ctx.beginPath();
        ctx.fillStyle = color;
        ctx.arc(x,y,radius, 0, 2* Math.PI)
        ctx.fill();
    };

    function DrawBackground(color) {
    ctx.fillStyle = color;
    ctx.fillRect(0, 0, c.width, c.height)
  };

  function DrawShield(x,y,scale, color){
      ctx.beginPath();
      ctx.moveTo(x,y);
      ctx.bezierCurveTo(x,y, x-scale/3, y+scale/6, x- scale/2, y+scale/6)
      ctx.lineTo(x - scale / 2, y + scale /1.7)
      ctx.bezierCurveTo(x - scale / 2, y + scale / 1.7, x-scale/2 , y + scale / 1.5, x , y + scale/1.2)
      ctx.bezierCurveTo(x, y + scale / 1.2, x + scale / 2, y + scale / 1.5, x+ scale/2, y + scale / 1.7)
      ctx.lineTo(x + scale / 2, y + scale /6)
      ctx.bezierCurveTo(x+scale/2, y + scale/6, x+scale/3, y+scale/6, x,y)
      ctx.fillStyle = color;
      ctx.fill();
    }

    function DrawTriangle(cord1X,cord1Y,cord2X,cord2Y,cord3X,cord3Y, color) {
      ctx.beginPath();
      ctx.fillStyle = color;
      ctx.moveTo(cord1X, cord1Y);
      ctx.lineTo(cord2X,cord2Y);
      ctx.lineTo(cord3X,cord3Y);
      ctx.lineTo(cord1X,cord1Y);
      ctx.fill();
    };

    function DrawSun(x,y,size,color){
      DrawCircle(x,y,size, color);
      DrawTriangle(x-size/5, y-size, x + size / 5, y - size, x, y-size*2.5)
      DrawTriangle(x - size / 5 - size/1.5, y - size/2, x + size / 5 - size / 1.5, y - size/1.5, x-size-size /1.5, y - size * 1.5)
      DrawTriangle(x-size,y-size/5, x-size,y+size/5,x-size*2.5,y)
      DrawTriangle(x + size / 5 + size / 1.5, y - size / 2, x - size / 5 + size / 1.5, y - size / 1.5, x + size + size / 1.5, y - size * 1.5)
      DrawTriangle(x + size, y + size / 5, x + size, y - size / 5, x + size * 2.5, y)
      DrawTriangle(x + size / 5 + size / 1.5, y + size / 2, x - size / 5 + size / 1.5, y + size / 1.5, x + size + size / 1.5, y + size * 1.5)
      DrawTriangle(x - size / 5 - size / 1.5, y + size / 2, x + size / 5 - size / 1.5, y + size / 1.5, x - size - size / 1.5, y + size * 1.5)
      DrawTriangle(x - size / 5, y + size, x + size / 5, y + size, x, y + size * 2.5)
    };

    class RandomCube {
    constructor(width, height, color, moveDir, speed, randomSpeed, startY, startX) {
      this.width = width
      this.height = height;
      this.col = color;
      this.moveDir = moveDir;
      this.y = startY;
      this.x = startX;
      this.randomSpeed = randomSpeed;
      this.speed;
      if (this.randomSpeed == null || this.randomSpeed == true) {
        this.speed = speed * (Math.random() * 2) + speed;
      } else {
        this.speed = speed;
      }
      if (this.moveDir == "left" || this.moveDir == "right") {
        if (this.y == null) {
          this.y = Math.random() * 200;
        }
        if (startX == null) {
          this.x = Math.random() * 320;
        }
        if (this.moveDir == "left") {
          this.speed = -this.speed;
          this.x = 320;
        } else if (this.moveDir == "right") {
          this.x = 0 - this.width;
        }
      } else {
        if (this.moveDir == "up") {
          this.speed = -this.speed;
          this.y = 200;
        } else if (this.moveDir == "down") {
          this.y = 0;
        }
      }
    }
    draw() {
      ctx.fillStyle = this.col;
      ctx.fillRect(this.x, this.y, this.width, this.height);
      if (this.moveDir == "left" || this.moveDir == "right") {
        this.x += this.speed;
      } else {
        this.y += this.speed;
      }
    }
  }

    function ParticleExplosion(x, y, color, speed, duration, particleAmount, particleSize, fadeSpeed, notrandomY) {
    this.start = GetTime();
    this.col = color;
    this.speed = speed;
    this.duration = duration;
    this.lifetime = 2000;
    this.amount = particleAmount;
    this.size = particleSize
    this.x = x;
    this.y = y;
    this.fadeSpeed = fadeSpeed;
    this.particles = [];
   
    while (this.particles.length < this.amount) {
       if (notrandomY) {
        this.yspeed = -this.speed/1.5;
      } else {
        this.yspeed = ((Math.random() - 0.5) * this.speed);
      }
      this.particles.push(new ExplosionParticle(this.x, this.y, this.size, this.col, this.fadeSpeed,
        {
          x: ((Math.random() - 0.5) * this.speed),
          y: this.yspeed
        }))
      this.draw = function () {
        this.lifetime = this.duration - (GetTime() - this.start)
        this.particles.forEach((Particle, index) => {
          Particle.draw()
        })
      }
    }
  };

  class ExplosionParticle {
      constructor(x, y, radius, color, fadeSpeed, velocity) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.radius = radius;
        this.velocity = velocity;
        this.alpha = 1 * fadeSpeed;
      }
      draw() {
        ctx.globalAlpha = this.alpha;
        ctx.beginPath()
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false)
        ctx.fillStyle = this.color
        ctx.fill()
        this.x += this.velocity.x
        this.y += this.velocity.y
        this.alpha -= 0.01
      }
    }

    function RippleEffect(x, y, speed, duration, rippleWidth, color, inOrOut, fillOrStroke, amountOfRipples, background) {
        this.col = color;
        this.speed = speed;
        this.dur = duration;
        this.width = rippleWidth;
        this.start = GetTime();
        this.lifetime;
        this.x = x;
        this.y = y;
        this.fill = fillOrStroke;
        this.radius = 0;
        this.amount = amountOfRipples;
        this.background = background;
        if (inOrOut == "in") {
          this.radius = 200 + (this.width * (this.amount * 2));
          this.speed = -this.speed
        }
        this.draw = function () {
          if(this.background){
            DrawBackground("black");
          }
          
          
          ctx.lineWidth = this.width;
          ctx.beginPath();
          for (let i = 0; i < this.amount; i++) {
            if (this.radius - i * (this.width * 2) > 0) {
              ctx.arc(this.x, this.y, this.radius - i * (this.width * 2), 0, 2 * Math.PI);
            }
          }
          if (this.fill == "fill") {
            ctx.fillStyle = this.col;
            ctx.fill();
          } else {
            ctx.strokeStyle = this.col;
            ctx.stroke();
          }
          this.radius += this.speed;
          this.lifetime = this.dur - (GetTime() - this.start);
          if (this.lifetime <= 0){
            utilityPlayed = false;
          }
        }
      }

    function GetTime() {
      return new Date().getTime()
    }

    window.requestAnimationFrame(update);
</script>
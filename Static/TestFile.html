<head>
  <title>Test Effects Real</title>
  <meta description="" />
  <meta publisher="SignalRGB" />

  <meta property="effectPush" label="Push effect" type="boolean" default="0" />
  <meta property="num" label="Ambience brightness" type="number" min="0" max="5" default="0" />
  
</head>

<body style="margin: 0; padding: 0; background: #000;">
  <canvas id="exCanvas" width="320" height="200"></canvas>
</body>

<script>
  var canvas, ctx;
  canvas = document.getElementById('exCanvas');
  ctx = canvas.getContext('2d');
  var width = 320;
  var height = 200;
  var effects = [];

  function update() {
    DrawRect(0, 0, 320, 200, "salmon")

    if(effects.length < 1){
      effects.push(new genericMenu())
    }
    effects.forEach((ele, i)=>{
        ele.draw();
        ele.lifetime <= 0 ? effects.splice(i, 1) : null;
    })

    window.requestAnimationFrame(update);
  };

  function genericMenu(){
    this.lifetime = 10;
    this.done = false;
    this.redo = false;
    this.effects = [];
    this.draw = function(){
      if(this.redo){
        this.effects = [];
        this.redo = false;
        this.done = false;
      }
      var count = 0;
      if(this.effects.length < 8){
        this.effects.push(new menuRow(this.effects.length * 40))
      }
      this.effects.forEach((ele, i)=>{
        ele.draw(this.done);
        ele.done ? count++ : null;
      })
      if(count == 8 && !this.done){
        this.done = true
        setTimeout(()=>{
          this.redo = true;
        }, 500)
      }
    }
  }

  function menuRow(x){
    this.x = x;
    this.start = Date.now();
    this.speed = Math.random() * 800 + 800;
    this.effects = [];
    this.done = false;
    this.draw = function(donezo){
      var elapsed = Date.now() - this.start;
      var count = 0;
      if(elapsed > this.speed && this.effects.length < 5){
        this.effects.push(new menuSquare(this.x, 200 - (this.effects.length * 40 + 40), 5, 40, 40))
        this.start = Date.now()
      }
      this.effects.forEach((ele, i)=>{
        ele.draw(donezo);
        if(ele.done){
          count++;
          if(this.effects[i - 1]){
            this.effects[i - 1].grass = false;
          }
        }
      })
      count == 5 ? this.done = true : null;
    }
  }

  function menuSquare(x, y2, speed, width, height){
    this.x = x;
    this.y = 0;
    this.alpha = 1;
    this.width = width;
    this.height = height;
    this.y2 = y2;
    this.speed = speed;
    this.grass = true;
    this.done = false;
    this.draw = function(donezo){
      ctx.globalAlpha = this.alpha;
      DrawRect(this.x, this.y, this.width, this.height, "rgb(130, 60, 35)")
      this.grass ? DrawRect(this.x, this.y, this.width, this.height * .75, "green") : null;
      ctx.globalAlpha = 1;
      this.y <= this.y2 - this.speed ? this.y+=this.speed : this.done = true;
      donezo ? this.alpha >= .05 ? this.alpha-=.05 : this.alpha = 0 : null;
    }
  }

  function drawLightning(array, color, width){
      ctx.beginPath()
      ctx.moveTo(...array[0])
      array.forEach((ele, i)=>{
        if(i){
          ctx.lineTo(...array[i])
        }
      });
      ctx.strokeStyle = color;
      ctx.lineJoin = "round";
      ctx.lineWidth = width + Math.random() * width;
      ctx.stroke()
  }

  function DrawGear(x, y, radius, stroke, teeth, color){
    DrawStroke(x, y, radius, color, stroke)
    for(let i = 0; i < teeth; i++){
      var ix = Math.cos(Math.PI * 2 / teeth * i) * radius + x;
      var iy = Math.sin(Math.PI * 2 / teeth * i) * radius + y;
      var rotate = Math.atan2(y - iy, x - ix) + Math.PI / 2;
      ctx.save()
      ctx.translate(ix, iy)
      ctx.rotate(rotate)
      ctx.translate(-ix, -iy)
      DrawRect(ix, iy, Math.PI * radius * 2 / teeth * .75, radius / 3 + stroke / 2, "orange")
      ctx.restore()
    }
  }

  function DrawPath(x, y, path, color) {
    ctx.fillStyle = color;
    ctx.save();
    ctx.translate(x, y);
    let ex = new Path2D(path);
    ctx.fill(ex);
    ctx.restore();
  };

  function DrawTriangle(cord1X, cord1Y, cord2X, cord2Y, cord3X, cord3Y, color) {
    ctx.beginPath();
    ctx.fillStyle = color;
    ctx.moveTo(cord1X, cord1Y);
    ctx.lineTo(cord2X, cord2Y);
    ctx.lineTo(cord3X, cord3Y);
    ctx.lineTo(cord1X, cord1Y);
    ctx.fill();
  };

  function DrawCircle(x, y, radius, color) {
    ctx.beginPath();
    ctx.fillStyle = color;
    ctx.arc(x, y, radius, 0, 2 * Math.PI)
    ctx.fill();
  };

  function DrawStroke(x, y, radius, color, stroke) {
    ctx.beginPath();
    ctx.strokeStyle = color;
    ctx.lineWidth = stroke;
    ctx.arc(x, y, radius, 0, 2 * Math.PI)
    ctx.stroke();
  };

  function DrawRect(x, y, width, height, color) {
    ctx.beginPath();
    ctx.fillStyle = color;
    ctx.fillRect(x, y, width, height);
  };

  function DrawHex(x, y, color, size) {
    ctx.beginPath();
    for (var i = 0; i < 7; i++) {
      ctx.lineTo(x + size * Math.cos(2 * Math.PI / 6 * i), y + size * 0.9 * Math.sin(2 * Math.PI / 6 * i));
    }
    ctx.fillStyle = color;
    ctx.fill();
    ctx.strokeStyle = "black"
    ctx.stroke()
  };

  function hexToRgb(hex) {
    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : null;
  }

  function hexToHSL(H) {
  // Convert hex to RGB first
  let r = 0, g = 0, b = 0;
  if (H.length == 4) {
    r = "0x" + H[1] + H[1];
    g = "0x" + H[2] + H[2];
    b = "0x" + H[3] + H[3];
  } else if (H.length == 7) {
    r = "0x" + H[1] + H[2];
    g = "0x" + H[3] + H[4];
    b = "0x" + H[5] + H[6];
  }
  // Then to HSL
  r /= 255;
  g /= 255;
  b /= 255;
  let cmin = Math.min(r,g,b),
      cmax = Math.max(r,g,b),
      delta = cmax - cmin,
      h = 0,
      s = 0,
      l = 0;

  if (delta == 0)
    h = 0;
  else if (cmax == r)
    h = ((g - b) / delta) % 6;
  else if (cmax == g)
    h = (b - r) / delta + 2;
  else
    h = (r - g) / delta + 4;

  h = Math.round(h * 60);

  if (h < 0)
    h += 360;

  l = (cmax + cmin) / 2;
  s = delta == 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));
  s = +(s * 100).toFixed(1);
  l = +(l * 100).toFixed(1);

  return [h, s, l];
}

  function copyScreen(alpha) {
    var shine = engine.vision.ShineMeter
    let lightness = new Int8Array(engine.zone.lightness);
    let sat = new Int8Array(engine.zone.saturation);
    let hue = new Int16Array(engine.zone.hue);
    for (var iZone = 0; iZone < 560; iZone++) {
      var iRow = Math.floor(iZone / 28);
      var iCol = iZone % 28;
      var iWidth = 320 / 28;
      var iHeight = 200 / 20;
      var iZx = iCol * iWidth;
      var iZy = iRow * iHeight;
      ctx.fillStyle =
        "hsla(" +
        hue[iZone] +
        "," +
        sat[iZone] +
        "%," +
        lightness[iZone] * keyScreenBrightness / 100 +
        "%, " +
        `${alpha}` +
        ")";

      ctx.fillRect(iZx, iZy, iWidth, iHeight);
    }

  }

  function GetTime() {
    return new Date().getTime()
  }

  function StateHandler() {
    var stack = [];
    var state = null;

    var updateState = function () {
      if (stack.length > 0) {
        state = stack[stack.length - 1];
      } else {
        state = null;
      }
    };

    this.Push = function (newState) {
      stack.push(newState);
      updateState();
    };

    this.Pop = function () {
      stack.pop();
      updateState();
    };

    this.Process = function () {
      if (state != null) {
        state.Process();
      }
    };
  }

  function Meter(size, callback) {
    this.size = size;
    this.value = 0;
    this.diff = 0;
    this.increased = false;
    this.decreased = false;
    var values = [];

    this.setValue = function (updatedValue) {
      values.push(updatedValue);
      if (values.length > this.size) {
        values.shift();
      }

      for (var i = 0; i < values.length - 1; i++) {
        if (values[i] !== values[i + 1]) return;
      }
      if (this.value !== values[0]) {
        this.diff = Math.abs(this.value - values[0]);
        this.increased = this.value < values[0];
        this.decreased = this.value > values[0];
        this.value = values[0];
        callback();
      }
    }
  }

  function onCanvasTapped(x, y) {
    effects.push(new lowAmmoEffect())
  }

  window.requestAnimationFrame(update);
</script>
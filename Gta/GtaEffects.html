<html>

<head>
    <title>Gta effects</title>
    <meta description="Gta effects">
    <meta publisher="SignalRgb">
    <meta property="Play" label="Enable health effects" type="boolean" default="1">




<body style="margin: 0; padding: 0;">
    <canvas id="exCanvas" width="320" height="200"></canvas>
    <script>
        // Get the canvas element from the DOM
        var c = document.getElementById("exCanvas");
        var ctx = c.getContext("2d");

        var width = 320;
        var height = 200;
        var hue = 0;
        var effects = [];


        //Meters





        var stateHdlr = new StateHandler();

        function StateHandler() {
            var stack = [];
            var state = null;

            // Set current state to the top item in the stack
            var updateState = function () {
                if (stack.length > 0) {
                    state = stack[stack.length - 1];
                } else {
                    state = null;
                }
            }
            // Allows dev to add effect to state handler
            this.Push = function (newState) {
                stack.push(newState);
                updateState();
            };
            // Allows dev to remove effect from handler
            this.Pop = function () {
                stack.pop();
                updateState();
            };
            // Call the Process function of the current state (effect)
            this.Process = function () {
                if (state != null) {
                    state.Process();
                }
            };
        }




        function Meter(size, callback) {
            this.size = size;
            this.value = 0;
            this.diff = 0;
            this.increased = false;
            this.decreased = false;
            var values = [];

            this.setValue = function (updatedValue) {
                values.push(updatedValue);
                if (values.length > this.size) {
                    values.shift();
                }

                for (var i = 0; i < values.length - 1; i++) {
                    if (values[i] !== values[i + 1]) return;
                }
                if (this.value !== values[0]) {
                    this.diff = Math.abs(this.value - values[0]);
                    this.increased = this.value < values[0];
                    this.decreased = this.value > values[0];
                    this.value = values[0];
                    callback();
                }
            };
        }




        function copyScreen(alpha) {

            var shine = engine.vision.ShineMeter
            let lightness = new Int8Array(engine.zone.lightness);
            let sat = new Int8Array(engine.zone.saturation);
            let hue = new Int16Array(engine.zone.hue);
            for (var iZone = 0; iZone < 560; iZone++) {
                var iRow = Math.floor(iZone / 28);
                var iCol = iZone % 28;
                var iWidth = 320 / 28;
                var iHeight = 200 / 20;
                var iZx = iCol * iWidth;
                var iZy = iRow * iHeight;
                ctx.fillStyle =
                    "hsla(" +
                    hue[iZone] +
                    "," +
                    sat[iZone] +
                    "%," +
                    lightness[iZone] +
                    "%, " +
                    `${alpha}` +
                    ")";

                ctx.fillRect(iZx, iZy, iWidth, iHeight);
            }

        }



        //Effects
        var CurrentLowHp = false;
        function LowHpEffect() {
            this.start = GetTime();
            this.explosionEffect = new ParticleExplosion(160, 100, "red", 14, 1500, 50, 10, 2, false, false, true);

            this.draw = function () {
                this.elapsed = GetTime();
                this.explosionEffect.draw();
                DrawHeart(160, 90, (Math.sin(this.elapsed / 300) + 1) * 50, (Math.sin(this.elapsed / 300) + 1) * 25)
                if ((Math.sin(this.elapsed / 300)) >= 0.99) {
                    this.explosionEffect = new ParticleExplosion(160, 100, "red", 14, 1500, 50, 10, 2, false, false, true);
                }
                if (CurrentLowHp == false) {
                    this.lifetime = 0
                }
            }
        }

        function MoneyEffect(color) {
            this.start = GetTime();
            this.money = [];
            this.color = color;

            for (let i = 0; i < 35; i++) {
                this.money.push(new fallingMoney(Math.random() * 320, Math.random() + 5, this.color))
            }
            this.draw = function () {
                this.money.forEach(money => {
                    money.draw();
                });
                if (GetTime() - this.start > 8000) {
                    this.lifetime = 0;
                }
            }
        }

        function WastedEffect() {
            Freezbackground = true;
            this.start = GetTime();
            this.bloodDrip = [];
            this.bloodHeight = 0;
            this.Process = function () {

                if (Math.random() > 0.8) {
                    this.bloodDrip.push(new blood(Math.random() * 320, 0, "red", 0.01))
                }
                this.elapsed = GetTime() - this.start;
                if (this.bloodHeight < -200) {
                    stateHdlr.Pop();
                    Freezbackground = false;
                }
                this.Draw();
            }

            this.Draw = function () {
                copyScreen(0.1)
                this.bloodDrip.forEach((blood, index) => {
                    blood.Draw();
                    if (blood.y > 200 - this.bloodHeight) {
                        this.bloodHeight -= blood.size;
                        this.bloodDrip.splice(index, 1)
                    }
                }
                );
                ctx.fillStyle = "red";
                ctx.fillRect(0, 200, 320, this.bloodHeight)
            }
        }




        //We could use the arrow effect as XP effect( something like this:      effects.push(new ArrowEffect("up", "blue", 3, 5, 1500));)

        function ArrowEffect(direction, color, amount, speed, duration) {
            this.start = GetTime();
            this.speed = speed;
            this.duration = duration;
            this.lifetime = this.duration;
            this.direction = direction;
            this.color = color;
            this.amount = amount;
            this.draw = function () {
                if (this.direction == 'up') {
                    this.speed = -this.speed;
                    ctx.fillStyle = this.color;
                    for (let i = 0; i < this.amount; i++) {
                        ctx.beginPath();
                        ctx.moveTo(160, this.lifetime / 1.5 - 150 - (200 * i));
                        ctx.lineTo(320, this.lifetime / 1.5 - (200 * i));
                        ctx.lineTo(320, this.lifetime / 1.5 - (200 * i) + 100);
                        ctx.lineTo(160, this.lifetime / 1.5 - (200 * i) - 100);
                        ctx.lineTo(0, this.lifetime / 1.5 - (200 * i) + 100);
                        ctx.lineTo(0, this.lifetime / 1.5 - (200 * i));
                        ctx.lineTo(160, this.lifetime / 1.5 - (200 * i) - 150);
                        ctx.fill();
                    }
                } else {
                    ctx.fillStyle = this.color;
                    for (let i = 0; i < this.amount; i++) {
                        ctx.beginPath();
                        ctx.moveTo(160, 300 - this.lifetime / 1.5 + (200 * i));
                        ctx.lineTo(320, 240 - this.lifetime / 1.5 + (200 * i));
                        ctx.lineTo(320, 180 - this.lifetime / 1.5 + (200 * i));
                        ctx.lineTo(160, 240 - this.lifetime / 1.5 + (200 * i));
                        ctx.lineTo(0, 180 - this.lifetime / 1.5 + (200 * i));
                        ctx.lineTo(0, 240 - this.lifetime / 1.5 + (200 * i));
                        ctx.lineTo(160, 300 - this.lifetime / 1.5 + (200 * i));
                        ctx.fill();
                    }
                }
                this.Ymin += this.speed;
                this.elapsed = new Date().getTime() - this.start;
                this.lifetime = this.duration - this.elapsed;
                if (this.lifetime <= 0) {
                    speedAnim = false
                }
            }
        }

        function ParticleExplosion(x, y, color, speed, duration, particleAmount, particleSize, fadeSpeed, notrandomY, useHearts, hasPhysics) {
            this.start = GetTime();
            this.col = color;
            this.speed = speed;
            this.duration = duration;
            this.lifetime = 2000;
            this.amount = particleAmount;
            this.size = particleSize
            this.x = x;
            this.y = y;
            this.fadeSpeed = fadeSpeed;
            this.particles = [];
            this.useHearts = useHearts;
            this.hasPhysics = hasPhysics;

            while (this.particles.length < this.amount) {
                if (notrandomY) {
                    this.yspeed = -this.speed / 1.5;
                } else {
                    this.yspeed = ((Math.random() - 0.5) * this.speed);
                }
                if (this.useHearts == null || this.useHearts == false) {
                    this.particles.push(new ExplosionParticle(this.x, this.y, this.size, this.col, this.fadeSpeed,
                        {
                            x: ((Math.random() - 0.5) * this.speed),
                            y: this.yspeed
                        }, this.hasPhysics))
                } else {
                    this.particles.push(new HeartParticle(this.x, this.y, this.size, this.col, this.fadeSpeed,
                        {
                            x: ((Math.random() - 0.5) * this.speed),
                            y: this.yspeed
                        }))
                }

                this.draw = function () {
                    this.lifetime = this.duration - (GetTime() - this.start)
                    this.particles.forEach((Particle, index) => {
                        Particle.draw()
                    })
                }
            }
        };

        function PoliceEffect() {
            this.start = new Date().getTime();
            this.duration = 1500;
            this.timing = 100;
            this.speed = 8;
            this.Process = function () {
                this.elapsed = new Date().getTime() - this.start;
                if (this.elapsed > this.duration) {
                    stateHdlr.Pop();
                }
                this.Draw();
            };
            this.Draw = function () {
                ctx.fillStyle = "black";
                ctx.fillRect(0, 0, 320, 200);
                if (this.timing > 30 && this.timing < 110) {
                    ctx.fillStyle = "#ff0000";
                    ctx.fillRect(0, 0, 106, 200);

                    ctx.fillStyle = "#0000ff";
                    ctx.fillRect(214, 0, 106, 200);
                } else {
                    ctx.fillStyle = "#ffffff";
                    ctx.fillRect(106, 0, 108, 200);
                }
                if (this.timing > 0) {
                    this.timing -= this.speed;
                } else {
                    this.timing = 110;
                }
            };
        }

        //Helper effects


        function DrawHeart(x, y, xSize, Ysize, color) {
            ctx.save();
            ctx.beginPath();
            ctx.fillStyle = color;
            ctx.moveTo(x, y);
            // top left curve
            ctx.bezierCurveTo(
                x,
                y,
                x - xSize / 2,
                y - Ysize,
                x - xSize / 2,
                y + Ysize / 4
            );
            ctx.bezierCurveTo(
                x - xSize / 2,
                y + Ysize / 4,
                x - xSize / 2,
                y + Ysize / 4,
                x,
                y + Ysize
            );
            ctx.bezierCurveTo(
                x + xSize / 2,
                y + Ysize / 4,
                x + xSize / 2,
                y + Ysize / 4,
                x + xSize / 2,
                y + Ysize / 4
            );
            ctx.bezierCurveTo(
                x + xSize / 2,
                y + Ysize / 4,
                x + xSize / 2,
                y - Ysize,
                x,
                y
            );

            ctx.fill()
            ctx.restore()
        };

        function GetTime() {
            return new Date().getTime();
        }

        //classes
        class ExplosionParticle {
            constructor(x, y, radius, color, fadeSpeed, velocity, hasPhysics) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.radius = radius;
                this.velocity = velocity;
                this.alpha = 1 * fadeSpeed;
                this.hasPhysics = hasPhysics;
            }
            draw() {
                ctx.globalAlpha = this.alpha;
                ctx.beginPath()
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false)
                ctx.fillStyle = this.color
                ctx.fill()
                this.x += this.velocity.x
                this.y += this.velocity.y
                if (this.hasPhysics != null || this.hasPhysics != false) {
                    this.velocity.y += 0.3;
                }
                this.alpha -= 0.01
                ctx.globalAlpha = 1;
            }
        }

        class fallingMoney {
            constructor(x, speed, color) {
                this.speed = speed / 5;
                this.x = x;
                this.y = 0 - (Math.random() * 250);
                this.startVal = (Math.random() * 50);
                this.start = GetTime();
                this.color = color;
            }
            draw() {
                this.elapsed = GetTime() - this.start;
                this.moveVal = (this.elapsed / 1000);
                ctx.fillStyle = this.color;
                ctx.save();
                ctx.translate(this.x + Math.sin(this.startVal + this.moveVal) * 100, this.y);
                ctx.rotate(-Math.sin(this.moveVal + this.startVal) / 5);
                ctx.fillRect(this.x, this.y, 100, 35);
                ctx.restore();
                this.y += this.speed;
            }
        }

        class blood {
            constructor(x, y, color, fade) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.fade = fade;
                this.speed = (Math.random() + 0.1) * 6
                this.size = (Math.random() * 5) + 5;
            }
            Draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, 2 * Math.PI)
                ctx.fillStyle = this.color;
                ctx.fill();
                this.y += this.speed * Math.random();
                this.x += (Math.random() - 0.5) * 8;
            }

        }







        Freezbackground = false;

        function update() {
            if (!Freezbackground) {
                copyScreen(1);
            }

            for (let i = 0; i < effects.length; i++) {
                effects[i].draw();
                if (effects[i].lifetime <= 0) {
                    effects.splice(i, 1);
                }
            }


            stateHdlr.Process();
            window.requestAnimationFrame(update);
        }
        effects.push(new MoneyEffect("green"))
        window.requestAnimationFrame(update);
    </script>
</body>

</html>
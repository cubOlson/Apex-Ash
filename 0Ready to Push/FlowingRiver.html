<head>
  <title>Flowing River</title>
  <meta description="A gently-flowing river of RGB." />
  <meta publisher="SignalRGB" />
  <meta property="fgHue1" label="Lower hue" type="color" min="0" max="360" default="#00ffff" />
  <meta property="fgHue2" label="Upper hue" type="color" min="0" max="360" default="#1500ff" />
  <meta property="rainbowMode" label="Rainbow" type="boolean" min="0" max="1" default="0" />
  <meta property="speedRaw" label="Speed" type="number" min="0" max="100" default="50" />
  <meta property="vertical" label="Vertical" type="boolean" min="0" max="1" default="0" />
  <meta property="reverse" label="Reverse" type="boolean" min="0" max="1" default="0" />
</head>

<body style="margin: 0; padding: 0">
  <canvas id="exCanvas" width="320" height="200"></canvas>
</body>

<script>
  var c = document.getElementById("exCanvas");
  var ctx = c.getContext("2d");
  var width = 320;
  var height = 200;
  var effects = [];
  var effects2 = [];

  var fgHue1 = 180;
  var fgHue2 = 245;

  var reverse = false;

  var rainbowMode = false;
  var rainbowHue = 0;

  var reverseMeter = new Meter(1, reset);

  function reset() {
    effects.length = 0;
    effects2.length = 0;

    if (reverseMeter.value == true) {
      for (let i = -6; i < 33; i++) {
        effects.push(new RInitWave(i * 10));
      }
    } else {
      for (let i = -6; i < 33; i++) {
        effects.push(new InitWave(i * 10));
      }
    }
  }

  for (let i = -6; i < 33; i++) {
    effects.push(new InitWave(i * 10));
  }

  function update() {

    if (rainbowHue < 360) {
      rainbowHue++;
    } else {
      rainbowHue = 0;
    }

    reverseMeter.setValue(reverse);

    if (effects.length < 33) {
      if (reverseMeter.value == false) {
        effects.push(new Wave());
      } else {
        effects.push(new RWave());
      }
    }

    if(vertical){
      ctx.save();
      ctx.translate(160, 200);
      ctx.rotate(Math.PI / 2);
      ctx.translate(-200, -165);
      ctx.scale(1, 2)
    }

    for (i = 0; i < effects.length; i++) {
      effects[i].Draw();
      if (effects[i].IsFinished()) {
        effects.splice(i, 1);
      }
    }

    if(vertical){
      ctx.restore();
    }
    
    window.requestAnimationFrame(update);
  }

  window.requestAnimationFrame(update);

  function InitWave(x) {
    this.x = x - 10;

    this.h = getRandomInt(180, 220);
    this.h2 = getRandomInt(180, 220);

    this.y1 = getRandomInt(-20, 20);
    this.y2 = getRandomInt(-20, 20);
    this.y3 = getRandomInt(-20, 20);
    this.y4 = getRandomInt(-20, 20);

    this.Draw = function () {
      ctx.strokeStyle = "hsl(" + this.h + ",100%,50%)";
      ctx.lineWidth = 10;
      ctx.beginPath();
      ctx.moveTo(this.x, 0);
      ctx.lineTo(this.x, 200);
      ctx.stroke();

      ctx.strokeStyle = "hsla(" + this.h2 + ",100%,50%,0.5)";
      ctx.beginPath();
      ctx.moveTo(this.x, 0);
      ctx.lineTo(this.x + this.y1, 50);
      ctx.lineTo(this.x + this.y2, 100);
      ctx.lineTo(this.x + this.y3, 150);
      ctx.lineTo(this.x + this.y4, 200);
      ctx.stroke();

      this.x += speedRaw / 50;
    };

    this.IsFinished = function () {
      if (this.x > 320) {
        return true;
      } else {
        return false;
      }
    };
  }

  function Wave() {
    this.x = -10;
    this.rh = rainbowHue;
    this.h = getRandomColor(fgHue1, fgHue2);

    this.rs2 = getRandomInt(70, 100);
    this.h2 = getRandomColor(fgHue1, fgHue2);
    this.y1 = getRandomInt(-20, 20);
    this.y2 = getRandomInt(-20, 20);
    this.y3 = getRandomInt(-20, 20);
    this.y4 = getRandomInt(-20, 20);

    this.Draw = function () {
      if (rainbowMode) {
        ctx.strokeStyle = "hsl(" + this.rh + ",100%,50%)";
      } else {
        ctx.strokeStyle = "hsl(" + this.h[0] + "," + this.h[1] + "%," + this.h[2] + "%)";
      }
      ctx.lineWidth = 10;
      ctx.beginPath();
      ctx.moveTo(this.x, 0);
      ctx.lineTo(this.x, 200);
      ctx.stroke();

      if (rainbowMode) {
        ctx.strokeStyle = "hsl(" + this.rh + "," + this.rs2 + "%,50%)";
      } else {
        ctx.strokeStyle = "hsl(" + this.h2[0] + "," + this.h2[1] + "%," + this.h2[2] + "%)";
      }
      ctx.beginPath();
      ctx.moveTo(this.x, 0);
      ctx.lineTo(this.x + this.y1, 50);
      ctx.lineTo(this.x + this.y2, 100);
      ctx.lineTo(this.x + this.y3, 150);
      ctx.lineTo(this.x + this.y4, 200);
      ctx.stroke();

      this.x += speedRaw / 50;
    };

    this.IsFinished = function () {
      if (this.x > 320) {
        return true;
      } else {
        return false;
      }
    };
  }

  function RInitWave(x) {
    this.x = x + 10;

    this.h = getRandomInt(180, 220);
    this.h2 = getRandomInt(180, 220);
    this.y1 = getRandomInt(-20, 20);
    this.y2 = getRandomInt(-20, 20);
    this.y3 = getRandomInt(-20, 20);
    this.y4 = getRandomInt(-20, 20);

    this.Draw = function () {
      ctx.strokeStyle = "hsl(" + this.h + ",100%,50%)";
      ctx.lineWidth = 10;
      ctx.beginPath();
      ctx.moveTo(this.x, 0);
      ctx.lineTo(this.x, 200);
      ctx.stroke();

      ctx.strokeStyle = "hsla(" + this.h2 + ",100%,50%,0.5)";
      ctx.beginPath();
      ctx.moveTo(this.x, 0);
      ctx.lineTo(this.x + this.y1, 50);
      ctx.lineTo(this.x + this.y2, 100);
      ctx.lineTo(this.x + this.y3, 150);
      ctx.lineTo(this.x + this.y4, 200);
      ctx.stroke();

      this.x -= speedRaw / 50;
    };

    this.IsFinished = function () {
      if (this.x < 0) {
        return true;
      } else {
        return false;
      }
    };
  }

  function RWave() {
    this.x = 330;
    this.rh = rainbowHue;
    this.h = getRandomColor(fgHue1, fgHue2);

    this.rs2 = getRandomInt(70, 100);
    this.h2 = getRandomColor(fgHue1, fgHue2);
    this.y1 = getRandomInt(-20, 20);
    this.y2 = getRandomInt(-20, 20);
    this.y3 = getRandomInt(-20, 20);
    this.y4 = getRandomInt(-20, 20);

    this.Draw = function () {
      if (rainbowMode) {
        ctx.strokeStyle = "hsl(" + this.rh + ",100%,50%)";
      } else {
        ctx.strokeStyle = "hsl(" + this.h[0] + "," + this.h[1] + "%," + this.h[2] + "%)";
      }
      ctx.lineWidth = 10;
      ctx.beginPath();
      ctx.moveTo(this.x, 0);
      ctx.lineTo(this.x, 200);
      ctx.stroke();
      this.x -= speedRaw / 50;

      if (rainbowMode) {
        ctx.strokeStyle = "hsl(" + this.rh + "," + this.rs2 + "%,50%)";
      } else {
        ctx.strokeStyle = "hsl(" + this.h2[0] + "," + this.h2[1] + "%," + this.h2[2] + "%)";
      }
      ctx.lineWidth = 10;
      ctx.beginPath();
      ctx.moveTo(this.x, 0);
      ctx.lineTo(this.x + this.y1, 50);
      ctx.lineTo(this.x + this.y2, 100);
      ctx.lineTo(this.x + this.y3, 150);
      ctx.lineTo(this.x + this.y4, 200);
      ctx.stroke();

    };

    this.IsFinished = function () {
      if (this.x < 0) {
        return true;
      } else {
        return false;
      }
    };
  }

  function getRandomInt(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  function getRandomColor(min, max) {
    var minHsl = hexToHSL(min);
    var maxHsl = hexToHSL(max);

    minH = Math.ceil(minHsl[0]);
    maxH = Math.floor(maxHsl[0]);
    var outputHue = Math.floor(Math.random() * (maxH - minH + 1)) + minH;

    var outputSat = minHsl[1] + maxHsl[1] / 2 / 255 * 100;

    var outputLit = minHsl[2] + maxHsl[2] / 2 / 255 * 100;

    return [outputHue, outputSat, outputLit];
  }

  function hexToHSL(H) {
    // Convert hex to RGB first
    let r = 0, g = 0, b = 0;
    if (H.length == 4) {
      r = "0x" + H[1] + H[1];
      g = "0x" + H[2] + H[2];
      b = "0x" + H[3] + H[3];
    } else if (H.length == 7) {
      r = "0x" + H[1] + H[2];
      g = "0x" + H[3] + H[4];
      b = "0x" + H[5] + H[6];
    }
    // Then to HSL
    r /= 255;
    g /= 255;
    b /= 255;
    let cmin = Math.min(r, g, b),
      cmax = Math.max(r, g, b),
      delta = cmax - cmin,
      h = 0,
      s = 0,
      l = 0;

    if (delta == 0)
      h = 0;
    else if (cmax == r)
      h = ((g - b) / delta) % 6;
    else if (cmax == g)
      h = (b - r) / delta + 2;
    else
      h = (r - g) / delta + 4;

    h = Math.round(h * 60);

    if (h < 0)
      h += 360;

    l = (cmax + cmin) / 2;
    s = delta == 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));
    s = +(s * 100).toFixed(1);
    l = +(l * 100).toFixed(1);

    return [h, s, l];
  }

  function Meter(count, callback) {
    this.size = count;
    this.value = 0;
    this.diff = 0;
    this.increased = false;
    this.decreased = false;
    var values = [];

    this.setValue = function (updatedValue) {
      // Add and shift.
      values.push(updatedValue);
      if (values.length > this.size) {
        values.shift();
      }

      // Exit early if we've got a long-term match.
      for (var i = 0; i < values.length - 1; i++) {
        if (values[i] !== values[i + 1]) return;
      }

      // We got here, so weve got a matching value collection.
      if (this.value !== values[0]) {
        //var fromZero = this.value === 0;
        //var toZero = values[0] === 0;
        this.diff = Math.abs(this.value - values[0]);
        this.increased = this.value < values[0];
        this.decreased = this.value > values[0];
        this.value = values[0];
        callback();
      }
    };
  }
</script>
<head>
  <title>Minecraft Java Old</title>
  <meta description="Game intergration for Minecraft Java edition. 
  You must use auto GUI scaling and select your resolution.
  0 = 1080p, 1 = 1440p, 2 = 2160p" />
  <meta publisher="WhirlwindFX" />
  <meta property="enableHealth" label="Health effect" type="boolean" default="1" />
  <meta property="effectHex1" label="Decrease Health effect Color" type="color" min="0" max="360" default="#ff0000" />
  <meta property="effectHex2" label="Increase Health effect Color" type="color" min="0" max="360" default="#ff57ae" />
  <meta property="enableHunger" label="Hunger effect" type="boolean" default="1" />
  <meta property="effectHex3" label="Hunger state effect Color" type="color" min="0" max="360" default="#572b00" />
  <meta property="effectHex4" label="Is Fed effect Color" type="color" min="0" max="360" default="#fc8c03" />
  <meta property="enableXP" label="XP effect" type="boolean" default="1" />
  <meta property="enableBoss" label="Boss bar effect" type="boolean" default="1" />
  <meta property="enableFire" label="On Fire effect" type="boolean" default="1" />

  <meta meter="Fire" tags="minecraft, vlc" x=".03" y=".95" width=".005" height=".005" h="0-30" s="60-100" l="30-100"
    type="area" />

  <meta meter="health" tags="minecraft, vlc" x=".3150" y=".87" width=".1575" height=".001" h="0-20" s="60-100"
    l="80-100" type="area">
  <resolution size="2560x1440" x=".291" y=".8529" width=".1625" height=".001" />
  <resolution size="3840x2160" x=".291" y=".8472" width=".1625" height=".001" />
  </meta>

  <meta meter="food" tags="photos, vlc" x=".5295" y=".865" width=".165" height=".002" h="0-50" s="40-80" l="65-100"
    type="area">
  <resolution size="2560x1440" x=".5281" y=".8472" width=".15" height=".004" />
  <resolution size="3840x2160" x=".5281" y=".8472" width=".15" height=".004" />
  </meta>

  <meta meter="armor" tags="minecraft, vlc" x=".3124" y=".83" width=".164" height=".0020" h="0-360" s="0-10" l="70-80"
    type="area">
  <resolution size="2560x1440" x=".29" y=".805" width=".164" height=".004" />
  <resolution size="3840x2160" x=".29" y=".81" width=".164" height=".004" />
  </meta>
  <meta meter="xp" tags="minecraft, vlc" x=".3188" y=".9009" width=".376" height=".002" h="80-100" s="30-100" l="0-100"
    type="area">
  <resolution size="2560x1440" x=".2898" y=".8861" width=".376" height=".002" />
  <resolution size="3840x2160" x=".2898" y=".8861" width=".376" height=".002" />
  </meta>

  <meta meter="boss" tags="minecraft, vlc" x=".3151" y=".0490" width=".3125" height=".002" h="260-330" s="80-100"
    l="70-100" type="area">
  <resolution size="2560x1440" x=".2898" y=".8861" width=".376" height=".002" />
  <resolution size="3840x2160" x=".2898" y=".8861" width=".376" height=".002" />
  </meta>

  <meta meter="inGame1" tags="minecraft, vlc" x=".3151" y=".0499" width=".3125" height=".001" h="0-360" s="0-10"
    l="50-100" type="area">
  <resolution size="2560x1440" x=".3058" y=".91288" width=".3815" height=".001" />
  <resolution size="3840x2160" x=".2898" y=".8861" width=".376" height=".001" />
  </meta>
</head>

<body style="margin: 0; padding: 0; background: #000">
  <canvas id="exCanvas" width="320" height="200"></canvas>
</body>

<script>

  var canvas, ctx;
  var stateHdlr = new StateHandler();
  var healthMeter = new Meter(10, onHealthMeterChanged);
  var xpMeter = new Meter(10, onXpMeterChanged);
  var foodMeter = new Meter(50, onFoodMeterChanged);
  var armorMeter = new Meter(10, onArmorMeterChanged);
  var bossMeter = new Meter(10, onBossMeterChanged);
  var fireMeter = new Meter(3, onFireMeterChanged);
  var foodMeterBlocker = new Meter(10, onFoodMeterChanged);
  var inGameMeter = new Meter(5, onGameChanged)
  var effects = [];
  var inGame = false;


  function update() {
    IdleState();
    inGameMeter.setValue(engine.vision.inGame1)
    healthMeter.setValue(engine.vision.health);
    if (inGame) {
      xpMeter.setValue(engine.vision.xp);
      foodMeter.setValue(engine.vision.food);
      armorMeter.setValue(engine.vision.armor);
      bossMeter.setValue(engine.vision.boss);
      fireMeter.setValue(engine.vision.Fire)
    }

    //Effect handler 
    for (let i = 0; i < effects.length; i++) {
      effects[i].draw();
      if (effects[i].lifetime <= 0) {
        effects.splice(i, 1);
      }
    }

    stateHdlr.Process();
    window.requestAnimationFrame(update);
  }


  //Callbacks
  function onGameChanged() {
    if (inGameMeter.value > 0.5 && healthMeter.value > 0) {
      if (inGame == false) {
        effects.length = 0;
      }
      inGame = true;
    } else {
      inGame = false
    }
  }

  function onFireMeterChanged() {
    if (enableFire === 1) {
      if (fireMeter.value > 0.5) {
        effects.push(new fireState());
      }
    }
  }
  function onHealthMeterChanged() {
    //console.log(healthMeter.value);
    if (enableHealth == 1 && inGame) {
      if (healthMeter.decreased) {
        effects.push(new DamageState());
      } else if (healthMeter.increased) {
        effects.push(new HealState());
      }
    }
  }

  function onXpMeterChanged() {
    if (enableXP == 1) {
      if (xpMeter.increased && xpMeter.value > 0.01) {
        effects.push(new XpUpState());
      }
    }
  }

  function onFoodMeterChanged() {
    //console.log(foodMeter.value);
    if (enableHunger == true) {
      if (foodMeter.decreased) {
        effects.push(new HungerState());
      } else if (foodMeter.increased) {
        effects.push(new fedState());
      }
    }
  }

  function onArmorMeterChanged() {
    effects.push(new ArmorState());
  }

  function onBossMeterChanged() {
    if (enableBoss == 1) {
      if (bossMeter.increased) {
        //console.log(bossMeter.value);
        effects.push(new BossState());
      }
    }
  }

  function XpUpState() {
    this.start = new Date().getTime();
    this.lifetime = 45;

    this.draw = function () {
      this.lifetime -= 1;
      ctx.fillStyle = "#42d113";
      ctx.fillRect(0, 0, 320, 200);
      ctx.fillStyle = "#e1ff00";
      ctx.beginPath();
      ctx.arc(Math.random() * 320, Math.random() * 200, 25, 0, 2 * Math.PI);
      ctx.arc(Math.random() * 320, Math.random() * 200, 25, 0, 2 * Math.PI);
      ctx.arc(Math.random() * 320, Math.random() * 200, 25, 0, 2 * Math.PI);
      ctx.fill();
    };
  }
  function fireState() {
    this.start = new Date().getTime();
    this.lifetime = 20;
    this.draw = function () {
      this.lifetime -= 1;
      ctx.fillStyle = "#e25822";
      ctx.fillRect(0, 0, 320, 200);
      ctx.fillStyle = "#fac000";
      ctx.fillRect(Math.random() * 320, Math.random() * 200, 50, 50);
      ctx.fillRect(Math.random() * 320, Math.random() * 200, 50, 50);
      ctx.fillRect(Math.random() * 320, Math.random() * 200, 50, 50);
      ctx.fillRect(Math.random() * 320, Math.random() * 200, 50, 50);
    };
  }

  function DamageState() {
    this.start = new Date().getTime();
    this.lifetime = 45;

    this.draw = function () {
      this.lifetime -= 1;
      if (this.lifetime > 10 && this.lifetime < 15) {
        ctx.fillStyle = "#ffffff";
      } else if (this.lifetime > 40 && this.lifetime < 45) {
        ctx.fillStyle = "#ffffff";
      } else {
        ctx.fillStyle = effectHex1;
      }
      ctx.fillRect(0, 0, 320, 200);
    };
  }

  function HealState() {
    this.start = new Date().getTime();
    this.lifetime = 45;

    this.draw = function () {
      this.lifetime = 2000 - (new Date().getTime() - this.start)

      ctx.fillStyle = "#ff57ae";
      ctx.fillRect(0, 0, 320, 200);

      ctx.strokeStyle = "white";
      ctx.lineWidth = 10;
      ctx.beginPath();
      ctx.arc(160, 100, (200 - (this.lifetime) / 10), 0, 2 * Math.PI);
      ctx.stroke();

      ctx.fillStyle = "white";
      ctx.fillRect(Math.random() * 320, Math.random() * 200, 10, 10);
      ctx.fillRect(Math.random() * 320, Math.random() * 200, 10, 10);
      ctx.fillRect(Math.random() * 320, Math.random() * 200, 10, 10);
    };
  }

  function ArmorState() {
    this.start = new Date().getTime();
    this.lifetime = 45;

    this.draw = function () {
      this.lifetime -= 1;

      if (this.lifetime < 10) {
        ctx.fillStyle = "rgba(255,255,255," + this.lifetime / 10 + ")";
      } else if (this.lifetime > 35) {
        ctx.fillStyle = "rgba(255,255,255," + (35 - this.lifetime) / 10 + ")";
      } else {
        ctx.fillStyle = "white";
      }
      ctx.fillRect(0, 0, armorMeter.value * 500, 200);
    };
  }

  function IdleState() {
    let lightness = new Int8Array(engine.zone.lightness);
    let sat = new Int8Array(engine.zone.saturation);
    let hue = new Int16Array(engine.zone.hue);

    for (var iZone = 0; iZone < 560; iZone++) {
      ctx.fillStyle = 'hsl(' + hue[iZone] + ',' + sat[iZone] + '%,' + lightness[iZone] + '%)'

      var iRow = Math.floor(iZone / 28);
      var iCol = iZone % 28;
      var iWidth = 320 / 28;
      var iHeight = 200 / 20;
      var iZx = iCol * iWidth;
      var iZy = iRow * iHeight;

      ctx.fillRect(iZx, iZy, iWidth, iHeight);

    }
  }

  function BossState() {
    this.Process = function () {
      let lightness = new Int8Array(engine.zone.lightness);
      let sat = new Int8Array(engine.zone.saturation);
      let hue = new Int16Array(engine.zone.hue);
      //console.log(bossMeter.value);
      for (var iZone = 0; iZone < 560; iZone++) {
        if (iZx > bossMeter.value * 320) {
          ctx.fillStyle =
            "hsl(" +
            hue[iZone] +
            "," +
            sat[iZone] +
            "%," +
            lightness[iZone] +
            "%)";
        } else {
          ctx.fillStyle =
            "hsl(" + 273 + "," + sat[iZone] + "%," + lightness[iZone] + "%)";
        }
        var iRow = Math.floor(iZone / 28);
        var iCol = iZone % 28;
        var iWidth = 320 / 28;
        var iHeight = 200 / 20;
        var iZx = iCol * iWidth;
        var iZy = iRow * iHeight;

        ctx.fillRect(iZx, iZy, iWidth, iHeight);
      }
    };
  }

  function HungerState() {
    this.start = new Date().getTime();
    this.lifetime = 45;
    this.draw = function () {
      this.lifetime -= 1;

      ctx.fillStyle = effectHex3;
      ctx.fillRect(0, 0, 320, 200);
    };
  }

  function fedState() {
    this.start = new Date().getTime();
    this.lifetime = 45;

    this.draw = function () {
      this.lifetime -= 1;

      ctx.fillStyle = effectHex4;
      ctx.fillRect(0, 0, 320, 200);

      ctx.fillStyle = "white";
      ctx.fillRect(Math.random() * 320, Math.random() * 200, 10, 10);
      ctx.fillRect(Math.random() * 320, Math.random() * 200, 10, 10);
      ctx.fillRect(Math.random() * 320, Math.random() * 200, 10, 10);
    };
  }



  function StateHandler() {
    var stack = [];
    var state = null;

    // Set current state to the top item in the stack
    var updateState = function () {
      if (stack.length > 0) {
        state = stack[stack.length - 1];
      } else {
        state = null;
      }
    };

    // Allows dev to add effect to state handler
    this.Push = function (newState) {
      stack.push(newState);
      updateState();
    };
    // Allows dev to remove effect from handler
    this.Pop = function () {
      stack.pop();
      updateState();
    };
    // Call the Process function of the current state (effect)
    this.Process = function () {
      if (state != null) {
        state.Process();
      }
    };
  }

  function Meter(count, callback) {
    this.size = count;
    this.value = 0;
    this.diff = 0;
    this.increased = false;
    this.decreased = false;
    var values = [];

    this.setValue = function (updatedValue) {
      // Add and shift.
      values.push(updatedValue);
      if (values.length > this.size) {
        values.shift();
      }

      // Exit early if we've got a long-term match.
      for (var i = 0; i < values.length - 1; i++) {
        if (values[i] !== values[i + 1]) return;
      }

      // We got here, so we've got a matching value collection.
      if (this.value !== values[0]) {
        //var fromZero = this.value === 0;
        //var toZero = values[0] === 0;
        this.diff = Math.abs(this.value - values[0]);
        this.increased = this.value < values[0];
        this.decreased = this.value > values[0];
        this.value = values[0];

        callback();
      }
    };
  }



  function onEngineReady() {
    // Grab canvas and rendering context.
    canvas = document.getElementById("exCanvas");
    ctx = canvas.getContext("2d");

    // Start updates *after* our engine is accessible and ready.
    window.requestAnimationFrame(update);
  }
</script>
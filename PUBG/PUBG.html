<head>
  <title>PUBG: Battlegrounds</title>
  <meta description="Explore the solar system with ambience and RGB effects." />
  <meta publisher="SignalRGB" />

  <meta property="keyScreenBrightness" label="Ambience brightness" type="number" min="0" max="100" default="100" />

  <meta meter="inGame" tags="PUBG,PLAYERUNKNOWN'S BATTLEGROUNDS" type="area" x="0.4991" y="0.0208" width="0.003" height=".001" h="0-360"
    s="0-20" l="80-100">
  </meta>
  <meta meter="hpWhite" tags="PUBG,PLAYERUNKNOWN'S BATTLEGROUNDS" type="area" x="0.4208" y="0.959" width="0.001" height=".001" h="0-360"
    s="0-10" l="60-100">
  </meta>
  <meta meter="hpYellow" tags="PUBG,PLAYERUNKNOWN'S BATTLEGROUNDS" type="area" x="0.4208" y="0.959" width="0.001" height=".001" h="0-360"
    s="0-10" l="60-100">
  </meta>
  <meta meter="hpPink" tags="PUBG,PLAYERUNKNOWN'S BATTLEGROUNDS" type="area" x="0.4208" y="0.959" width="0.001" height=".001" h="0-10"
    s="60-70" l="80-100">
  </meta>
  <meta meter="hpRed" tags="PUBG,PLAYERUNKNOWN'S BATTLEGROUNDS" type="area" x="0.4208" y="0.959" width="0.001" height=".001" h="0-10"
    s="90-100" l="90-100">
  </meta>
  <meta meter="ammo0" tags="PUBG,PLAYERUNKNOWN'S BATTLEGROUNDS" type="area" x="0.4977" y="0.9213" width="0.0005" height=".01" h="0-10"
    s="90-100" l="80-100">
  </meta>
  <meta meter="zoneClosing" tags="PUBG,PLAYERUNKNOWN'S BATTLEGROUNDS" type="area" x="0.888" y="0.7181" width="0.001" height=".002" h="340-360"
    s="80-100" l="80-100">
  </meta>
  <meta meter="zoneClosing2" tags="PUBG,PLAYERUNKNOWN'S BATTLEGROUNDS" type="area" x="0.888" y="0.7181" width="0.001" height=".002" h="0-20"
  s="80-100" l="80-100">
</meta>
  <meta meter="boostYellow" tags="PUBG,PLAYERUNKNOWN'S BATTLEGROUNDS" type="area" x="0.4213" y="0.9503" width="0.1593" height=".0001" h="40-50"
  s="60-75" l="75-100">
  </meta>
  <meta meter="inventory1" tags="PUBG,PLAYERUNKNOWN'S BATTLEGROUNDS" type="area" x="0.1743" y="0.0604" width="0.001" height="0.01" h="0-360"
  s="0-10" l="60-75">
  </meta>
  <meta meter="inventory2" tags="PUBG,PLAYERUNKNOWN'S BATTLEGROUNDS" type="area" x="0.273" y="0.06" width="0.001" height="0.01" h="0-360"
  s="0-10" l="60-75">
  </meta>
  <meta meter="kill" tags="PUBG,PLAYERUNKNOWN'S BATTLEGROUNDS" type="area" x="0.4953" y="0.731" width="0.025" height="0.002" h="0-15"
  s="70-100" l="70-100">
  </meta>
  <meta meter="assist" tags="PUBG,PLAYERUNKNOWN'S BATTLEGROUNDS" type="area" x="0.4872" y="0.7309" width="0.025" height="0.002" h="40-60"
  s="70-100" l="70-100">
  </meta>
  <meta meter="vehicleHP" tags="PUBG,PLAYERUNKNOWN'S BATTLEGROUNDS" type="area" x="0.1478" y="0.9667" width="0.001" height="0.005" h="0-360"
  s="0-25" l="75-100">
  </meta>
  <meta meter="vehicleEmpty" tags="PUBG,PLAYERUNKNOWN'S BATTLEGROUNDS" type="area" x="0.1464" y="0.9383" width="0.001" height="0.004" h="0-10"
  s="70-100" l="25-50">
  </meta>
</head>

<body style="margin: 0; padding: 0; background: #000;">
  <canvas id="exCanvas" width="320" height="200"></canvas>
</body>

<script>
  //engine.zone
  var canvas, ctx;
  canvas = document.getElementById('exCanvas');
  ctx = canvas.getContext('2d');
  var width = 320;
  var height = 200;
  var stateHdlr = new StateHandler();
  var effects = [];
  var noAmmo = false;
  var zoneClosingNow = false;
  var boosted = false;
  var inGameBool = false;

  var InGameMeter = new Meter(15, inGameHandler);
  var HealthWhiteMeter = new Meter(5, healthHandler);
  var HealthPinkMeter = new Meter(5, healthHandler);
  var HealthRedMeter = new Meter(5, healthHandler);
  var HealthYellowMeter = new Meter(5, healthHandler);
  var NoAmmoMeter = new Meter(5, ammoHandler);
  var ZoneClosingMeter = new Meter(8, zoneHandler);
  var BoostMeter = new Meter(5, boostHandler);
  var Inventory1Meter = new Meter(8, inGameHandler);
  var Inventory2Meter = new Meter(8, inGameHandler);
  var KillMeter = new Meter(10, killHandler);
  var AssistMeter = new Meter(10, assistHandler);
  var VehicleHPMeter = new Meter(10, vehicleHandler);
  var VehicleEMeter = new Meter(10, vehicleHandler);

  function update() {
    drawRect(0, 0, 200, 320, "black");

    if (keyScreenBrightness > 5) {
      copyScreen(1);
    }

    InGameMeter.setValue(engine.vision.inGame);
    Inventory1Meter.setValue(engine.vision.inventory1);
    Inventory2Meter.setValue(engine.vision.inventory2);
    
    if(inGameBool){
      HealthWhiteMeter.setValue(engine.vision.hpWhite);
      HealthPinkMeter.setValue(engine.vision.hpPink);
      HealthRedMeter.setValue(engine.vision.hpRed);
      HealthYellowMeter.setValue(engine.vision.hpYellow);
      NoAmmoMeter.setValue(engine.vision.ammo0);
      ZoneClosingMeter.setValue(engine.vision.zoneClosing);
      BoostMeter.setValue(engine.vision.boostYellow);
      KillMeter.setValue(engine.vision.kill);
      AssistMeter.setValue(engine.vision.assist);
      VehicleHPMeter.setValue(engine.vision.vehicleHP);
      VehicleEMeter.setValue(engine.vision.vehicleEmpty);
    }

    for (let i = 0; i < effects.length; i++) {
      effects[i].draw();
      if (effects[i].lifetime <= 0) {
        effects.splice(i, 1);
      }
    };

    stateHdlr.Process();
    window.requestAnimationFrame(update);
  };

  function inGameHandler(){
    if(InGameMeter.value == 1){
      effects = [];
      inGameBool = true;
      console.log("In Game " + Date.now())
    } else if (InGameMeter.value == 0){
      effects = [];
      inGameBool = false;
      if(Inventory1Meter.value == 1 && Inventory2Meter.value == 1){
        console.log("IN INVENTORY " + Date.now())
      }
    }
  }

  function healthHandler(){
    if(HealthWhiteMeter.value == 1){
      console.log("GOOD HEALTH")
    } else if (HealthYellowMeter.value == 1){
      console.log("MEDIUM HEALTH")
    } else if (HealthPinkMeter.value == 1){
      console.log("LOW HEALTH")
    } else if (HealthRedMeter.value == 1){
      console.log("DOWNED")
    }
  }

  function ammoHandler(){
    if(NoAmmoMeter.value == 1){
      console.log("NO AMMO " + Date.now())
      noAmmo = true;
    } if (noAmmo && NoAmmoMeter.value == 0){
      noAmmo = false;
      console.log("RELOAD " + Date.now())
    }
  }

  function zoneHandler(){
    if(ZoneClosingMeter.value == 1 && !zoneClosingNow){
      console.log("ZONE CLOSING " + Date.now());
      zoneClosingNow = true;
    } else if (ZoneClosingMeter.value == 0 && engine.vision.zoneClosing2 == 0 && zoneClosingNow) {
      console.log("ZONE DONE CLOSED " + Date.now())
      zoneClosingNow = false;
    }
  }

  function boostHandler(){
    if(BoostMeter.value == 1 && !boosted){
      console.log("BOOSTED " + Date.now())
      boosted = true;
    } else if (BoostMeter.value == 0 && boosted){
      console.log("NO BOOST " + Date.now())
      boosted = false;
    }
  }

  function killHandler(){
    if(KillMeter.value > .5){
      console.log("KILL " + Date.now())
    }
  }

  function assistHandler(){
    if(AssistMeter.value > .5){
      console.log("ASSIST " + Date.now())
    }
  }

  function vehicleHandler(){
    if(VehicleEMeter.value > .75 && VehicleHPMeter.value == 1){
      console.log("IN VEHICLE " + Date.now())
    }
  }

  function renderPath(x, y, path, color) {
    ctx.fillStyle = color;
    ctx.save();
    ctx.translate(x, y);
    let ex = new Path2D(path);
    ctx.fill(ex);
    ctx.restore();
  }

  function DrawCircle(x, y, radius, color) {
    ctx.beginPath();
    ctx.fillStyle = color;
    ctx.arc(x, y, radius, 0, 2 * Math.PI)
    ctx.fill();
  };

  function DrawStroke(x, y, radius, color, stroke) {
    ctx.beginPath();
    ctx.strokeStyle = color;
    ctx.lineWidth = stroke;
    ctx.arc(x, y, radius, 0, 2 * Math.PI)
    ctx.stroke();
  };

  function drawRect(x, y, height, width, color) {
    ctx.beginPath();
    ctx.fillStyle = color;
    ctx.fillRect(x, y, height, width);
  }

  function copyScreen(alpha) {
    var shine = engine.vision.ShineMeter
    let lightness = new Int8Array(engine.zone.lightness);
    let sat = new Int8Array(engine.zone.saturation);
    let hue = new Int16Array(engine.zone.hue);
    for (var iZone = 0; iZone < 560; iZone++) {
      var iRow = Math.floor(iZone / 28);
      var iCol = iZone % 28;
      var iWidth = 320 / 28;
      var iHeight = 200 / 20;
      var iZx = iCol * iWidth;
      var iZy = iRow * iHeight;
      ctx.fillStyle =
        "hsla(" +
        hue[iZone] +
        "," +
        sat[iZone] +
        "%," +
        lightness[iZone] * keyScreenBrightness / 100 +
        "%, " +
        `${alpha}` +
        ")";

      ctx.fillRect(iZx, iZy, iWidth, iHeight);
    }

  }

  function StateHandler() {
    var stack = [];
    var state = null;

    var updateState = function () {
      if (stack.length > 0) {
        state = stack[stack.length - 1];
      } else {
        state = null;
      }
    };

    this.Push = function (newState) {
      stack.push(newState);
      updateState();
    };

    this.Pop = function () {
      stack.pop();
      updateState();
    };

    this.Process = function () {
      if (state != null) {
        state.Process();
      }
    };
  }

  function Meter(size, callback) {
    this.size = size;
    this.value = 0;
    this.diff = 0;
    this.increased = false;
    this.decreased = false;
    var values = [];

    this.setValue = function (updatedValue) {
      values.push(updatedValue);
      if (values.length > this.size) {
        values.shift();
      }

      for (var i = 0; i < values.length - 1; i++) {
        if (values[i] !== values[i + 1]) return;
      }
      if (this.value !== values[0]) {
        this.diff = Math.abs(this.value - values[0]);
        this.increased = this.value < values[0];
        this.decreased = this.value > values[0];
        this.value = values[0];
        callback();
      }
    };
  }

  function timedMeter(size, callback) {
    this.size = size;
    this.value = 0;
    this.diff = 0;
    this.increased = false;
    this.decreased = false;
    this.start = Date.now();
    this.elapsed = 0;
    var values = [];

    this.setValue = function (updatedValue) {
      values.push(updatedValue);
      this.elapsed = Date.now() - this.start;
      if (values.length > this.size) {
        values.shift();
      }

      for (var i = 0; i < values.length - 1; i++) {
        if (values[i] !== values[i + 1]) return;
      }
      if (this.value !== values[0]) {
        this.diff = Math.abs(this.value - values[0]);
        this.increased = this.value < values[0];
        this.decreased = this.value > values[0];
        this.value = values[0];
        this.start = Date.now();
        callback();
      }
    };
  }

  window.requestAnimationFrame(update);
</script>
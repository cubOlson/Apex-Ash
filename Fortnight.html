<head>
  <title>Fortnite Ch. 3 Season 1</title>
  <meta description="Ambience and metering for Fortnite Season 7" />
  <meta publisher="WhirlwindFX" />
  <meta
    property="enableAmmo"
    label="Ammo low effect"
    type="boolean"
    default="1"
  />
  <meta property="myHuePicker1" label="Ammo low effect Hue Control" type="hue" default="0" min="0" max="360">
  <meta
    property="enableKill"
    label="Kill effect"
    type="boolean"
    default="1"
  />
  <meta property="myHuePicker2" label="Kill Hue Control" type="hue" default="167" min="0" max="360">
  <meta
    property="enableXP"
    label="XP effect"
    type="boolean"
    default="1"
  />
  <meta
    property="enableShield"
    label="Shield effect"
    type="boolean"
    default="1"
  />
  <meta
    property="enableVehicle"
    label="Vehicle effect"
    type="boolean"
    default="1"
  />
  <meta property="myHuePicker3" label="Vehicle Hue Control" type="hue" default="30" min="0" max="360">
  <meta
    property="enableHP"
    label="Health effect"
    type="boolean"
    default="1"
  />
  <meta
  property="enableCircle"
  label="Storm enclosing effect"
  type="boolean"
  default="1"
/>
<meta
meter="circle"
tags="vlc,fortnite"
type="area"
x= "0.4292"
y= "0.1991"
height= "0.00056"
width= "0.00042"
h="298-300"
s="72-73"
l="99-100"
/>
  <meta
    meter="ammo"
    tags="vlc,fortnite"
    x=".676"
    y=".8674"
    width=".025"
    height=".0335"
    type="ocr_numeric"
    confidence="40"
  />
  <meta
  meter="notBuilding"
  tags="vlc,fortnite"
  x=".8235"
  y=".7935"
  width=".01"
  height=".028"
  type="ocr_textmatch"
  confidence="70"
/>
<meta
meter="Building"
tags="vlc,fortnite"
x=".7584"
y=".805"
width=".01"
height=".028"
type="ocr_textmatch"
confidence="70"
/>
<meta
meter="build1"
tags="vlc,fortnite"
x=".7896"
y=".7796"
width=".01"
h="0-360"
s="0-20"
l="90-100"
type="linear"
/>
<meta
meter="build2"
tags="vlc,fortnite"
x=".8307"
y=".7796"
width=".01"
h="0-360"
s="0-20"
l="90-100"
type="linear"
/>
<meta
meter="build3"
tags="vlc,fortnite"
x=".8719"
y=".7796"
width=".01"
h="0-360"
s="0-20"
l="90-100"
type="linear"
/>
<meta
meter="build4"
tags="vlc,fortnite"
x=".9120"
y=".7796"
width=".01"
h="0-360"
s="0-20"
l="90-100"
type="linear"
/>
  <meta
    meter="ammo2"
    tags="vlc,fortnite"
    x=".685"
    y=".8674"
    width=".0230"
    height=".0335"
    type="ocr_numeric"
    confidence="50"
  />
  <meta
    meter="kill"
    tags="vlc,fortnite"
    x=".939"
    y=".2937"
    width=".0149"
    height=".029"
    type="ocr_numeric"
    confidence="60"
  />
  <meta
    property="boost"
    label="Color Boost"
    type="number"
    min="0"
    max="20"
    default="0"
  />
  <meta
    property="firecolor"
    label="Fire Color"
    type="hue"
    min="0"
    max="40"
    default="30"
  />
  <meta
    property="emissionrate"
    label="Emission Rate"
    type="number"
    min="1"
    max="5"
    default="5"
  />
<meta
	meter="exit"
	tags="vlc,fortnite"
  type="area"
	x= "0.0536"
	y= "0.7981"
	height= "0.0019"
	width= "0.0005"
	h="280-340"
	s="20-100"
	l="20-100"
/>
  <meta
    meter="health"
    tags="vlc,fortnite"
    x= ".0480" 
    y=".9"
    width=".2"
    height=".020"
    h="70-140"
    s="40-100"
    l="40-100"
    type="area"
  />
  <meta
    meter="shields"
    tags="vlc,fortnite"
    x=".05"
    y=".8770"
    width=".2"
    height=".010"
    h="180-212"
    s="70-100"
    l="60-100"
    type="area"
  />
  <meta
    meter="battlebus"
    tags="vlc,fortnite"
    x=".50266"
    y=".0926"
    width=".08"
    height=".0050"
    h="220-225"
    s="80-100"
    l="50-100"
    type="area"
  />
  <meta
    meter="knock"
    tags="vlc,fortnite"
    x=".054"
    y=".8981"
    width=".190"
    height=".010"
    h="338-347"
    s="95-100"
    l="79-98"
    type="area"
  />
  <meta
    meter="vehicle"
    tags="vlc,fortnite"
    x=".058"
    y=".86"
    width=".02"
    height=".0010"
    h="30-45"
    s="55-100"
    l="75-100"
    type="area"
  />
  <meta
    meter="xp"
    tags="vlc,fortnite"
    x=".009"
    y=".9875"
    width=".9"
    height=".004"
    h="45-55"
    s="70-100"
    l="50-100"
    type="area"
  />
</head>

<body style="margin: 0; padding: 0; background: #000;">
  <canvas id="exCanvas" width="320" height="200"></canvas>
</body>

<script>
  
  var canvas, ctx;
  var audio = [];
  var effects = [];
  var waves = [];
  var huez = [];
  var hue = 200;
  var sat = 100;
  var latency = 6;
  var stateMgr = new StateHandler();
  var currentBrightness = 0;
  var litPrev = 0;

  function arrayEqual(array) {
    for (var i = 0; i < array.length - 1; i++) {
      if (array[i] !== array[i + 1]) return false;
    }
    return true;
  }

  function random(min, max) {
    var num = Math.floor(Math.random() * (max - min)) + min;
    // if min = 10 max = 15 random var = 0.1544465; it will return approzimately 10 because of math.floor
    return num;
  }

  var speed = 10;
  var width = 320;
  var height = 200;
  var gravity = true;
  function Particle(x, y, lifetime) {
    this.x = x;
    this.y = y;

    this.velX = random(-speed, speed);
    if (this.velX == 0) this.velX = 1;

    this.velY = random(-speed, speed);
    if (this.velY == 0) this.velY = 1;

    this.brightness = random(30, 50);
    this.color = "hsl(" + firecolor + ",100%," + this.brightness + "%)";
    this.size = random(5, 10);

    this.offscreen = false;
    this.lifetime = lifetime;
    this.date = new Date();
    this.birth = this.date.getTime();
  }

  Particle.prototype.draw = function () {
    ctx.beginPath();
    ctx.fillStyle = "hsl(" + firecolor + ",100%," + this.brightness + "%)";
    ctx.arc(this.x, this.y, this.size, 0, 2 * Math.PI);
    ctx.fill();
  };

  Particle.prototype.update = function () {
    this.x += this.velX;
    this.y += this.velY;

    if (gravity) {
      this.velY += 0.9;
      if (this.velY > 9.1) {
        this.velY = 9.1;
      }
    }

    if (this.x < 0) {
      this.offscreen = true;
    }

    if (this.x > width + this.size || this.x < -this.size) {
      this.offscreen = true;
    }

    if (this.y > height + this.size) {
      this.offscreen = true;
    }

    if (this.y < 0) {
      this.offscreen = true;
    }
  };

  function Wave(stop, color) {
    this.color = color;
    this.stopVal = stop;
    this.lifetime = 0;
  }

  Wave.prototype.draw = function () {
    ctx.fillStyle = this.color;
    var width = this.stopVal / (60 - this.lifetime);
    ctx.fillRect(0, 0, this.stopVal, 200);
  };

  Wave.prototype.update = function () {
    this.lifetime++;
  };

  var vShield = [];
  var vHealth = [];
  var vXp = [];
  var vKill = [];
  var shieldPrev = 0;
  var healthPrev = 0;
  var killPrev = 0;
  var damageBrightness = 0;
  var healthBrightness = 0;
  var shieldBrightness = 0;
  var shieldDamageBrightness = 0;
  var vehiclePhase = 0;
  var shieldValue = 0;
  var healthValue = 0;
  var notBuildingAnim = false;
  var BuildingAnim = false;
  
  var move = 0;
  var lazerMove =0;
  var lazerMove2 =0;
  var lazerx1 = 160;
  var lazery1 = 200;
  var circleMeter = new Meter(3, circleChange);
  var BuildingMeter = new Meter(4, checkBuild);
  var notBuildingMeter = new Meter(4, checkBuild);

  function circleChange(){
      if(circleMeter.increased){
        console.log(circleMeter.value);
        stateMgr.Push(new reversePulseRippleState("#8000ff", true));
      }
    }

    function reversePulseRippleState(color, hollow) {
    this.start = new Date().getTime();
    this.duration = 2000;
    this.count = 2000;
    this.color = color;
    this.isHollow = hollow;
    
    this.Process = function () {
      this.elapsed = new Date().getTime() - this.start;
      if (this.elapsed > this.duration) {
        stateMgr.Pop();
      }
      this.Draw();
    };

    this.Draw = function () {
      ctx.fillStyle = "black";
      ctx.fillRect(0, 0, 320, 200);
      var pctUp = this.count / 2000;
      if (this.isHollow) {
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 20;
        ctx.beginPath();
        ctx.arc(160, 100, 200  * pctUp, 0, 2 * Math.PI);
        ctx.stroke();
      } else {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(160, 100, 200  * pctUp, 0, 2 * Math.PI);
        ctx.fill();
      }

      if (this.count < 100) {
        this.count = 2000;
      } else {
        this.count -= 75;
      }
    };
  }
  function PulseRippleState(color, hollow, duration) {
    this.start = new Date().getTime();
    this.duration = duration;
    this.count = 2000;
    this.color = color;
    this.isHollow = hollow;

    this.Process = function () {
      this.elapsed = new Date().getTime() - this.start;
      if (this.elapsed > this.duration) {
        stateMgr.Pop();
      }
      this.Draw();
    };

    this.Draw = function () {
      ctx.fillStyle = "black";
      ctx.fillRect(0, 0, 320, 200);
      var pctUp = this.count / 2000;
      if (this.isHollow) {
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 20;
        ctx.beginPath();
        ctx.arc(160, 100, 200 - 200 * pctUp, 0, 2 * Math.PI);
        ctx.stroke();
      } else {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(160, 100, 200 - 200 * pctUp, 0, 2 * Math.PI);
        ctx.fill();
      }

      if (this.count < 100) {
        this.count = 2000;
      } else {
        this.count -= 75;
      }
    };
  }
  function renderExtensions() {
    
    if(enableShield){
    vShield.push(engine.vision.shields);
    if (vShield.length > 15) {
      //console.log( "VShield = " + vShield);
      vShield.shift();
    }
    }
    if(enableHP){
    vHealth.push(engine.vision.health);
    if (vHealth.length > 15) {
      //console.log( "VHealth = " + vHealth);
      vHealth.shift();
    }
    }
    if(enableXP){
    vXp.push(engine.vision.xp);
    if (vXp.length > 15) {
      vXp.shift();
      //console.log(vXp);
    }
    }
    if (arrayEqual(vShield)) {
      shieldValue = vShield[0];
      //console.log( "Shield = " + shieldValue);
    }
    if (arrayEqual(vHealth)) {
      healthValue = vHealth[0];
      //console.log( "health = " + healthValue);
    }

    var bNoHealth = healthValue === 0;
    var bKnocked = engine.vision.knock > 0;
    if (bNoHealth && bKnocked) {
      ctx.fillStyle = "hsl(" + 0 + "," + 100 + "%," + random(30, 50) + "%)";
      ctx.fillRect(0, 0, 320, 200);
    }

    if (shieldPrev != shieldValue) { // if it changes
      var bFromZero = shieldPrev === 0 && healthPrev === 0; // if the old value isnt 0
      var bToZero = shieldValue === 0 && healthValue === 0; // if the player isnt dead

      if (!bFromZero && !bToZero) { // if both above are false
        if (shieldPrev > shieldValue) {
          shieldDamageBrightness = 50;
        } else {
          shieldBrightness = 50;
        }
      }

      shieldPrev = shieldValue;
    }

    if (healthPrev != healthValue) {
      var bFromZero = healthPrev === 0;
      var bToZero = healthValue === 0;
      if (!bFromZero && !bToZero) {
        if (healthPrev > healthValue) {
          damageBrightness = 50;
        } else {
          healthBrightness = 50;
        }
      }
      healthPrev = healthValue;
    }
    if(enableHP){
    if (healthValue > 0 && healthValue < 0.5) {
      for (var iIdx = 0; iIdx < 100; iIdx++) {
        ctx.fillStyle = "hsl(" + 345 + "," + 100 + "%," + random(20, 50) + "%)";
        ctx.fillRect(
          random(0, 300),
          random(0, 180),
          random(20, 50),
          random(50, 50)
        );
      }
    }
  }
    if (enableVehicle){
    if (healthValue > 0 && engine.vision.vehicle > 0.4) {
      var vBr = Math.sin((vehiclePhase / 100) * Math.PI) * 30;
      ctx.fillStyle = "hsl(" + myHuePicker3 + "," + 100 + "%," + (vBr + 20) + "%)";
      ctx.fillRect(0, 0, 320, 200);

      vehiclePhase++;
      if (vehiclePhase > 100) {
        vehiclePhase = 0;
      }
    }
    }
    if (shieldBrightness > 0) {
      var nShWid = 1 - Math.pow(shieldBrightness / 50, 3);
      ctx.fillStyle = "hsl(" + 190 + "," + 100 + "%," + nShWid * 50 + "%)";
      ctx.fillRect(0, 0, nShWid * 320, 200);
      shieldBrightness -= 1;
    }

    if (shieldDamageBrightness > 0) {
      var nShWid = shieldDamageBrightness / 50;
      ctx.fillStyle =
        "hsl(" + 345 + "," + 100 + "%," + shieldDamageBrightness + "%)";
      ctx.fillRect(0, 0, nShWid * 320, 200);
      shieldDamageBrightness -= 1;
    }

    if (healthBrightness > 0) {
      ctx.fillStyle = "hsl(" + 120 + "," + 100 + "%," + healthBrightness + "%)";
      ctx.fillRect(0, 0, 320, 200);
      healthBrightness -= 1;
    }

    if (damageBrightness > 0) {
      ctx.fillStyle = "hsl(" + 345 + "," + 100 + "%," + damageBrightness + "%)";
      ctx.fillRect(0, 0, 320, 200);
      damageBrightness -= 1;
    }

    for (i = 0; i < waves.length; i++) {
      waves[i].draw();
      waves[i].update();
    }

    for (i = 0; i < waves.length; i++) {
      if (waves[i].lifetime > 75) {
        waves.splice(i, 1);
      }
    }

    if (vXp[13] < vXp[14]) {
      waves.push(new Wave(vXp[14] * 320, "#fbd100"));
    }
  }
  function StateHandler() {
    var stack = [];
    var state = null;

    var updateState = function () {
      if (stack.length > 0) {
        state = stack[stack.length - 1];
      } else {
        state = null;
      }
    };

    this.Push = function (newState) {
      stack.push(newState);
      updateState();
    };

    this.Pop = function () {
      stack.pop();
      updateState();
    };

    this.Process = function () {
      if (state != null) {
        state.Process();
      }
    };
  }

  function onEngineReady() {
    // Grab canvas and rendering context.
    canvas = document.getElementById("exCanvas");
    ctx = canvas.getContext("2d");

    window.requestAnimationFrame(update);
  }

  var duration = 15;

  function Meter(count, callback) {
    this.size = count;
    this.value = 0;
    this.diff = 0;
    this.increased = false;
    this.decreased = false;
    var values = [];

    this.setValue = function (updatedValue) {
      // Add and shift.
      values.push(updatedValue);
      if (values.length > this.size) {
        values.shift();
      }

      // Exit early if we've got a long-term match.
      for (var i = 0; i < values.length - 1; i++) {
        if (values[i] !== values[i + 1]) return;
      }

      // We got here, so we've got a matching value collection.
      if (this.value !== values[0]) {
        //var fromZero = this.value === 0;
        //var toZero = values[0] === 0;
        this.diff = Math.abs(this.value - values[0]);
        this.increased = this.value < values[0];
        this.decreased = this.value > values[0];
        this.value = values[0];
        callback();
      }
    };
  }

  function buildStepUp(x, y){
    this.x = x;
    this.y = y;
    this.lifetime = 50;

    this.draw = function(){
      
      let index = 0;
      while(index < 5){
        ctx.beginPath();
        ctx.fillStyle = 'blue';
        ctx.globalAlpha = .6;
        ctx.fillRect(this.x + (100 * index),this.y,100,50);
        ctx.globalAlpha = 1;
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 15;
        ctx.strokeRect(this.x + (100 * index),this.y,100,50);
        index++;
      }

      this.lifetime--;
    }
  }

  function checkBuildMeters(){
    if(engine.vision.build1 || engine.vision.build2 || engine.vision.build3 || engine.vision.build4){
      return true
    }
      return false
  };

  function checkBuild(){
    if(BuildingMeter.value == 1 && checkBuildMeters() && !BuildingAnim){

      let index = 0;
      var intr = setInterval(function() {
        effects.push(new buildStepUp(0 - (index % 2 * 50), 200 - (50 * index)));
        if (++index == 6) clearInterval(intr);
      }, 150);

      BuildingAnim = true;
      notBuildingAnim = false;

    } else if (notBuildingMeter.value == 1 && !checkBuildMeters() && !notBuildingAnim){

      stateMgr.Push(new PulseRippleState('red', true, 1000));
      BuildingAnim = false;
      notBuildingAnim = true;

    }
  }

  function update() {
    BuildingMeter.setValue(engine.vision.Building);
    notBuildingMeter.setValue(engine.vision.notBuilding);



    if (engine.vision.battlebus || engine.vision.exit)
    {

      enableAmmo = false;
      enableHP = false;
      enableKill = false;
      enableShield = false;
      enableVehicle = false;
     
    }
    //console.log(engine.vision.xp);
    
    var brightness = (engine.audio.level + 20) / 20;

    
    if (brightness > currentBrightness + 0.25) {
      currentBrightness = brightness;
    }

    audio.push(brightness);
    if (audio.length > latency) {
      audio.shift();
    }

    // Is there a faster way to handle averaging?
    var average = 0;
    for (var iIdx = 0; iIdx < audio.length; iIdx++) {
      average += audio[iIdx];
    }
    average /= audio.length;

    // Range limit the average.
    if (average < 0.1) {
      average = 0.1;
    } else if (average > 1) {
      average = 1;
    }

    var lit = average * 40;

    //console.log("Light [0]: " + engine.zone.lightness.byteLength);
    let lightness = new Int8Array(engine.zone.lightness);
    let sat = new Int8Array(engine.zone.saturation);
    let zhue = new Int16Array(engine.zone.hue);

    for (var iZone = 0; iZone < 560; iZone++) {
      var xZoneBrightness = lightness[iZone];
      var hue = zhue[iZone] + boost;
      if(engine.vision.exit != 1){
      ctx.fillStyle =
        "hsl(" + hue + "," + sat[iZone] + "%," + xZoneBrightness + "%)";
      }
      
      if(engine.vision.exit == 1){
        ctx.fillStyle = "hsl(" + 280 + "," + 100 + "%," + xZoneBrightness + "%)";
      }
     
      var iRow = Math.floor(iZone / 28);
      var iCol = iZone % 28;
      var iWidth = 320 / 28;
      var iHeight = 200 / 20;
      var zx = iCol * iWidth;
      var zy = iRow * iHeight;

      ctx.fillRect(zx, zy, iWidth, iHeight);
    }

    renderExtensions();
    if(enableCircle){
    circleMeter.setValue(engine.vision.circle);
    }

    currentBrightness -= 0.01;
    if(enableKill){
     //console.log(engine.vision.kill);
     //console.log("killprev" + killPrev);
      if(engine.vision.kill >= 0){
        if (killPrev <= engine.vision.kill && duration <= 200 && duration > 0 && engine.vision.kill != -1){
          for (var iIdx = 0; iIdx < 300; iIdx++) {
          ctx.fillStyle = "hsl(" + myHuePicker2 + "," + 100 + "%," + random(20, 50) + "%)";
          ctx.fillRect(
          random(0, 300),
          random(0, 180),
          random(20, 50),
          random(50, 50)
        );
      }
       //console.log("cc" + duration);
        duration -= 1;
      }
      if(killPrev + 1 === engine.vision.kill)
      {
        killPrev = engine.vision.kill;
        duration=200;
      }
      if(0 == engine.vision.kill)
      {
        killPrev = engine.vision.kill;
      }
    }
    }

    if (enableAmmo) {
      if (engine.vision.ammo < 2 && engine.vision.ammo > 1 || engine.vision.ammo2 < 5 && engine.vision.ammo2 > 1) {
        ctx.fillStyle = "hsl(" + myHuePicker1 + "," + 100 + "%," + 30 + "%)";
        ctx.fillRect(0, 0, 320, 200);
        ctx.fillStyle = "hsl(" + myHuePicker1 + "," + 50 + "%," + 30 + "%)";
        ctx.fillRect(0, 0+move, 320, 50);
        move += 10;
        if(move === 200)
        {
          move = 0;
        }
      }
    }
  for (let i = 0; i < effects.length; i++) {
      effects[i].draw();
    }

    for (let i = 0; i < effects.length; i++) {
      if (effects[i].lifetime <= 0) {
        effects.splice(i, 1);
      }
    }
    stateMgr.Process();
    window.requestAnimationFrame(update);
  }
 
</script>

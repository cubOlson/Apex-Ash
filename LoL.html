<head>
  <title>League of Legends Cub Copy</title>
  <meta description="Metering and ambiance for League of Legends." />
  <meta publisher="WhirlwindFX" />
  <meta 
  property="character" 
  label="Champions" 
  type="combobox" 
  values="Ahri,Ashe,Aurelion Sol,Caitlyn,Cassiopeia,Diana,Ezreal,Garen,Irelia,
Janna,Jax,Jhin,Jinx,Kai'sa,Leona,Lucian,Lulu,Lux,Lee Sin,Miss Fortune,Rek'sai,
Ryze,Senna,Sona,Soraka,Teemo,Thresh,Vayne,Viktor,Yasuo,Yone,Zeri" 
  default="Ahri"
  />
  <meta
    property="keyScreenBrightness"
    label="Ambiance brightness"
    type="number"
    min="0"
    max="100"
    default="100"
  />
  <meta
  property="goldLimit"
  label="Gold Effect Threshold"
  type="number"
  min="0"
  max="10000"
  default="1000"
  />
  <meta
    property="enableHealth"
    label="Health effect"
    type="boolean"
    default="1"
  />
  <meta meter="lowHealth" tags="league" x=".3557" y=".9593" width=".0526" h="100-140" s="30-100" l="20-70" type="linear">
  </meta>
  <meta meter="lowMana" tags="league" x=".3557" y=".9778" width=".0526" h="200-230" s="50-100" l="40-70" type="linear">
  </meta>
  <meta meter="loadBar" tags="league" x=".3953" y=".7389" width=".2115" h="170-200" s="50-100" l="30-100" type="linear">
  </meta>
  <meta meter="checkLoadBar" tags="league" x=".3953" y=".7389" width=".001" h="170-200" s="50-75" l="30-50" type="linear">
  </meta>
  <meta meter="allyDeath1" tags="league" x=".8682" y=".7194" width=".001" h="30-70" s="20-60" l="70-90" type="linear">
  </meta>
  <meta meter="allyDeath2" tags="league" x=".9021" y=".7194" width=".001" h="30-70" s="20-60" l="70-90" type="linear">
  </meta>
  <meta meter="allyDeath3" tags="league" x=".9359" y=".7194" width=".001" h="30-70" s="20-60" l="70-90" type="linear">
  </meta>
  <meta meter="allyDeath4" tags="league" x=".9693" y=".7194" width=".001" h="30-70" s="20-60" l="70-90" type="linear">
  </meta>
  <meta meter="itemHover" tags="league" x=".8505" y=".7657" width=".001" height = "0.001"  h="0-360" s="0-100" l="0-30" type="area">
  </meta>
  <meta meter="qButton" tags="league" x=".3807" y=".8787" width=".001" height = "0.001"  h="20-170" s="30-100" l="20-100" type="area">
  </meta>
  <meta meter="wButton" tags="league" x=".4156" y=".8787" width=".001" height = "0.001"  h="20-170" s="30-100" l="20-100" type="area">
  </meta>
  <meta meter="eButton" tags="league" x=".45" y=".8787" width=".002" height = "0.001" h="20-170" s="30-100" l="20-100" type="area">
  </meta>
  <meta meter="rButton" tags="league" x=".4849" y=".8787" width=".001" height = "0.001"  h="20-170" s="30-100" l="20-100" type="area">
  </meta>
  <meta meter="ExtendedqButton" tags="league" x=".3807" y=".8787" width=".03"  height= "0.001" h="20-170" s="0-100" l="95-100" type="area">
  </meta>
  <meta meter="ExtendedwButton" tags="league" x=".4156" y=".8787" width=".031"  height= "0.001" h="20-170" s="0-100" l="95-100" type="area">
  </meta>
  <meta meter="ExtendedeButton" tags="league" x=".45" y=".8787" width=".03" height= "0.001" h="20-170" s="0-60" l="95-100" type="area">
  </meta>
  <meta meter="ExtendedrButton" tags="league" x=".4849" y=".8787" width=".03"  height= "0.001" h="20-170" s="0-100" l="95-100" type="area">
  </meta>
  <meta meter="ManaR" tags="league" x=".4849" y=".88" width=".03" height="0.035" h="170-200" s="50-100" l="50-100" type="area"></meta>
  <meta meter="ManaQ" tags="league" x=".3807" y=".8787" width=".03" height="0.035" h="170-200" s="50-100" l="50-100" type="area"></meta>
  <meta meter="ManaW" tags="league" x=".4156" y=".8787" width=".03" height="0.035" h="170-200" s="50-100" l="50-100" type="area"></meta>
  <meta meter="ManaE" tags="league" x=".45" y=".8787" width=".03" height="0.035" h="170-200" s="50-100" l="50-100" type="area"></meta>
  <meta meter="dButton" tags="league" x=".524" y=".8787" width=".001" h="20-170" s="30-100" l="20-100" type="linear">
  </meta>
  <meta meter="fButton" tags="league" x=".55" y=".8787" width=".001" h="20-170" s="30-100" l="20-100" type="linear">
  </meta>
  <meta meter="gold" tags="league" x=".6286" y=".9676" width=".0339" height=".0194" h="0-10" s="50-100" l="50-100" type="ocr_numeric" confidence="100">
  </meta>
  <meta meter="levelUp" tags="league" x=".3406" y=".9454" width=".001" height=".001" h="270-290" s="50-100" l="25-75" type="area">
  </meta>
  <meta meter="tookDamage" tags="league" x=".3557" y=".9593" width=".2125" height=".0001" h="0-25" s="50-100" l="50-100" type="area">
  </meta>
  <meta meter="alliedTurret" tags="league" x=".5984" y=".1352" width=".0073" height=".0056" h="190-210" s="65-100" l="75-100" type="area">
  </meta>
  <meta meter="enemyTurret" tags="league" x=".6516" y=".1352" width=".0073" height=".0056" h="0-10" s="50-100" l="50-100" type="area">
  </meta>
  <meta meter="inGame1" tags="league" x=".3073" y=".8713" width=".001" height=".002" h="20-50" s="50-70" l="30-70" type="area">
  </meta>
  <meta meter="inGame2" tags="league" x=".5214" y=".9352" width=".0542" height=".0056" h="160-200" s="40-100" l="0-25" type="area">
  </meta>
  <meta meter="ShopMenu" tags="league" x="0.1449" y=".1673" width=".5335" h="20-170" s="0-100" l="40-100" type="linear">
  </meta>
</head>

<body style="margin: 0; padding: 0; background: #000">
  <canvas id="exCanvas" width="320" height="200"></canvas>
</body>

<script>
  var c, ctx, champion;
  var stateMgr = new StateHandler();
  var effects = [];
  var height = 200;
  var width = 320;

  var ActiveExtendedE = false;
  var ActiveExtendedQ = false;
  var ActiveExtendedW = false;
  var freezeBackground = false;
  var StopEffects = false;
  var inShop;
  var noR = false;
  var noW = false;
  var noE = false;
  var noQ = false;
  var play1 = false;
  var play2 = false;
  var ActiveExtendedE = false;
  var goldAnimPushed = false;
  var utilityPlayed = false;
  var deadAllies = 0;
  var levelUpAnim = false;
  var deathAnim = false;
  var turretAnim = false;

  // All meter definitions
  var checkLoadMeter = new Meter(5, loadGoing);
  var allyMeter1 = new Meter(10, allyEffects);
  var allyMeter2 = new Meter(10, allyEffects);
  var allyMeter3 = new Meter(10, allyEffects);
  var allyMeter4 = new Meter(10, allyEffects);
  var q_Meter = new Meter(10, Q_Effects);
  var w_Meter = new Meter(10, W_Effects);
  var e_Meter = new Meter(10, E_Effects);
  var r_Meter = new Meter(4, R_Effects);
  var Extendedq_Meter = new Meter(5, ExtendedQ_Effects);
  var Extendedw_Meter = new Meter(5, ExtendedW_Effects);
  var Extendede_Meter = new Meter(2, ExtendedE_Effects);
  var Extendedr_Meter = new Meter(5, ExtendedE_Effects);
  var d_Meter = new Meter(5, Utility_Effects);
  var f_Meter = new Meter(5, Utility_Effects);
  var levelUpMeter = new Meter(5, levelUpEffect);
  var alliedTurretMeter = new Meter(5, turretEffects);
  var enemyTurretMeter = new Meter(5, turretEffects);
  var shopMenuMeter = new Meter (2, shopMenu);
  var manaRMeter = new Meter(3, manaR);
  var manaQMeter = new Meter(3, manaQ);
  var manaEMeter = new Meter(3, manaE);
  var manaWMeter = new Meter(3, manaW);
  var playingMeter1 = new Meter(10, playingGame1);
  var playingMeter2 = new Meter(10, playingGame2);
  var damageMeter = new Meter(1, damageEffects);
  var lowHealthMeter = new Meter(2, damageEffects);

  //UPDATE FUNCTION --------------------------------------------------------------------------------
  function update() {
    //Set all meter values each update
    checkLoadMeter.setValue(engine.vision.checkLoadBar);
    if(play1 && play2){
      manaWMeter.setValue(engine.vision.ManaW);
      manaQMeter.setValue(engine.vision.ManaQ);
      manaEMeter.setValue(engine.vision.ManaE);
      manaRMeter.setValue(engine.vision.ManaR);
      shopMenuMeter.setValue(engine.vision.ShopMenu)
      allyMeter1.setValue(engine.vision.allyDeath1);
      allyMeter2.setValue(engine.vision.allyDeath2);
      allyMeter3.setValue(engine.vision.allyDeath3);
      allyMeter4.setValue(engine.vision.allyDeath4);
      damageMeter.setValue(engine.vision.tookDamage);
      lowHealthMeter.setValue(engine.vision.lowHealth);
      if (!StopEffects) {
        if (!noQ) {
          q_Meter.setValue(engine.vision.qButton);
        }
        if (!noW) {
          w_Meter.setValue(engine.vision.wButton);
        }
        if (!noE) {
          e_Meter.setValue(engine.vision.eButton);
        }
        if (!noR) {
          r_Meter.setValue(engine.vision.rButton);
        }

        d_Meter.setValue(engine.vision.dButton);
        f_Meter.setValue(engine.vision.fButton);
        levelUpMeter.setValue(engine.vision.levelUp);
        alliedTurretMeter.setValue(engine.vision.alliedTurret);
        enemyTurretMeter.setValue(engine.vision.enemyTurret);
      }


      if (!ActiveExtendedE) {
        Extendede_Meter.setValue(engine.vision.ExtendedeButton);
      }
      Extendedq_Meter.setValue(engine.vision.ExtendedqButton)
      if (!ActiveExtendedW) {
        Extendedw_Meter.setValue(engine.vision.ExtendedwButton);
      }
      Extendedr_Meter.setValue(engine.vision.ExtendedrButton); 

    }
   
      playingMeter1.setValue(engine.vision.inGame1);
      playingMeter2.setValue(engine.vision.inGame2);

    champion = character;

    //Screen ambience play
    if(!freezeBackground){
      copyScreen();
    }
    
    //Effects animation play
    if(effects.length){
      effects.forEach((element, index) => {
        element.draw();
        if(element.lifetime <= 0){
          effects.splice(index, 1);
        }
      })
    }

    //Gold effect
    if(engine.vision.gold > goldLimit && !goldAnimPushed && play1 && play2){
      goldAnimPushed = true;
      effects.push(new goldEffect());
    }

    //Low Health Effect
    if (lowHealthMeter.value < 1 && lowHealthMeter.value > .05 && play1 && play2){
      for(let i = 0; i < 3; i++){
        effects.push(new ballPhysics(160, 200, Math.random()* 10 + 15, "red"))
      }
    }

    //State Manager animation play
    stateMgr.Process();
    window.requestAnimationFrame(update);
  }

  // START CALLBACK FUNCTIONS ----------------------------------------------------------------

  function Q_Effects(){
    if(q_Meter.value == 0){
      switch (champion) {
        case "Ahri":
          break;
        case "Ashe":
          effects.push(new asheQ())
          break;
        case "Aurelion Sol":
          break;
        case "Caitlyn":
          break;
        case "Cassiopeia":
          break;
        case "Diana":
          break;
        case "Ezreal":
          break;
        case "Garen":
          break;
        case "Irelia":
          break;
        case "Janna":
          break;
        case "Jax":
          break;
        case "Jhin":
          break;
        case "Jinx":
          break;
        case "Kai'sa":
          break;
        case "Lee Sin":
          break;
        case "Leona":
          break;
        case "Lucian":
          break;
        case "Lulu":
          break;
        case "Lux":
          break;
        case "Miss Fortune":
          effects.push(new FortuneQ());
          break;
        case "Rek'sai":
          break;
        case "Ryze":
          break;
        case "Sona":
          break;
        case "Soraka":
          break;
        case "Senna":
          break;
        case "Teemo":
          stateMgr.Push(new TeemoQ())
          break;
        case "Thresh":
          break;
        case "Vayne":
          break;
        case "Viktor":
          break;
        case "Yasuo":
          break;
        case "Yone":
          effects.push(new YoneQeffect())
          break;
        case "Zeri":
          break;
      }
    }
  };

  function ExtendedQ_Effects() {
    if(!ActiveExtendedQ){
      if (Extendedq_Meter.value > 0) {
        switch (champion) {
          case "Lux":
            break;
          case "Yone":
            effects.push(new ExtendedQYoneEffect());
            ActiveExtendedQ = true;
            break;
        }
      } 
    } else {
      if(Extendedq_Meter.value == 0){
        ActiveExtendedQ = false;
      }
    }
  };

  function W_Effects(){
    if(w_Meter.value == 0){
      switch (champion) {
        case "Ahri":
          break;
        case "Ashe":
          stateMgr.Push(new asheW())
          break;
        case "Aurelion Sol":
          break;
        case "Caitlyn":
          break;
        case "Cassiopeia":
          break;
        case "Diana":
          break;
        case "Ezreal":
          break;
        case "Garen":
          break;
        case "Irelia":
          break;
        case "Janna":
          break;
        case "Jax":
          break;
        case "Jhin":
          break;
        case "Jinx":
          break;
        case "Kai'sa":
          break;
        case "Lee Sin":
          break;
        case "Leona":
          break;
        case "Lucian":
          break;
        case "Lulu":
          break;
        case "Lux":
          break;
        case "Miss Fortune":
          effects.push(new ArrowEffect("up", "orange", 2, 7, 1000));
          break;
        case "Rek'sai":
          break;
        case "Ryze":
          break;
        case "Sona":
          break;
        case "Soraka":
          break;
        case "Senna":
          break;
        case "Thresh":
          break;
        case "Vayne":
          break;
        case "Viktor":
          break;
        case "Yasuo":
          break;
        case "Yone":
          stateMgr.Push(new YoneWeffect());
          break;
        case "Zeri":
          break;
      }
    }
  };

  function ExtendedW_Effects() {
   
    if(Extendedw_Meter.value > 0 && !StopEffects){
      ActiveExtendedW = true;
      switch (champion) {
        case "Teemo":
          effects.push(new ArrowEffect("up", "blue", 2 , 7,1000));
          ActiveExtendedW = false;
          break;
      }
    }
  };

  function E_Effects(){
    if(e_Meter.value == 0){
      switch (champion) {
        case "Ahri":
          break;
        case "Ashe":
          effects.push(new ArrowEffect("up", "hsl(184, 100%, 50%)",1, 7, 1000))
          break;
        case "Aurelion Sol":
          break;
        case "Caitlyn":
          break;
        case "Cassiopeia":
          break;
        case "Diana":
          break;
        case "Ezreal":
          break;
        case "Garen":
          break;
        case "Irelia":
          break;
        case "Janna":
          break;
        case "Jax":
          break;
        case "Jhin":
          break;
        case "Jinx":
          break;
        case "Kai'sa":
          break;
        case "Lee Sin":
          break;
        case "Leona":
          break;
        case "Lucian":
          break;
        case "Lulu":
          break;
        case "Lux":
          break;
        case "Miss Fortune":
          effects.push(new FortuneE())
          break;
        case "Rek'sai":
          break;
        case "Ryze":
          break;
        case "Sona":
          break;
        case "Soraka":
          break;
        case "Senna":
          break;
        case "Teemo":
          break;
        case "Thresh":
          break;
        case "Vayne":
          break;
        case "Viktor":
          break;
        case "Yasuo":
          break;
        case "Yone":
          ActiveExtendedE = false;
          break;
        case "Zeri":
          break;
      }
    }
  };

  function ExtendedE_Effects() {
    if(Extendede_Meter.value > 0){
      ActiveExtendedE = true;
      switch (champion) {
        case "Lux":
          break;
        case "Yone":
          effects.push(new ExtendedEYoneEffect("grey"));
          break;
      }    
    }
  };

  function R_Effects(){
    if(r_Meter.value == 0){
        switch (champion) {
        case "Ahri":
          break;
        case "Ashe":
          stateMgr.Push(new asheR())
          break;
        case "Aurelion Sol":
          break;
        case "Caitlyn":
          break;
        case "Cassiopeia":
          break;
        case "Diana":
          break;
        case "Ezreal":
          break;
        case "Garen":
          break;
        case "Irelia":
          break;
        case "Janna":
          break;
        case "Jax":
          break;
        case "Jhin":
          break;
        case "Jinx":
          break;
        case "Kai'sa":
          break;
        case "Lee Sin":
          break;
        case "Leona":
          break;
        case "Lucian":
          break;
        case "Lulu":
          break;
        case "Lux":
          break;
        case "Miss Fortune":
          stateMgr.Push(new FortuneR())
          break;
        case "Rek'sai":
          break;
        case "Ryze":
          break;
        case "Sona":
          break;
        case "Soraka":
          break;
        case "Senna":
          break;
        case "Teemo":
          stateMgr.Push(new TeemoR);
          break;
        case "Thresh":
          break;
        case "Vayne":
          break;
        case "Viktor":
          break;
        case "Yasuo":
          break;
        case "Yone":
          stateMgr.Push(new RYoneEffect());
          break;
        case "Zeri":
          break;
      } 
    }
  };

  function Utility_Effects(){
    if (d_Meter.decreased && d_Meter.value == 0 && checkAll() && !utilityPlayed){
      utilityPlayed = true;
      effects.push(new RippleEffect(160, 200, 10, 2000, 10, "yellow", "in", "stroke", 5, false))
    }
    if (f_Meter.decreased && f_Meter.value == 0 && checkAll() && !utilityPlayed){
      utilityPlayed = true;
      effects.push(new RippleEffect(160, 200, 10, 2000, 10, "yellow", "in", "stroke", 5, false))
    }
  };

  function allyEffects(){

    let count = 0;
    allyMeter1.value == 0 ? count++ : null;
    allyMeter2.value == 0 ? count++ : null;
    allyMeter3.value == 0 ? count++ : null;
    allyMeter4.value == 0 ? count++ : null;

    if (count > deadAllies && !deathAnim && play1 && play2 && engine.vision.itemHover != 1){
      deathAnim = true;
      effects.push(new deathEffect());
    };
    
    deadAllies = count;
  };

  function manaR(){
    if(manaRMeter.value > 0.6){
      noR = true;
    } else {
      noR = false
    }
  }
   function manaQ() {
      if (manaQMeter.value > 0.6) {
        noQ = true;
      } else {
        noQ = false
      }
    }
     function manaE() {
        if (manaEMeter.value > 0.6) {
          noE = true;
        } else {
          noE = false
        }
      }
       function manaW() {
          if (manaWMeter.value > 0.6) {
            noW = true;
          } else {
            noW = false
          }
        }

  function damageEffects(){
    if (damageMeter.value > .01){
      for(let i = 0; i < 10; i++){
        setTimeout(()=>{effects.push(new ballPhysics(160, 200, Math.random()* 10 + 15, "red"));}, 20);
      }
    }
  }

  function levelUpEffect(){
    if(levelUpMeter.decreased && !levelUpAnim && play1 && play2){
      levelUpAnim = true;
      StopEffects = true;
      effects.push(new BarEffect("up", "yellow", 10, 1000, 320, 3));
    } else if(levelUpMeter.value > .5){
      levelUpAnim = false;
    }
  };

  function checkAll(){
    if (!inShop && !StopEffects && play1 && play2){
      return true
    }
    return false;
  };

  function shopMenu(){
    if(shopMenuMeter.value == 1){
      inShop = true;
      StopEffects = true
    } else {
      inShop = false
      effects.length = 0;
      StopEffects = false;
    }
  };

  function playingGame1(){
    if(playingMeter1.value > 0.8){
      play1 = true
    } else {
      play1 = false;
    }
  };
  
  function playingGame2() {
    if (playingMeter2.value > 0.8) {
      play2 = true
    } else {
      play2 = false;
    }
  };

  function DrawBackground(color) {
    ctx.fillStyle = color;
    ctx.fillRect(0, 0, c.width, c.height)
  };

  function turretEffects(){
    console.log('IN TURRET')
    if(alliedTurretMeter.value == 1 && !turretAnim){
      turretAnim = true;
      effects.push(new fallingTurret("blue"));
    } else if(enemyTurretMeter.value == 1 && !turretAnim){
      turretAnim = true;
      effects.push(new fallingTurret("red"));
    }
  };

  function loadGoing(){
    return 1;
  };

  // END CALLBACKS -----------------------------------------------------------------------------------
  // ASHE --------------------------------------------------------------------------------
    function asheQ(){
      this.start = GetTime();
      this.prevArrows = GetTime();
      this.lifetime;
      this.cubes = [];

      effects.push(new RippleEffect(160, 100, 10, 1000, 30, "blue", "in", "Stroke", 1))
      
      this.draw = function(){
        this.lifetime = 3000 -(GetTime() - this.start)
        if(  GetTime() - this.prevArrows > 800){
          for (let index = 0; index < 4; index++) {
            this.cubes.push(new RandomCube(20, 60, "hsl(184, 100%, 50%)", "up", 5,true ,200 + (index *50), 100 +(30*index)))
          }
          this.prevArrows = GetTime();
        }
        this.cubes.forEach(cube => {
          cube.draw();
        });
      }
    };

    function asheW (){
      this.start = GetTime();
      this.state = 0;
      this.lifetime = 2000;
      this.background = new SmoothBackgroundToBlack(12);
      this.explosion = new ParticleExplosion(160, 200, "hsl(184, 100%, 50%)", 6, 1000, 8, 7, 1.5, true);
      
      freezeBackground = true;
          
      this.Process = function () {
        if (this.lifetime <= 0) {
          stateMgr.Pop();
          freezeBackground = false;
        }
        this.draw();
      }
          
      this.draw = function () {
        this.lifetime = 2500 - (GetTime() - this.start)
        if (this.state == 0) {
          this.background.draw();
          if (this.background.y >= 0) {
            this.state = 1;
          }
        } else {
          DrawBackground("hsla(0,0%,0%, 0.07)")
          this.explosion.draw()
        }
      }
    };

    function asheR(){
      this.start = GetTime();
      this.state = 0;
      this.lifetime = 3500;
      this.background = new SmoothBackgroundToBlack(20);
      this.cube = new RandomCube(100, 30, "hsl(184, 100%, 50%)", "right", 5.5,false ,85);
      this.bloodRain =  new BloodRain("hsl(184, 100%, 50%)", 8)
      freezeBackground = true;
            
      this.Process = function (){
        if(this.lifetime <= 0){
          stateMgr.Pop();
        }
        this.draw()
      }

      this.draw = function (){
        this.lifetime = 4500 - (GetTime() - this.start);
        if(this.state == 0){
          this.background.draw();
          if (this.background.y >= 0) {
            this.state = 1;
          }
        } else if (this.state == 1){
          DrawBackground("black");
          this.cube.draw();
          this.cubex = this.cube.x + this.cube.width;
          DrawTriangle(this.cubex, 60, this.cubex+ 80, 100, this.cubex, 140, "hsl(184, 100%, 50%)")
          if(this.cubex -100> 320){
            this.state =2;
          }
        } else if (this.state ==2){
          DrawBackground("hsla(0,0%,0%, 0.1)");
          this.bloodRain.Process()
        }
      }
    };
  // END ASHE ------------------------------------------------------------------------
  // MISS FORTUNE -------------------------------------------------------------
  function FortuneQ(){
        this.start = GetTime();
        this.lifetime = 2000;
        this.state = 0;
        this.cube = new RandomCube(30,30, "orange", "right", 5, 100)
        this.explosion = new ParticleExplosion(160,100, "orange", 10,1000,200, 7, 1.5, false);

        this.draw = function () {
          this.lifetime = 3000 -(GetTime() - this.start)
          if(this.state == 0){
            this.cube.draw();
            if(this.cube.x >= 160){
              this.state =1
            }
          } else if(this.state == 1){
            this.explosion.draw()
            
            this.explosion.particles.forEach((particle, index) => {
              if(particle.x <= 160){
                this.explosion.particles.splice(index,1)
              }
            });
          }
        }
      }

      function FortuneE() {
          this.start = GetTime();
          this.lifetime = 3000;
          this.state = 0;
          this.cubes = [];
          
          this.draw = function () {
          this.lifetime = 3000 - (GetTime() - this.start)
          for (let index = 0; index < 40; index++) {
            DrawCube(Math.random() * 320, Math.random() *160, Math.random() * 20 + 5, Math.random() * 20 + 5, `hsl(10,${Math.random() * 70 + 30}%, ${Math.random() * 70 + 30}%)`)
          }
          }
        }

        function FortuneR() {
            this.start = GetTime();
            this.state = 0;
            this.lifetime = 3000;
            this.background = new SmoothBackgroundToBlack();
            this.explosion = new ParticleExplosion(160, 200, "orange", 10, 1000, 150, 7, 1.5, true);
            this.col = 25;
            freezeBackground = true;

            this.Process = function(){
            if(this.lifetime <= 0){
              stateMgr.Pop();
              freezeBackground = false;
            } 
            this.draw();
            }
            this.draw = function () {
               this.lifetime = 3500 - (GetTime() - this.start)
              if(this.state == 0){
                this.background.draw();
                if(this.background.y >= 0){
                  this.state = 1;
                }
              } else {
                DrawBackground("hsla(0,0%,0%, 0.1)")
                this.explosion.draw()
               if( this.explosion.particles[0].y <= 0){
                this.explosion = new ParticleExplosion(160, 200, `hsl(${this.col},100%, 50%)`, 10, 1000, 150, 7, 1.5, true);
                this.col -=10;
                }
              }
            }
          }
  // END MISS FORTUNE ---------------------------------------------------------
  // TEEMO --------------------------------------------------------------------
  function TeemoQ(){
        this.state = 0;
        this.background = new SmoothBackgroundToBlack();
        this.cube = new RandomCube(40,20,"purple", "right", 5.3, 100)
        this.ripple = new RippleEffect(320, 100, 8, 1500, 30, "purple", "out", "stroke", 3, true)
        this.start = GetTime();
       
        freezeBackground = true;
        StopEffects = true;
        this.Process = function () {
          this.Draw();
        };
        this.Draw = function () {
          if(this.state ==0){
            this.background.draw();
             if (this.background.y >= 0) {
              this.state = 1;
            }
          } else if (this.state == 1){
            DrawBackground("black");
            this.cube.draw()
            if(this.cube.x >= 280){
              this.state = 2;
            }
          } else {
            DrawBackground("black");
            this.ripple.draw()
            if(this.ripple.radius >=500){
              StopEffects = false
              freezeBackground = false;
              stateMgr.Pop();
            }
          }
      }
    }

    function TeemoR() {
      this.state = 0;
      this.background = new SmoothBackgroundToBlack();
      this.y = -50;
      this.explosion = new ParticleExplosion(160, 100, "purple", 7, 1000, 150, 20, 1);

      freezeBackground = true;
      StopEffects = true;
       this.Process = function () {
        this.Draw();
      };

      this.Draw = function () {
        if (this.state == 0) {
          this.background.draw();
          if (this.background.y >= 0) {
            this.state = 1;
          }
        } else if (this.state == 1) {
          DrawBackground("black");
          puffcap(this.y);
          if(this.y <= 100){
            this.y += 5;
          } else {
            this.state = 2;
          }
        } else if(this.state ==2) {
          DrawBackground("black");
          this.explosion.draw();
           if (this.start == null) {
            this.start = GetTime();
            StopEffects = false
          }
          if (GetTime() - this.start > 2000) {
            stateMgr.Pop();
            freezeBackground = false;
            effects.length = 0;
          }
        }
      }
    }

    function TeemoW(){
      this.lifetime = 1000;
      this.bars = [];
      this.y = 300;
      this.draw = function () {
        ctx.fillStyle = "blue"; 
        for (let i= 0; i < 2; i++) {
          ctx.beginPath();
          ctx.moveTo(160, this.y + 200 * i - 150);
          ctx.lineTo(320, this.y + 200 * i);
          ctx.lineTo(320, this.y + 200 * i + 100);
          ctx.lineTo(160, this.y + 200 * i - 100);
          ctx.lineTo(0, this.y + 200 * i + 100);
          ctx.lineTo(0, this.y + 200 * i);
          ctx.lineTo(160, this.y + 200 * i - 150);
          ctx.fill();
          
        }
      
        this.y -= 10;
        if(this.y< -200){
          this.lifetime = 0;
        }
      }
    }

    function puffcap(y) {
        DrawCircle(160,y,40,"green");
        DrawCircle(175, y-20, 10, "purple");
        DrawCircle(175, y +10, 8, "purple");
        DrawCircle(145, y +20, 15, "purple");
      }
  // END TEEMO ---------------------------------------------------------------
  // YONE --------------------------------------------------------------------
  function ExtendedEYoneEffect(){
      this.lifetime = 1000;
      this.draw = function (){
        DrawBackground("hsla(238, 100%, 5%, 0.8)");
        if(!ActiveExtendedE){
          this.lifetime = 0;
          effects.push(new RippleEffect(160,100,5,2500, 30, "red", "out", "stroke", "3"))
        }
      }
    }

    function YoneWeffect() {
        this.start = GetTime();
        this.lifetime;
        freezeBackground = true;
        var bar1 = new BarEffect("left", "red", 15, 1000, 1500, 1);
        var bar2 = new BarEffect("left", "black", 15, 1000, 1500, 1);
        this.Process = function(){
          if(this.lifetime <= 0){
            freezeBackground = false;
            stateMgr.Pop();
          }
          this.draw()
        }
        this.draw = function () {
          copyScreen();
          this.lifetime = 1000 - (GetTime() - this.start)
          if (this.lifetime > 900) {
            bar1.draw();
          } else if (this.lifetime >0){
            bar1.draw();
            bar2.draw();
          }
        }
      }

      function YoneQeffect(color) {
      this.start = GetTime();
      this.lifetime;
      this.x = -320;
      this.y = 200;
      this.col = color;
      this.sat = 0;
      this.draw = function(){
        this.lifetime = 2000 - (GetTime() -this.start)
        ctx.beginPath();
        ctx.moveTo(0 + this.x, 180 + this.y);
        ctx.lineTo(160 + this.x, 80 + this.y)
        ctx.lineTo(320 + this.x,0 + this.y)
        ctx.lineTo(180 + this.x,120 + this.y)
        ctx.lineTo(40 + this.x,220 + this.y)
        ctx.fillStyle = this.col;
        ctx.fill();
        if(this.x <0){
          this.x += 15;
          this.y -= 9.375
          this.state = 1;
        } else if(this.state == 1) {
          
          // effects.push(new RippleEffect(320,0,7,1500,30, "red", "out", "stroke", 3))
          this.state =2;
        } else if(this.state == 2){
          this.col =  `hsla(0, ${this.sat}%, 50%)`
          this.sat+=3;
        }
      } 
    }

    function ExtendedQYoneEffect() {
        this.lifetime = 1000;
        this.bars = [];
        this.draw = function () {
          while (this.bars.length < 20){
            this.bars.push(new RandomCube(30, 20, "blue", "left", 3))
            this.bars.push(new RandomCube(30, 20, "blue", "right", 3))
          }

          this.bars.forEach(bar => {
            bar.draw();
          });
          this.bars.shift();
        
          if (!ActiveExtendedQ) {
            this.lifetime = 0;
            effects.push(new YoneQeffect("blue"))
          }
        }
      }

      function RYoneEffect(){
        this.start = GetTime();
        this.lifetime = 1000;
        this.x = -120;
        StopEffects = true;
        freezeBackground = true;
        this.Process = function(){
          if(this.lifetime <=0){
            stateMgr.Pop();
            stateMgr.Push(new BloodRain("red", 5));
          }
          this.draw()
        }
        this.draw = function(){
          if(this.lifetime > 200){
           DrawArrow("red", this.x);
           DrawArrow("black", this.x-30);
           this.x += 10;
          }
          this.lifetime = 1200 - (GetTime() - this.start);
        }
      }

    //END YONE -----------------------------------------------------------------------------
    // START EFFECT/HELPER FUNCTIONS --------------------------------------------------------------------
  
    function DrawCube(x,y,width, height, color){
      ctx.beginPath();
      ctx.fillStyle = color;
      ctx.fillRect(x,y,width,height)
    };

    function DrawCircle(x,y,radius,color){
        ctx.beginPath();
        ctx.fillStyle = color;
        ctx.arc(x,y,radius, 0, 2* Math.PI)
        ctx.fill();
    };

    function DrawTriangle(cord1X,cord1Y,cord2X,cord2Y,cord3X,cord3Y, color) {
      ctx.beginPath();
      ctx.fillStyle = color;
      ctx.moveTo(cord1X, cord1Y);
      ctx.lineTo(cord2X,cord2Y);
      ctx.lineTo(cord3X,cord3Y);
      ctx.lineTo(cord1X,cord1Y);
      ctx.fill();
    };

    function DrawArrow(color, x){
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.moveTo(0 + x, 0);
      ctx.lineTo(60 + x, 0);
      ctx.lineTo(120 + x, 100);
      ctx.lineTo(60 + x, 200);
      ctx.lineTo(0 + x, 200);
      ctx.lineTo(60 + x, 100)
      ctx.lineTo(0 + x, 0)
      ctx.fill();
    };

    function ArrowEffect(direction, color, amount, speed, duration) {
            this.start = GetTime();
            this.speed = speed;
            this.duration = duration;
            this.lifetime = this.duration;
            this.direction = direction;
            this.color = color;
            this.amount = amount;
            this.draw = function () {
              if (this.direction == 'up') {
                this.speed = -this.speed;
                ctx.fillStyle = this.color;
                for (let i = 0; i < this.amount; i++) {
                  ctx.beginPath();
                  ctx.moveTo(160, this.lifetime / 1.5 - 150 - (200 * i));
                  ctx.lineTo(320, this.lifetime / 1.5 - (200 * i));
                  ctx.lineTo(320, this.lifetime / 1.5 - (200 * i) + 100);
                  ctx.lineTo(160, this.lifetime / 1.5 - (200 * i) - 100);
                  ctx.lineTo(0, this.lifetime / 1.5 - (200 * i) + 100);
                  ctx.lineTo(0, this.lifetime / 1.5 - (200 * i));
                  ctx.lineTo(160, this.lifetime / 1.5 - (200 * i) - 150);
                  ctx.fill();
                }
              } else {
                ctx.fillStyle = this.color;
                for (let i = 0; i < this.amount; i++) {
                  ctx.beginPath();
                  ctx.moveTo(160, 300 - this.lifetime / 1.5 + (200 * i));
                  ctx.lineTo(320, 240 - this.lifetime / 1.5 + (200 * i));
                  ctx.lineTo(320, 180 - this.lifetime / 1.5 + (200 * i));
                  ctx.lineTo(160, 240 - this.lifetime / 1.5 + (200 * i));
                  ctx.lineTo(0, 180 - this.lifetime / 1.5 + (200 * i));
                  ctx.lineTo(0, 240 - this.lifetime / 1.5 + (200 * i));
                  ctx.lineTo(160, 300 - this.lifetime / 1.5 + (200 * i));
                  ctx.fill();
                }
              }
              this.Ymin += this.speed;
              this.elapsed = new Date().getTime() - this.start;
              this.lifetime = this.duration - this.elapsed;
              if (this.lifetime <= 0) {
                speedAnim = false
              }
            }
          }

  function ballPhysics(x, y, radius, color){
    this.radius = radius;
    this.color = color;
    this.x = x;
    this.vx = 7 * Math.sin(radius);
    this.y = y;
    this.vy = -20;
    this.ay = 1;
    this.lifetime = 10;
    this.draw = function(){
      ctx.beginPath();
      ctx.fillStyle = this.color;
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
      ctx.fill();
      this.x += this.vx;
      this.y += this.vy;
      this.vy += this.ay;
      if(this.y > height){
        this.lifetime = 0;
      }
    }
  };

  function fallingTurret(color){
    this.lifetime = 10;
    this.angle = 0;
    this.change = 0;
    this.elapsed = 0;
    this.color = color;
    this.draw = function(){
      ctx.save();
      ctx.fillStyle = this.color;
      ctx.translate(75, 200);
      ctx.rotate(this.angle * Math.PI/180);
      ctx.translate(-75, -200);
      ctx.fillRect(0, -100, 75, 300);
      ctx.fillRect(-30, -40, 135, 140);
      ctx.restore();
      
      if(this.elapsed > 50){
        this.lifetime = 0;
        turretAnim = false;
      } else if(this.angle >= 90){
        this.angle = 90;
        this.elapsed++;
        if(this.elapsed < 5){
            effects.push(new RippleEffect(200, 200, 20, 200, 20, this.color, "out", "stroke", 1, false));
        }
      } else {
        this.angle += this.change;
        this.change += .05;
      }
    }
  };

  function deathEffect(){
    this.y = 350;
    this.lifetime = 10;
    for (let i = 0; i < 10; i++){
      effects.push(new ballPhysics(160, 200, Math.random()* 10 + 15, "red"))
      setTimeout(()=>{effects.push(new ballPhysics(160, 200, Math.random()* 10 + 15, "red"));}, 150);
      setTimeout(()=>{effects.push(new ballPhysics(160, 200, Math.random()* 10 + 15, "red"));}, 300);
      setTimeout(()=>{effects.push(new ballPhysics(160, 200, Math.random()* 10 + 15, "red"));}, 450);
    }
    
    this.draw = function(){
      ctx.fillStyle = "black";
      ctx.fillRect(0, 0, 320, 200);

      ctx.fillStyle = "white";
      ctx.fillRect(60, this.y, 200, 150);

      DrawCircle(160, this.y, 100, "white");
      DrawCircle(120, this.y - 10, 25, "black");
      DrawCircle(200, this.y - 10, 25, "black");
      DrawCircle(160, this.y + 80, 50, "black");
      DrawCircle(160, this.y + 110, 55, "white");

      this.y -= 6;
      if (this.y <= -200){
        this.lifetime = 0;
        deathAnim = false;
      }
    }
  };

  function DrawBackground(color) {
      ctx.fillStyle = color;
      ctx.fillRect(0, 0, c.width, c.height)
  };


  function ParticleExplosion(x, y, color, speed, duration, particleAmount, particleSize, fadeSpeed, notrandomY) {
    this.start = GetTime();
    this.col = color;
    this.speed = speed;
    this.duration = duration;
    this.lifetime = 2000;
    this.amount = particleAmount;
    this.size = particleSize
    this.x = x;
    this.y = y;
    this.fadeSpeed = fadeSpeed;
    this.particles = [];
   
    while (this.particles.length < this.amount) {
       if (notrandomY) {
        this.yspeed = -this.speed/1.5;
      } else {
        this.yspeed = ((Math.random() - 0.5) * this.speed);
      }
      this.particles.push(new ExplosionParticle(this.x, this.y, this.size, this.col, this.fadeSpeed,
        {
          x: ((Math.random() - 0.5) * this.speed),
          y: this.yspeed
        }))
      this.draw = function () {
        this.lifetime = this.duration - (GetTime() - this.start)
        this.particles.forEach((Particle, index) => {
          Particle.draw()
        })
      }
    }
  };

  class RandomCube{
    constructor(width, height, color, moveDir, speed,randomSpeed, startY, startX){
      this.width = width
      this.height = height;
      this.col = color;
      this.moveDir = moveDir;
      this.y = startY;
      this.x = startX;
      this.randomSpeed = randomSpeed;
      this.speed;
      if(this.randomSpeed == null || this.randomSpeed == true){
        this.speed =speed * (Math.random() * 2) + speed;
      } else{
        this.speed = speed;
      }
      if(this.moveDir == "left" || this.moveDir == "right"){
        if(this.y == null){
          this.y = Math.random() * 200;
        }
        if (this.x == null) {
          this.x = Math.random() * 200;
        }
        if(this.moveDir == "left"){
          this.speed = -this.speed;
          this.x = 320;
        } else if (this.moveDir == "right") {
          this.x = 0 - this.width;
        }
      } else {
        if (this.moveDir == "up") {
          this.speed = -this.speed;
          this.y = 200;
        } else if(this.moveDir == "down") {
          this.y = 0;
        }
      }
    }
    draw(){
      ctx.fillStyle = this.col; 
      ctx.fillRect(this.x, this.y, this.width, this.height);
      if(this.moveDir == "left" || this.moveDir == "right"){
        this.x += this.speed;
      } else {
        this.y += this.speed;
      }
    }
  };

  class ExplosionParticle {
      constructor(x, y, radius, color, fadeSpeed, velocity) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.radius = radius;
        this.velocity = velocity;
        this.alpha = 1 * fadeSpeed;
      }
      draw() {
        ctx.globalAlpha = this.alpha;
        ctx.beginPath()
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false)
        ctx.fillStyle = this.color
        ctx.fill()
        this.x += this.velocity.x
        this.y += this.velocity.y
        this.alpha -= 0.01
      }
    }

  function goldEffect(){
    this.x = 160;
    this.y = 100;
    this.radiusX = 50;
    this.lifetime = 10;

    this.draw = function(){
      this.x = Math.sin(Date.now() / 1000) * 160 + 160;
      ctx.beginPath();
      ctx.fillStyle = "gold";
      if(this.radiusX < 11){
        ctx.fillStyle = "white";
      }
      ctx.ellipse(this.x, this.y, this.radiusX, 50, 0, 0, 2 * Math.PI);
      ctx.fill();
      this.radiusX = Math.sin(Date.now() / 100) * 20 + 30;
      if((engine.vision.gold < goldLimit && engine.vision.gold != -1) || (!play1 || !play2)){
        this.lifetime = 0;
        goldAnimPushed = false;
      }
    }
  };

  function SmoothBackgroundToBlack(){
    this.y = -200;

    this.draw = function(){
      ctx.beginPath();
      ctx.fillStyle = "black"
      ctx.fillRect(0, this.y, 320, 200)
      this.y += 5;
    }
  };

  function BloodRain (color, radius){
        this.start = GetTime();
        this.elapsed = 0;
        this.bloodDrip = [];
        this.state = 0;
        this.cubeX = 1;
        this.cubeY = 1;
        this.color = color;
        this.radius = radius;

        this.Process = function () {
          if (this.bloodDrip.length < 20) {
            this.bloodDrip.push(new blood(Math.random() * c.width, 0, this.radius, this.color))
          }
          this.elapsed = GetTime() - this.start;
          if (this.elapsed >= 4000) {
            stateMgr.Pop();
            effects.length = 0;
            freezeBackground = false;
            StopEffects = false;
          }
          this.Draw();
        };
        this.Draw = function () {
          ctx.lineWidth = 1;
            this.bloodDrip.forEach(blood => {
            blood.Draw();
            }
          );
        }
      }

      function BarEffect(direction, color, speed, duration, barWidth, amountOfBars) {
          this.dir = direction;
          this.col = color;
          this.dur = duration;
          this.start = GetTime();
          this.lifetime;
          this.x = 0;
          this.y = 0;
          this.bW = barWidth;
          this.speed = speed;
          this.amount = amountOfBars;
          switch (this.dir) {
            case "up":
              this.y = c.height;
              this.speed = -this.speed;
              break;
            case "right":
              this.x -= this.bW;
              break;
            case "down":
              this.y -= this.bW;
              break;
            case "left":
              this.x = c.width + (this.bW*this.amount) - this.bW;
              this.speed = -this.speed;
              break;
          }
          this.draw = function () {
            ctx.fillStyle = this.col;
            for (let i = 0; i < this.amount; i++) {
              if (this.dir == "up" || this.dir == "down") {
                ctx.fillRect(this.x, this.y - ((this.bW * 2) * i), c.width, this.bW);
                this.y += this.speed / this.amount;
              } else {
                ctx.fillRect(this.x - ((this.bW * 2) * i), this.y, this.bW, c.height);
                this.x += this.speed / this.amount;
              }
            }
            this.lifetime = this.dur - (GetTime() - this.start);
          }
        }

    function RippleEffect(x, y, speed, duration, rippleWidth, color, inOrOut, fillOrStroke, amountOfRipples, background) {
        this.col = color;
        this.speed = speed;
        this.dur = duration;
        this.width = rippleWidth;
        this.start = GetTime();
        this.lifetime;
        this.x = x;
        this.y = y;
        this.fill = fillOrStroke;
        this.radius = 0;
        this.amount = amountOfRipples;
        this.background = background;
        if (inOrOut == "in") {
          this.radius = 200 + (this.width * (this.amount * 2));
          this.speed = -this.speed
        }
        this.draw = function () {
          if(this.background){
            DrawBackground("black");
          }
          
          
          ctx.lineWidth = this.width;
          ctx.beginPath();
          for (let i = 0; i < this.amount; i++) {
            if (this.radius - i * (this.width * 2) > 0) {
              ctx.arc(this.x, this.y, this.radius - i * (this.width * 2), 0, 2 * Math.PI);
            }
          }
          if (this.fill == "fill") {
            ctx.fillStyle = this.col;
            ctx.fill();
          } else {
            ctx.strokeStyle = this.col;
            ctx.stroke();
          }
          this.radius += this.speed;
          this.lifetime = this.dur - (GetTime() - this.start);
          if (this.lifetime <= 0){
            utilityPlayed = false;
          }
        }
      }

      class blood {
      constructor(x, y, radius, color) {
        this.x = x;
        this.y = y;
        this.radius = radius;
        this.color = color;
        this.speed = (Math.random() + 0.1) * 4
      }
      Draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI)
        ctx.strokeStyle = this.color;
        ctx.stroke();
        this.y += this.speed * Math.random();
        this.x += (Math.random() - 0.5) * 8;
      }
    }

    function GetTime() {
      return new Date().getTime()
    }

  function copyScreen() {
    let lightness = new Int8Array(engine.zone.lightness);
    let sat = new Int8Array(engine.zone.saturation);
    let hue = new Int16Array(engine.zone.hue);

    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, c.width, c.height);
    for (var iZone = 0; iZone < 560; iZone++) {
        ctx.fillStyle =
          "hsla(" +
          hue[iZone] +
          "," +
          sat[iZone] +
          "%," +
          lightness[iZone] +
          "%, " +
          keyScreenBrightness * 0.01 +
          ")";
      
      var iRow = Math.floor(iZone / 28);
      var iCol = iZone % 28;
      var iWidth = 320 / 28;
      var iHeight = 200 / 20;
      var iZx = iCol * iWidth;
      var iZy = iRow * iHeight;

      ctx.fillRect(iZx, iZy, iWidth, iHeight);
    }
  }

  
  function StateHandler() {
    var stack = [];
    var state = null;

    var updateState = function () {
      if (stack.length > 0) {
        state = stack[stack.length - 1];
      } else {
        state = null;
      }
    };

    this.Push = function (newState) {
        stack.push(newState);
        updateState();
      }

    this.Pop = function () {
      stack.pop();
      updateState();
    };

    this.Process = function () {
      if (state != null) {
        state.Process();
      }
    };
  }

  function Meter(count, callback) {
    this.size = count;
    this.value = 0;
    this.diff = 0;
    this.increased = false;
    this.decreased = false;
    var values = [];

    this.setValue = function (updatedValue) {
      // Add and shift.
      if (updatedValue == -1) return;
      values.push(updatedValue);

      if (values.length > this.size) {
        values.shift();
      }

      // Exit early if we've got a long-term match.
      for (var i = 0; i < values.length - 1; i++) {
        if (values[i] !== values[i + 1]) return;
      }

      // We got here, so we've got a matching value collection.
      if (this.value !== values[0]) {
        this.diff = Math.abs(this.value - values[0]);
        this.increased = this.value < values[0];
        this.decreased = this.value > values[0];
        this.value = values[0];
        callback();
      }
    };
  }

  function onEngineReady() {
    // Grab canvas and rendering context.
    c = document.getElementById("exCanvas");
    ctx = c.getContext("2d");

    // Start updates *after* our engine is accessible and ready.
    window.requestAnimationFrame(update);
  }
</script>

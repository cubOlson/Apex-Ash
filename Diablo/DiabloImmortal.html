<head>
  <title>Diablo immortal</title>
  <meta description="Crush everything with this integration" />
  <meta publisher="SignalRGB" />

  <meta property="keyScreenBrightness" label="Ambience brightness" type="number" min="0" max="100" default="100" />
  <meta property="adjToggle" label="Adjustment Toggle (turn off in-game)" type="boolean" default="0" />
  <meta property="RotateBar" label="RotateBars" type="boolean" default="0" />
  <meta property="healthColor" label="Health Bar Color" type="color" default="#12ff00" min="0" max="360" />
  <meta property="HealthBarX" label="HealthBarX" type="number" min="0" max="320" default="0" />
  <meta property="HealthBarY" label="HealthBarY" type="number" min="0" max="200" default="50" />
  <meta property="HealthBarWidth" label="HealthBarWidth" type="number" min="0" max="320" default="320" />
  <meta property="HealthBarHeight" label="HealthBarHeight" type="number" min="0" max="200" default="30" />
  <meta property="hudToggle" label="enable HUD effects" type="boolean" default="1" />

  <meta meter="health" tags="VLC, Diablo" type="area" x="0.0090" y="0.1167" width="0.0864" height="0.0174" h="0-360"
    s="50-100" l="25-75">
  </meta>

  <meta meter="inGame" tags="VLC,Diablo" type="area" x="0.9754" y="0.0419" width="0.00152" height="0.0021" h="20-50"
    s="25-66" l="45-70">
  </meta>

  <meta meter="inMenu" tags="VLC,Diablo" type="area" x="0.9754" y="0.0419" width="0.00152" height="0.0021" h="0-40"
    s="50-90" l="30-50">
  </meta>

  <meta meter="levelUpConfirmation" tags="VLC,Diablo" type="area" x="0.5855" y="0.1250" width="0.0027" height="0.00001"
    h="30-60" s="50-70" l="80-100">
    <resolution size="1920x1080" x="0.5813" y="0.1417" width="0.0027" height="0.00001" />
  </meta>

  <meta meter="levelUpR" tags="VLC,Diablo" type="area" x="0.5137" y="0.1250" width="0.0016" height="0.0000" h="30-60"
    s="50-70" l="80-100">
    <resolution size="1920x1080" x="0.5130" y="0.1296" width="0.001" height="0.0001" />
  </meta>

  <meta meter="speakingBlack" tags="VLC,Diablo" type="area" x="0.4086" y="0.6792" width="0.0969" height="0.00001"
    h="0-360" s="50-100" l="0-20">
  </meta>

  <meta meter="speakingYellow" tags="VLC,Diablo" type="area" x="0.4355" y="0.7021" width="0.0063" height="0.0007"
    h="30-60" s="10-30" l="60-80">
  </meta>

  <meta meter="ultReady" tags="VLC,Diablo" type="area" x="0.9402" y="0.7979" width="0.0001" height="0.0001" h="0-360"
    s="70-100" l="80-100">
  </meta>

  <meta meter="ultHSL" tags="VLC,Diablo" type="colormean" x="0.9402" y="0.7979" width="0.0001" height="0.0001" h="0-360"
    s="30-100" l="30-100">
  </meta>

  <meta meter="ultConfirm" tags="VLC,Diablo" type="colormean" x="0.8285" y="0.8181" width="0.0098" height="0.0097" h="0-360"
    s="30-100" l="30-100">
  </meta>

  <meta meter="diedYellowD" tags="VLC,Diablo" type="area" x="0.5121" y="0.2833" width="0.0051" height="0.0007" h="20-60"
    s="20-60" l="70-100">
  </meta>

  <meta meter="diedYellowE" tags="VLC,Diablo" type="area" x="0.5449" y="0.2833" width="0.0059" height="0.0014" h="20-60"
    s="20-60" l="70-100">
  </meta>

  <meta meter="diedRed" tags="VLC,Diablo" type="area" x="0.4141" y="0.2868" width="0.0051" height="0.0014" h="0-40"
    s="50-90" l="50-70">
  </meta>

  <meta meter="SafeZoneGreenF" tags="VLC,Diablo" type="area" x="0.4770" y="0.1854" width="0.0031" height="0.0007"
    h="118-138" s="30-80" l="70-100">
  </meta>

  <meta meter="SafeZoneGreenZ" tags="VLC,Diablo" type="area" x="0.5039" y="0.1854" width="0.0039" height="0.0000"
    h="118-138" s="30-80" l="70-100">
  </meta>

  <meta meter="KillStreakRed" tags="VLC,Diablo" type="area" x="0.4895" y="0.6521" width="0.0008" height="0.0083" h="0-10" s="75-100" l="75-100">
  </meta>

  <meta meter="KillStreakGreen" tags="VLC,Diablo" type="area" x="0.5879" y="0.7243" width="0.0258" height="0.0069" h="110-150" s="60-100" l="50-100">
  </meta>


<body style=" margin: 0; padding: 0; background: #000;">
  <canvas id="exCanvas" width="320" height="200"></canvas>
</body>

<script>
  //Declaring variables
  var canvas, ctx;
  var stateMgr = new StateHandler();
  var effects = [];

  var isInGame = false;
  var isInMenu = false;
  var speaking = false;
  var isFighting = false;
  var lowHpPlaying = false;
  var killStreakGoing = false;
  var safeZonePlaying = false;
  var ultPlayed = false;


  var healthMeter = new Meter(5, lowHp)
  var ingameMeter = new Meter(10, inGame)
  var inMenuMeter = new Meter(5, inMenu)
  var levelUpConfirmationMeter = new Meter(5, levelUpChanged)
  var levelUpRMeter = new Meter(5, levelUpChanged)
  var speakingblackMeter = new Meter(5, speakingChanged)
  var speakingyellowMeter = new Meter(5, speakingChanged)
  var ultReadyMeter = new Meter(10, ()=>"")
  var ultHueMeter = new Meter(2, ()=>"")
  var ultConfirmMeter = new Meter(15, ultReadyChanged)
  var diedyellowDMeter = new Meter(5, deathChanged)
  var diedYellowEMeter = new Meter(5, deathChanged)
  var diedRedMeter = new Meter(5, deathChanged)
  var SafeZoneGreenFMeter = new Meter(5, safeZoneChanged)
  var SafeZoneGreenZMeter = new Meter(5, safeZoneChanged)
  var KillStreakRedMeter = new Meter(5, killStreakChanged)
  var KillStreakGreenMeter = new Meter(5, killStreakChanged)
  //Declaring meters

  function update() {
    //Updating meters
    IdleState();

    ingameMeter.setValue(engine.vision.inGame)
    inMenuMeter.setValue(engine.vision.inMenu)
    healthMeter.setValue(engine.vision.health)
    speakingblackMeter.setValue(engine.vision.speakingBlack)
    speakingyellowMeter.setValue(engine.vision.speakingYellow)
    diedyellowDMeter.setValue(engine.vision.diedYellowD)
    diedYellowEMeter.setValue(engine.vision.diedYellowE)
    diedRedMeter.setValue(engine.vision.diedRed)

    if(isInGame && !isInMenu){
      levelUpConfirmationMeter.setValue(engine.vision.levelUpConfirmation)
      levelUpRMeter.setValue(engine.vision.levelUpR)
      ultReadyMeter.setValue(engine.vision.ultReady)
      ultHueMeter.setValue(engine.vision.ultHSL[0])
      ultConfirmMeter.setValue(engine.vision.ultConfirm[0])
      SafeZoneGreenFMeter.setValue(engine.vision.SafeZoneGreenF)
      SafeZoneGreenZMeter.setValue(engine.vision.SafeZoneGreenZ)
      KillStreakRedMeter.setValue(engine.vision.KillStreakRed)
      KillStreakGreenMeter.setValue(engine.vision.KillStreakGreen)
    }

    DrawHUD();

    //Effect handler 
    for (let i = 0; i < effects.length; i++) {
      effects[i].draw();
      if (effects[i].lifetime <= 0) {
        effects.splice(i, 1);
      }
    }
    stateMgr.Process();

    window.requestAnimationFrame(update);
  }


  function DrawHUD() {

    if (isInGame && !safeZonePlaying) {
      ctx.beginPath()
      ctx.save()
      ctx.translate(HealthBarX, RotateBar ? 200 : HealthBarY)

      if (RotateBar) {
        ctx.rotate(-90 / 180 * Math.PI)
      }

      ctx.fillStyle = healthColor;
      ctx.fillRect(0, 0, healthMeter.value * SetRange(HealthBarWidth, 0, RotateBar ? 200 : 320), HealthBarHeight)
      ctx.restore();

    } else if (adjToggle) {

      ctx.beginPath()
      ctx.save()
      ctx.translate(HealthBarX, RotateBar ? 200 : HealthBarY)

      if (RotateBar) {
        ctx.rotate(-90 / 180 * Math.PI)
      }
      ctx.fillStyle = healthColor;
      ctx.fillRect(0, 0, SetRange(HealthBarWidth, 0, RotateBar ? 200 : 320), HealthBarHeight)
      ctx.restore()
    }
  }

  function SetRange(num, min, max) {
    return Math.min(Math.max(num, min), max)
  }


  function lowHp() {
    inGame();
    if (healthMeter.value == 1 && !isInGame && !isInMenu && !lowHpPlaying) {
      lowHpPlaying = true;
      effects.push(new lowHpEffect())
    }
  }

  function SetRange(num, min, max) {
    return Math.min(Math.max(num, min), max)
  }

  function inGame() {
    if (ingameMeter.value == 1 && healthMeter.value > 0) {
      isInGame = true;
    } else {
      isInGame = false;
    }
  }

  function inMenu() {
    if (inMenuMeter.value == 1) {
      isInMenu = true;
    } else {
      isInMenu = false;
    }
  }

  function levelUpChanged() {
    if (levelUpConfirmationMeter.value == 1 && levelUpRMeter.value == 1 && isInGame) {
      effects.push(new levelUpEffect())
    }
  }

  function speakingChanged() {
    if (speakingblackMeter.value >= 0.9 && speakingyellowMeter.value == 1) {
      if (!speaking) {
        effects.push(new speakingEffect())
        speaking = true;
      }
    } else if (speakingblackMeter.value == 0 && speakingyellowMeter.value == 0 && speaking) {
      speaking = false;
    }
  }

  function ultReadyChanged() {
    if(ultReadyMeter.value < .25){
      ultPlayed = false;
    }
    if (ultReadyMeter.value == 1 && isInGame && engine.vision.health > 0 && engine.vision.inGame == 1 && ultReadyMeter.increased && !ultPlayed) {
      effects.push(new ultUpEffect())
      ultPlayed = true;
    }
  }


  function deathChanged() {
    if (diedYellowEMeter.value == 1 && diedyellowDMeter.value == 1 && diedRedMeter.value == 1) {
      effects.push(new DeathEffect())
    }
  }

  function safeZoneChanged() {
    if (SafeZoneGreenFMeter.value == 1 && SafeZoneGreenZMeter.value == 1 && isInGame && !safeZonePlaying) {
      safeZonePlaying = true;
      effects.push(new safeZoneEffect())
    }
  }

  function killStreakChanged() {
    if (KillStreakRedMeter.value == 1 && KillStreakGreenMeter.value > .25 && isInGame) {
      if (!killStreakGoing) {
        killStreakGoing = true;
        effects.push(new killStreakEffect())
      }
    } else {
      killStreakGoing = false;
    }
  }

  function ultUpEffect(){
    this.start = Date.now();
    this.lifetime = 10;
    this.effects = []
    this.radius = 1;
    this.draw = function(){
      var elapsed = Date.now() - this.start;
      this.effects.forEach((ele, i)=>{
        ele.draw()
        if(ele.lifetime <= 0){
          this.effects.splice(i, 1)
        }
      })
      if(elapsed > 500 && this.radius < 50){
        this.effects.push(new ultOrb(`hsl(${ultHueMeter.value}, 100%, 50%)`))
        DrawCircle(160, 100, this.radius, `hsl(0, 0%, ${50 + this.radius}%)`)
        DrawStroke(160, 100, this.radius, `hsl(${ultHueMeter.value}, 100%, 50%)`, this.radius / 2)
        this.radius < 50 ? this.radius++ : null;
      } else if(elapsed > 500 && this.radius >= 50){
        DrawStroke(160, 100, this.radius, `hsl(${ultHueMeter.value}, 100%, 50%)`, this.radius / 2)
        DrawStroke(160, 100, this.radius - 50, "grey", this.radius / 3)
        this.radius+=2
      } else {
        this.effects.push(new ultOrb(`hsl(${ultHueMeter.value}, 100%, 50%)`))
      }
      this.radius > 300 ? this.lifetime = 0 : null;
    }
  }

  function ultOrb(color){
    this.flip = Math.random()
    this.flip > .5 ? this.x = Math.random() > .5 ? 0 : 320 : this.x = Math.random() * 320;
    this.flip <= .5 ? this.y = Math.random() > .5 ? 0 : 200 : this.y = Math.random() * 200;
    this.vx = (160 - this.x) / 20;
    this.vy = (100 - this.y) / 20;
    this.radius = Math.random() * 10 + 5;
    this.color = color;
    this.lifetime = 10;
    this.draw = function(){
      DrawCircle(this.x, this.y, this.radius, this.color);
      this.x+=this.vx
      this.y+=this.vy
      if(Math.abs(160 - this.x) < 5 || Math.abs(100 - this.y) < 5){
        this.lifetime = 0;
      }
    }
  }

  function lowHpEffect() {
    this.start = Date.now();
    this.elapsed = 0;
    this.draw = function () {
      this.elapsed = Date.now() - this.start;
      ctx.beginPath();
      ctx.fillStyle = `hsla(0,100%,50%,0.3)`
      ctx.fillRect(0, 0, 320, 200)
      ctx.beginPath();
      let gradient = ctx.createRadialGradient(160, 100, 0, 160, 100, 200)
      this.calculateVal = -2100 * Math.floor((this.elapsed / 2100) / 1.1) + ((this.elapsed / 2100) * (2100 / 1.1));
      gradient.addColorStop(SetRange((-0 + (this.calculateVal)), 0, 1000) / 1000, "hsla(0, 0%, 0%,0)");
      gradient.addColorStop(SetRange((-200 + (this.calculateVal)), 0, 1000) / 1000, "hsla(0, 100%, 50%,1)");
      gradient.addColorStop(SetRange((-400 + (this.calculateVal)), 0, 1000) / 1000, "hsla(0, 0%, 0%,0)");
      gradient.addColorStop(SetRange((-600 + (this.calculateVal)), 0, 1000) / 1000, "hsla(0, 100%, 50%,1)");
      gradient.addColorStop(SetRange((-800 + (this.calculateVal)), 0, 1000) / 1000, "hsla(0, 0%, 0%,0)");
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, 320, 200)
      if (isInGame) {
        this.lifetime = 0;
        lowHpPlaying = false;
      }
    }
  }


  function killStreakEffect() {
    this.start = Date.now();
    this.streaks = [];
    this.pushed = false;
    this.draw = function () {
      this.elapsed = Date.now() - this.start;
      this.xMultiplier = (Math.random() - 0.5) * (SetRange(10 * this.elapsed / 30000, 0, 10));
      this.yMultiplier = (Math.random() - 0.5) * (SetRange(10 * this.elapsed / 30000, 0, 10))
      ctx.beginPath();
      ctx.globalAlpha = this.elapsed / 800;
      ctx.fillStyle = "black"
      ctx.fillRect(0, 0, 320, 200)

      for (let i = 0; i < 6; i++) {
        let counter = i % 3
        drawEye(i < 3 ? 100 : 220 + this.xMultiplier, 90 + this.yMultiplier, counter == 0 ? 1 : (i % 3 == 1 ? 0.45 : 0.15), i < 3 ? 20 : -20, counter == 0 ? "red" : (counter == 1 ? "black" : "white"))
      }
      ctx.restore();
      ctx.globalAlpha = 1;
      if (this.elapsed > 5000 && !this.pushed) {
        for (let i = 0; i < 5; i++) {
          setTimeout(() => {
            this.streaks.push(new streak());
          }, 200 * i);
        }
        this.pushed = true;
      }
      this.streaks.forEach((streakL, i) => {
        streakL.draw();
        if (streakL.y < -50) {
          this.streaks.splice(i, 1)
          this.streaks.push(new streak());
        }
      });
      if (killStreakGoing == false) {
        setTimeout(()=>{
          this.lifetime = 0;
        }, 1000)
      }
    }
  }

  function DrawCircle(x, y, radius, color) {
    ctx.beginPath();
    ctx.fillStyle = color;
    ctx.arc(x, y, radius, 0, 2 * Math.PI)
    ctx.fill();
  };

  function DrawStroke(x, y, radius, color, stroke) {
    ctx.beginPath();
    ctx.strokeStyle = color;
    ctx.lineWidth = stroke;
    ctx.arc(x, y, radius, 0, 2 * Math.PI)
    ctx.stroke();
  };

  function drawEye(x, y, size, rot, col) {
    ctx.beginPath();
    ctx.save();
    ctx.translate(x, y)
    ctx.rotate(rot * (Math.PI / 180))
    ctx.ellipse(0, 0, 50 * size, 40 * size, 0, 0, Math.PI * 1)
    ctx.fillStyle = col;
    ctx.fill();
    ctx.restore();

  }

  function levelUpEffect() {
    this.start = Date.now();
    this.pushed = false;
    this.draw = function () {
      this.elapsed = Date.now() - this.start;
      if (this.elapsed < 800) {
        ctx.beginPath();
        ctx.fillStyle = "yellow"
        ctx.fillRect(120, -250 + this.elapsed / 3, 80, 170)
        ctx.beginPath()
        ctx.moveTo(120, -80 + this.elapsed / 3)
        ctx.lineTo(200, -80 + this.elapsed / 3)
        ctx.lineTo(160, this.elapsed / 3)
        ctx.lineTo(120, -80 + this.elapsed / 3)
        ctx.fill();
      } else {
        for (let i = 0; i < 40; i++) {
          effects.push(new ImpactParticle(160, 200, Math.random() * 20 + 10, "yellow"))
          this.lifetime = 0;
        }
      }
    }
  }

  function ImpactParticle(x, y, radius, color) {
    this.radius = radius;
    this.color = color;
    this.x = x;
    this.vx = 2 * Math.sin(radius);
    this.y = y;
    this.vy = Math.random() * -10;
    this.ay = 0.2;
    this.lifetime = 10;
    this.draw = function () {
      ctx.beginPath();
      ctx.fillStyle = this.color;
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
      ctx.fill();
      this.x += this.vx;
      this.y += this.vy;
      this.vy += this.ay;
      if (this.y > 200) {
        this.lifetime = 0;
      }
    }
  };

  class streak {
    constructor() {
      this.x = Math.random() * 300;
      this.y = 220;
      this.speed = 5;
    }

    draw() {
      ctx.beginPath();
      ctx.globalAlpha = 0.3;
      ctx.fillStyle = "orange";
      ctx.fillRect(this.x, this.y, 20, 50)
      this.y -= this.speed;
      ctx.globalAlpha = 1;
    }
  }

  function speakingEffect() {
    this.start = Date.now();
    this.draw = function () {
      this.elapsed = Date.now() - this.start;
      let gradient = ctx.createLinearGradient(-100, 0, 420, 0)
      this.calculateVal = -2100 * Math.floor((this.elapsed / 2100) / 1) + ((this.elapsed / 2100) * (2100 / 1));
      gradient.addColorStop(SetRange((-0 + (this.calculateVal)), 0, 1000) / 1000, "hsla(52, 100%, 50%,1)");
      gradient.addColorStop(SetRange((-200 + (this.calculateVal)), 0, 1000) / 1000, "hsla(0, 100%, 50%,1)");
      gradient.addColorStop(SetRange((-400 + (this.calculateVal)), 0, 1000) / 1000, "hsla(56, 100%, 50%,1)");
      gradient.addColorStop(SetRange((-600 + (this.calculateVal)), 0, 1000) / 1000, "hsla(0, 100%, 50%,1)");
      gradient.addColorStop(SetRange((-800 + (this.calculateVal)), 0, 1000) / 1000, "hsla(52, 100%, 50%,1)");
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, 320, 200)
      drawWave(110, "black", (this.elapsed / 300), "up", 20)
      drawWave(90, "black", this.elapsed / 300, "down", 20)
      if (!speaking) {
        this.lifetime = 0;
      }
    }
  }

  function safeZoneEffect() {
    this.start = Date.now();
    this.draw = function () {
      this.elapsed = Date.now() - this.start;
      ctx.lineWidth = 30;
      if (this.elapsed < 1500) {
        ctx.beginPath();
        ctx.fillStyle = "hsla(128,100%,50%,0.1)"
        ctx.arc(160, 100, this.elapsed / 8, 0, Math.PI * 2)
        ctx.fill();
      } else if (this.elapsed < 4400) {
        ctx.beginPath();
        ctx.fillStyle = "hsla(128,100%,50%,0.1)"
        ctx.fillRect(0, 0, 320, 200)
      }
      if (this.elapsed > 1500 && this.elapsed < 2300) {
        this.calcVal = this.elapsed - 1500;
        ctx.beginPath();
        ctx.strokeStyle = "hsla(128,100%,50%,1)"
        ctx.moveTo(40, 80)
        ctx.lineTo(SetRange(40 + this.calcVal / 10, 40, 100), SetRange(80 + this.calcVal / 10, 80, 140))
        ctx.stroke();
      } else if (this.elapsed > 2300) {
        if (this.elapsed < 4400) {
          this.calcVal = this.elapsed - 2300;
          ctx.beginPath();
          ctx.strokeStyle = "hsla(128,100%,50%,1)"
          ctx.moveTo(40, 80)
          ctx.lineTo(100, 140)
          ctx.lineTo(SetRange(100 + this.calcVal / 6.2, 100, 260), SetRange(140 - this.calcVal / 10, 40, 140));
          ctx.stroke()
        }
        if (this.elapsed > 4000) {
          let gradient = ctx.createLinearGradient(-500, 0, 620, 0)
          this.calculateVal = -3200 * Math.floor((this.elapsed / 3200) / 1) + ((this.elapsed / 3200) * (3200 / 1));
          gradient.addColorStop(SetRange((-0 + (this.calculateVal)), 0, 1000) / 1000, "hsla(0, 0%, 0%,0)");
          gradient.addColorStop(SetRange((-500 + (this.calculateVal)), 0, 1000) / 1000, "hsla(130, 100%, 50%,1)");
          gradient.addColorStop(SetRange((-1000 + (this.calculateVal)), 0, 1000) / 1000, "hsla(113, 100%, 50%,1)");
          gradient.addColorStop(SetRange((-1500 + (this.calculateVal)), 0, 1000) / 1000, "hsla(0, 0%, 0%,0)");
          ctx.beginPath();
          ctx.arc(160, 100, 400, 0, Math.PI * 2)
          ctx.fillStyle = gradient;
          ctx.fill();
          if (this.elapsed > 5000) {
            safeZonePlaying = false;
            this.lifetime = 0;
          }
        }
      }
      ctx.lineWidth = 1;
    }
  }

  function DeathEffect() {
    this.start = Date.now();
    this.orbs = [];
    this.secondStage = false;
    for (let index = 0; index < 5; index++) {
      setTimeout(() => {
        this.orbs.push(new BloodOrb())
      }, 200 * index);
    }
    this.draw = function () {
      this.elapsed = Date.now() - this.start;
      ctx.beginPath();


      if (!this.secondStage) {
        ctx.fillStyle = `hsla(0,0%,0%,${this.elapsed / 1000})`
        ctx.fillRect(0, 0, 320, 200)
      }

      this.orbs.forEach((orb, i) => {
        orb.draw();
        if (orb.lifetime == 0) {
          this.orbs.splice(i, 1)
          if (!this.secondStage) {
            this.orbs.push(new BloodOrb())
          }
        }
      });
      if (!this.secondStage) {
        ctx.beginPath();
        ctx.fillStyle = "red";
        ctx.arc(160, 100, (Math.sin(this.elapsed / (500 - this.elapsed / 40)) + 1) * (this.elapsed / 100), 0, Math.PI * 2)
        ctx.fill();
      } else {
        let gradient = ctx.createRadialGradient(160, 100, 0, 160, 100, 200)
        this.calculateVal = -1385 * Math.floor(((this.elapsed - this.endTime) / 1385) / 1) + (((this.elapsed - this.endTime) / 1385) * (1385 / 1));
        gradient.addColorStop(SetRange((-0 + (this.calculateVal)), 0, 1000) / 1000, "hsla(0, 98%, 50%,1)");
        gradient.addColorStop(SetRange((-50 + (this.calculateVal)), 0, 1000) / 1000, "hsla(0, 0%, 0%,0)");
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 320, 200)
        if (this.elapsed - this.endTime > 900 || isInGame) {
          this.lifetime = 0;
        }
      }

      if ((Math.sin(this.elapsed / (500 - this.elapsed / 40)) + 1) * (this.elapsed / 100) > 150 && !this.secondStage) {
        this.orbs.length = 0;
        this.secondStage = true;
        this.endTime = this.elapsed;
      }
    }
  }

  class BloodOrb {
    constructor() {
      this.lifetime = 1;
      this.radius = (Math.random() * 15) + 5;
      if (Math.random() < 0.5) {
        this.x = Math.random() < 0.5 ? 0 - this.radius : 320 + this.radius
        this.y = Math.random() * 200;
      } else {
        this.x = Math.random() * 320;
        this.y = Math.random() < 0.5 ? 0 - this.radius : 200 + this.radius
      }
      this.angle = Math.atan2(100 - this.y, 160 - this.x)
      this.speed = {
        x: Math.cos(this.angle),
        y: Math.sin(this.angle)
      }
    }

    draw() {
      this.x += this.speed.x
      this.y += this.speed.y
      ctx.globalAlpha = 1
      ctx.beginPath();
      ctx.fillStyle = "hsla(0,100%,50%,1)"
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2)
      ctx.fill();
      if (Math.floor(this.x) > 155 && Math.floor(this.x) < 165 && Math.floor(this.y) >= 98 && Math.floor(this.y) < 102) {
        this.lifetime = 0;
      }
    }
  }



  function drawWave(y, color, frequency, direction, waveSize) {

    ctx.beginPath();

    ctx.moveTo(0, y);
    for (let i = 0; i < 320; i++) {
      ctx.lineTo(i, y + Math.sin(i * 0.01 + frequency) * waveSize);
    }
    ctx.lineTo(320, direction == "up" ? 200 : 0)
    ctx.lineTo(0, direction == "up" ? 200 : 0)
    ctx.closePath();
    ctx.fillStyle = color;
    ctx.fill();
  }

  function IdleState() {
    let lightness = new Int8Array(engine.zone.lightness);
    let sat = new Int8Array(engine.zone.saturation);
    let hue = new Int16Array(engine.zone.hue);

    for (var iZone = 0; iZone < 560; iZone++) {
      ctx.fillStyle = 'hsl(' + hue[iZone] + ',' + sat[iZone] + '%,' + lightness[iZone] * keyScreenBrightness / 100 + '%)'

      var iRow = Math.floor(iZone / 28);
      var iCol = iZone % 28;
      var iWidth = 320 / 28;
      var iHeight = 200 / 20;
      var iZx = iCol * iWidth;
      var iZy = iRow * iHeight;

      ctx.fillRect(iZx, iZy, iWidth, iHeight);



    }
  }



  //helper functions
  function GetTime() {
    return new Date().getTime();
  }

  function StateHandler() {
    var stack = [];
    var state = null;

    var updateState = function () {
      if (stack.length > 0) {
        state = stack[stack.length - 1];
      } else {
        state = null;
      }
    }

    this.Push = function (newState) {
      stack.push(newState);
      updateState();
    }

    this.Pop = function () {
      stack.pop();
      updateState();
    }

    this.Process = function () {
      if (state != null) {
        state.Process();
      }
    }
  }



  function Meter(count, callback) {
    this.size = count;
    this.value = 0;
    this.diff = 0;
    this.increased = false;
    this.decreased = false;
    var values = [];

    this.setValue = function (updatedValue) {
      // Add and shift.  
      values.push(updatedValue);
      if (values.length > this.size) { values.shift(); }

      // Exit early if we've got a long-term match.
      for (var i = 0; i < (values.length - 1); i++) {
        if (values[i] !== values[i + 1]) return;
      }

      // We got here, so we've got a matching value collection.
      if (this.value !== values[0]) {
        //var fromZero = this.value === 0;
        //var toZero = values[0] === 0;      
        this.diff = Math.abs(this.value - values[0]);
        this.increased = this.value < values[0];
        this.decreased = this.value > values[0];
        this.value = values[0];
        callback();
      }
    }
  }

  function onEngineReady() {
    // Grab canvas and rendering context.
    canvas = document.getElementById('exCanvas');
    ctx = canvas.getContext('2d');
    // Start updates *after* our engine is accessible and ready.
    window.requestAnimationFrame(update);
  }
  onEngineReady()

</script>
<head>
  <title>Rocket League</title>
  <meta description="Zoom zoom." />
  <meta publisher="SignalRGB" />

  <meta property="keyScreenBrightness" label="Ambience brightness" type="number" min="0" max="100" default="100" />
  <meta property="boostOn" label="Boost Effects" type="boolean" default="1" />
  <meta property="goalOn" label="Goal Effects" type="boolean" default="1" />
  <meta property="endGameOn" label="End Game Effects" type="boolean" default="1" />
  <meta property="searchOn" label="Search Effects" type="boolean" default="1" />
  <meta property="adjustHUD" label="Adjust Boost HUD" type="boolean" default="0" />
  <meta property="boostColor" label="Boost Color" type="color" min="0" max="360" default="#FFFF00" />
  <meta property="xPos" label="boost X-Position" type="number" min="0" max="320" default="0" />
  <meta property="yPos" label="boost Y-position" type="number" min="0" max="200" default="50" />
  <meta property="HUDStyle" label="HUD style" type="boolean" default="0" />
  <meta property="HUDRadius" label="HUD radius (circle)" type="number" min="1" max="200" default="50" />
  <meta property="HUDHeight" label="HUD height (rectangle)" type="number" min="1" max="200" default="50" />
  <meta property="HUDWidth" label="HUD width (rectangle)" type="number" min="1" max="320" default="320" />

  <meta meter="inGameBlack" tags="rocket league" type="area" x="0.4974" y="0.0139" width="0.005" height=".0001"
    h="0-360" s="0-85" l="0-25">
  <resolution size="3440x1440" x="0.4985" y="0.0118" width="0.005" height=".0001" />
  </meta>
  <meta meter="inGameWhite" tags="rocket league" type="area" x="0.4474" y="0.0065" width="0.0001" height=".0001"
    h="0-360" s="0-30" l="90-100">
  <resolution size="3440x1440" x="0.5387" y="0.0005" width="0.0001" height=".0001" />
  </meta>
  <meta meter="inGameBlue" tags="rocket league" type="area" x="0.9099" y="0.875" width="0.01" height=".0001" h="200-260"
    s="50-100" l="30-90">
  <resolution size="3440x1440" x="0.9317" y="0.8528" width="0.01" height=".0001" />
  </meta>
  <meta meter="inGameOrange" tags="rocket league" type="area" x="0.9099" y="0.875" width="0.01" height=".0001" h="0-60"
    s="50-100" l="30-90">
  <resolution size="3440x1440" x="0.9317" y="0.8528" width="0.01" height=".0001" />
  </meta>
  <meta meter="boost1" tags="rocket league" type="area" x="0.9078" y="0.9463" width="0.001" height=".0001" h="0-60"
    s="60-100" l="50-100">
  <resolution size="3440x1440" x="0.9313" y="0.9458" width="0.001" height=".0001" />
  </meta>
  <meta meter="boost2" tags="rocket league" type="area" x="0.875" y="0.9176" width="0.001" height=".0001" h="0-60"
    s="60-100" l="50-100">
  <resolution size="3440x1440" x="0.9061" y="0.9188" width="0.001" height=".0001" />
  </meta>
  <meta meter="boost3" tags="rocket league" type="area" x="0.8589" y="0.875" width="0.001" height=".0001" h="0-60"
    s="60-100" l="50-100">
  <resolution size="3440x1440" x="0.9029" y="0.9125" width="0.001" height=".0001" />
  </meta>
  <meta meter="boost4" tags="rocket league" type="area" x="0.8583" y="0.8056" width="0.001" height=".0001" h="0-60"
    s="60-100" l="50-100">
  <resolution size="3440x1440" x="0.8901" y="0.8396" width="0.001" height=".0001" />
  </meta>
  <meta meter="boost5" tags="rocket league" type="area" x="0.887" y="0.7463" width="0.001" height=".0001" h="0-60"
    s="50-100" l="50-100">
  <resolution size="3440x1440" x="0.904" y="0.766" width="0.001" height=".0001" />
  </meta>
  <meta meter="boost6" tags="rocket league" type="area" x="0.9141" y="0.7324" width="0.001" height=".0001" h="0-360"
    s="0-10" l="90-100">
  <resolution size="3440x1440" x="0.9355" y="0.7271" width="0.001" height=".0001" />
  </meta>
  <meta meter="boost7" tags="rocket league" type="area" x="0.9573" y="0.763" width="0.001" height=".0001" h="0-360"
    s="0-10" l="90-100">
  <resolution size="3440x1440" x="0.9688" y="0.7616" width="0.001" height=".0001" />
  </meta>
  <meta meter="win" tags="rocket league" type="area" x="0.9776" y="0.038" width="0.002" height=".001" h="0-360" s="0-10"
    l="90-100">
  <resolution size="3440x1440" x="0.9826" y="0.0382" width="0.002" height=".001" />
  </meta>
  <meta meter="scoreLeft" tags="rocket league" type="area" x="0.4125" y="0.0361" width="0.002" height=".01" h="0-360"
    s="0-50" l="90-100">
  <resolution size="3440x1440" x="0.4352" y="0.0403" width="0.002" height=".01" />
  </meta>
  <meta meter="scoreRight" tags="rocket league" type="area" x="0.5865" y="0.0426" width="0.002" height=".01" h="0-360"
    s="0-50" l="90-100">
  <resolution size="3440x1440" x="0.5642" y="0.0383" width="0.002" height=".01" />
  </meta>
  <meta meter="scoreBall" tags="rocket league" type="area" x="0.9729" y="0.0361" width="0.0001" height=".1" h="0-50"
    s="0-100" l="0-100">
  <resolution size="3440x1440" x="0.9785" y="0.0403" width="0.0001" height=".1" />
  </meta>
  <meta meter="searchingMid" tags="rocket league" type="linear" x="0.4797" y="0.6306" width="0.01" height =".0001" h="180-225" s="40-75"
    l="75-100">
  <resolution size="3440x1440" x="0.4892" y="0.6306" width="0.01" height =".0001" />
  </meta>
  <meta meter="searchingBot" tags="rocket league" type="linear" x="0.4448" y="0.9672" width="0.01" height =".0001" h="170-235"
    s="30-100" l="30-70">
  <resolution size="3440x1440" x="0.4625" y="0.9667" width="0.01" height =".0001" />
  </meta>
  <meta meter="replayBlock" tags="rocket league" type="linear" x=" 0.0324" y="0.9694" width="0.001" height="0.001"
    h="5-25" s="48-80" l="80-100">
  </meta>

</head>

<body style="margin: 0; padding: 0; background: #000;">
  <canvas id="exCanvas" width="320" height="200"></canvas>
</body>

<script>
  //engine.zone
  var canvas, ctx;
  canvas = document.getElementById('exCanvas');
  ctx = canvas.getContext('2d');
  var width = 320;
  var height = 200;
  var stateHdlr = new StateHandler();
  var effects = [];
  var inGame = false;
  var boostPushed = false;
  var boostState = 1;
  var oldBoostState = 1;
  var winPushed = false;
  var searchPushed = false;
  var recentScore = false;

  var InGameBlackMeter = new Meter(15, inGameHandler);
  var InGameWhiteMeter = new Meter(15, inGameHandler);
  var InGameBlueMeter = new Meter(15, inGameHandler);
  var InGameOrangeMeter = new Meter(15, inGameHandler);
  var Boost1Meter = new Meter(15, boostHandler);
  var Boost2Meter = new Meter(5, boostHandler);
  var Boost3Meter = new Meter(5, boostHandler);
  var Boost4Meter = new Meter(5, boostHandler);
  var Boost5Meter = new Meter(5, boostHandler);
  var Boost6Meter = new Meter(5, boostHandler);
  var Boost7Meter = new Meter(5, boostHandler);
  var WinMeter = new Meter(20, winHandler);
  var ScoreLeftMeter = new Meter(5, scoreHandler);
  var ScoreRightMeter = new Meter(5, scoreHandler);
  var ScoreBallMeter = new Meter(5, scoreHandler);
  var SearchingMidMeter = new Meter(10, searchHandler);
  var SearchingBotMeter = new Meter(10, searchHandler);
  var ReplayBlockMeter = new Meter(20, replayHandler)

  function update() {
    InGameBlackMeter.setValue(engine.vision.inGameBlack)
    InGameWhiteMeter.setValue(engine.vision.inGameWhite)
    InGameBlueMeter.setValue(engine.vision.inGameBlue)
    InGameOrangeMeter.setValue(engine.vision.inGameOrange)
    SearchingMidMeter.setValue(engine.vision.searchingMid)
    SearchingBotMeter.setValue(engine.vision.searchingBot)
    WinMeter.setValue(engine.vision.win)
    ScoreBallMeter.setValue(engine.vision.scoreBall)
    ReplayBlockMeter.setValue(engine.vision.replayBlock)

    if (inGame) {
      Boost1Meter.setValue(engine.vision.boost1)
      Boost2Meter.setValue(engine.vision.boost2)
      Boost3Meter.setValue(engine.vision.boost3)
      Boost4Meter.setValue(engine.vision.boost4)
      Boost5Meter.setValue(engine.vision.boost5)
      Boost6Meter.setValue(engine.vision.boost6)
      Boost7Meter.setValue(engine.vision.boost7)
      ScoreLeftMeter.setValue(engine.vision.scoreLeft)
      ScoreRightMeter.setValue(engine.vision.scoreRight)
    }

    DrawRect(0, 0, 320, 200, "black");

    if (keyScreenBrightness > 0) {
      copyScreen(1);
    }

    for (let i = 0; i < effects.length; i++) {
      effects[i].draw();
      if (effects[i].lifetime <= 0) {
        effects.splice(i, 1);
      }
    };

    if (adjustHUD) {
      if (HUDStyle) {
        DrawCircle(xPos, yPos, HUDRadius, boostColor)
      } else {
        DrawRect(xPos, yPos, HUDWidth, HUDHeight, boostColor)
      }
    }

    stateHdlr.Process();
    window.requestAnimationFrame(update);
  };

  function inGameHandler() {
    if (InGameBlackMeter.value > .9 && InGameWhiteMeter.value > .9 && (InGameBlueMeter.value > .6 || InGameOrangeMeter.value > .6)) {
      inGame = true;
    } else {
      boostPushed = false;
      inGame = false;
    }
  };

  function replayHandler() {
    if (ReplayBlockMeter.decreased) {
      recentScore = false;
    }
  }

  function boostHandler() {
    if (!boostPushed && inGame && boostOn) {
      effects.push(new boostHUD(xPos, yPos, HUDRadius))
      boostPushed = true;
    }
    if (Boost7Meter.value == 1 && Boost6Meter.value == 1) {
      boostState = 7;
    } else if (Boost6Meter.value == 1 && Boost5Meter.value == 1 && Boost7Meter.value != 1) {
      boostState = 6;
    } else if (Boost5Meter.value == 1 && Boost4Meter.value == 1 && Boost6Meter.value != 1) {
      boostState = 5;
    } else if (Boost4Meter.value == 1 && Boost3Meter.value == 1 && Boost5Meter.value != 1) {
      boostState = 4;
    } else if (Boost3Meter.value == 1 && Boost2Meter.value == 1 && Boost4Meter.value != 1) {
      boostState = 3;
    } else if (Boost2Meter.value == 1 && Boost1Meter.value == 1 && Boost3Meter.value != 1) {
      boostState = 2;
    } else if (Boost1Meter.value == 1 && Boost2Meter.value != 1) {
      boostState = 1;
    } else {
      boostState = 0;
    }
    if (boostState > oldBoostState && inGame && boostOn) {
      effects.push(new boostUp(xPos, yPos))
    }
    oldBoostState = boostState;
  }

  function winHandler() {
    console.log(ScoreBallMeter.value)
    if (WinMeter.value == 1 && ScoreBallMeter.value > .3 && !winPushed && endGameOn) {
      effects.push(new gameEnd())
      winPushed = true;
    }
  }

  function scoreHandler() {
    if (ScoreBallMeter.value > .1 && ScoreLeftMeter.value > .75 && goalOn) {
      effects.push(new score(true))
      setTimeout(() => {
        recentScore = true;
      }, 4000);
      setTimeout(() => {
        recentScore = false;
      }, 15000);
    } else if (ScoreBallMeter.value > .1 && ScoreRightMeter.value > .75) {
      effects.push(new score(false))
      setTimeout(() => {
        recentScore = true;
      }, 4000);
      setTimeout(() => {
        recentScore = false;
      }, 15000);
    }
  }

  function searchHandler() {
    if (SearchingBotMeter.value == 1 && SearchingMidMeter.value == 1 && !searchPushed && searchOn) {
      effects.push(new search())
      searchPushed = true
    }
  };

  function search() {
    this.lifetime = 10;
    this.effects = [];
    this.draw = function () {
      DrawRect(0, 0, 320, 200, "black")
      DrawHex(160, 100, "cyan", 70)
      if (this.effects.length < 2) {
        this.effects.push(new arrow(195, 100, "right", 70, 30, 2, "cyan"))
        this.effects.push(new arrow(125, 100, "left", 70, 30, 2, "cyan"))
      }
      this.effects.forEach((ele, i) => {
        ele.draw();
        if (ele.lifetime <= 0) {
          this.effects.splice(i, 1)
        }
      });
      if (SearchingBotMeter.value < .75 || SearchingMidMeter.value < .75 || !searchOn) {
        this.lifetime = 0
        searchPushed = false
      }
    }
  }

  function arrow(x, y, direction, size, stroke, speed, color) {
    this.x = x;
    this.y = y;
    this.direction = direction;
    this.size = size;
    this.stroke = stroke;
    this.speed = speed;
    this.color = color;
    this.draw = function () {
      var firstX = this.direction == "left" ? this.x + this.size : this.x - this.size;
      var secondX = this.direction == "left" ? this.x + this.size : this.x - this.size;
      ctx.beginPath();
      ctx.moveTo(firstX, this.y - this.size)
      ctx.lineTo(this.x, this.y)
      ctx.lineTo(secondX, this.y + this.size)
      ctx.lineWidth = this.stroke;
      ctx.strokeStyle = this.color
      ctx.stroke()
      this.direction == "left" ? this.x -= this.speed : this.x += this.speed;
      if (this.x > 370 || this.x < -50) {
        this.lifetime = 0;
      }
    }
  }

  function score(you) {
    this.type = you;
    this.type ? this.x = 0 : this.x = 320;
    this.y = 100;
    this.lifetime = 10;
    if (InGameBlueMeter.value > InGameOrangeMeter.value) {
      this.type ? this.color = "blue" : this.color = "orange";
    } else {
      this.type ? this.color = "orange" : this.color = "blue";
    }
    this.draw = function () {
      DrawCircle(this.x, this.y, 50, "grey")
      DrawStroke(this.x, this.y, 50, "black", 15)
      this.type ? this.x += 10 : this.x -= 10;
      if (Math.abs(160 - this.x) <= 20) {
        for (let i = 0; i < 30; i++) {
          effects.push(new explosionParticle(160, 100, 10, this.color))
        }
      }
      if (this.x > 350 || this.x < -20 || !inGame) {
        this.lifetime = 0;
      }
    }
  }

  function explosionParticle(x, y, min, color) {
    this.x = x;
    this.y = y;
    this.vx = Math.random() * -min + min / 2;
    this.vy = Math.random() * -min + min / 2;
    this.min = min;
    this.color = color;
    this.lifetime = 10;
    this.start = Date.now()
    this.draw = function () {
      DrawCircle(this.x, this.y, Math.random() * 10 + 10, this.color)
      this.x += this.vx;
      this.y += this.vy;
      if (this.x > 320 || this.x < 0 || this.y > 200 || this.y < 0 || Date.now() - this.start >= 3000) {
        this.lifetime = 0;
      }
    }
  }

  function gameEnd() {
    this.lifetime = 10;
    this.start1 = Date.now();
    this.start2 = Date.now();
    this.effects = []
    this.draw = function () {
      var elapsed = Date.now() - this.start2;
      var color = `hsl(${engine.audio.density * 320}, 100%, 50%)`
      var level = 100 + engine.audio.level
      if (level > 80 && elapsed > 100) {
        this.effects.push(new winStroke(160, 200, color))
        this.start2 = Date.now()
      }
      this.effects.forEach((ele, i) => {
        ele.draw();
        if (ele.lifetime <= 0) {
          this.effects.splice(i, 1);
        }
      });

      if (Date.now() - this.start1 > 15000 || !endGameOn) {
        this.lifetime = 0;
        winPushed = false;
      }
    }
  }

  function winStroke(x, y, color) {
    this.x = x;
    this.y = y;
    this.color = color;
    this.radius = 1;
    this.alpha = 1;
    this.draw = function () {
      ctx.globalAlpha = this.alpha;
      DrawStroke(this.x, this.y, this.radius, this.color, 30)
      ctx.globalAlpha = 1;
      this.radius += 5;
      this.radius > 100 ? this.alpha -= .05 : null;
      this.alpha <= 0 ? this.lifetime = 0 : null;
    }
  }

  function boostHUD(x, y, radius) {
    this.x = x;
    this.y = y;
    this.prevBoostVal = 0;
    this.radius = radius;
    this.lifetime = 10;
    this.draw = function () {
      this.x = xPos;
      this.y = yPos;
      this.radius = HUDRadius
      if (!recentScore) {


        switch (boostState) {
          case 0:
            HUDStyle ? DrawCircle(this.x, this.y, this.radius, `hsl(0, 100%, ${Math.sin(Date.now() / 200) * 20 + 30}%)`) :
              DrawRect(this.x, this.y, 320, 50, `hsl(0, 100%, ${Math.sin(Date.now() / 200) * 20 + 30}%)`);

            break;
          case 7:
            var thisColor = hexToHSL(boostColor)
            HUDStyle ? DrawCircle(this.x, this.y, this.radius, `hsl(${thisColor[0]}, 100%, ${Math.sin(Date.now() / 200) * 20 + 60}%)`) :
              DrawRect(this.x, this.y, 320, 50, `hsl(${thisColor[0]}, 100%, ${Math.sin(Date.now() / 100) * 10 + 60}%)`);
            break;
          default:
            if (HUDStyle) {
              var endAngle = -Math.PI / 2 + (Math.PI * 2 / 6) * boostState
              ctx.fillStyle = boostColor;
              ctx.beginPath();
              ctx.moveTo(this.x, this.y);
              ctx.arc(this.x, this.y, this.radius, -Math.PI / 2, endAngle);
              ctx.closePath();
              ctx.fill();
            } else {
              DrawRect(this.x, this.y, 320 / 7 * boostState, 50, boostColor)
            }
            break;
        }
      }
      if (!inGame || !boostOn) {
        this.lifetime = 0;
        boostPushed = false;
      }
    }
  }

  function boostUp(x, y) {
    this.x = xPos;
    this.y = yPos;
    this.radius = 1;
    this.width = HUDWidth;
    this.height = HUDHeight;
    this.lifetime = 10;
    this.alpha = 1;
    this.draw = function () {
      if (HUDStyle) {
        DrawStroke(this.x, this.y, this.radius, "white", 30)
        this.radius += 5;
        if (this.radius > 200) {
          this.lifetime = 0;
        }
      } else {
        ctx.globalAlpha = this.alpha;
        DrawRect(this.x, this.y, this.width, this.height, "white")
        ctx.globalAlpha = 1;
        this.alpha -= .04;
        this.x -= 5;
        this.y -= 5;
        this.width += 10;
        this.height += 10;
        if (this.alpha <= 0) {
          this.lifetime = 0;
        }
      }
    }
  }

  function renderPath(x, y, path, color) {
    ctx.fillStyle = color;
    ctx.save();
    ctx.translate(x, y);
    let ex = new Path2D(path);
    ctx.fill(ex);
    ctx.restore();
  }

  function DrawCircle(x, y, radius, color) {
    ctx.beginPath();
    ctx.fillStyle = color;
    ctx.arc(x, y, radius, 0, 2 * Math.PI)
    ctx.fill();
  };

  function DrawHex(x, y, color, size) {
    ctx.beginPath();
    for (var i = 0; i < 7; i++) {
      ctx.lineTo(x + size * Math.cos(2 * Math.PI / 6 * i), y + size * 0.9 * Math.sin(2 * Math.PI / 6 * i));
    }
    ctx.fillStyle = color;
    ctx.fill();
    ctx.strokeStyle = "black"
    ctx.stroke()
  };

  function DrawStroke(x, y, radius, color, stroke) {
    ctx.beginPath();
    ctx.strokeStyle = color;
    ctx.lineWidth = stroke;
    ctx.arc(x, y, radius, 0, 2 * Math.PI)
    ctx.stroke();
  };

  function DrawRect(x, y, height, width, color) {
    ctx.beginPath();
    ctx.fillStyle = color;
    ctx.fillRect(x, y, height, width);
  }

  function copyScreen(alpha) {
    var shine = engine.vision.ShineMeter
    let lightness = new Int8Array(engine.zone.lightness);
    let sat = new Int8Array(engine.zone.saturation);
    let hue = new Int16Array(engine.zone.hue);
    for (var iZone = 0; iZone < 560; iZone++) {
      var iRow = Math.floor(iZone / 28);
      var iCol = iZone % 28;
      var iWidth = 320 / 28;
      var iHeight = 200 / 20;
      var iZx = iCol * iWidth;
      var iZy = iRow * iHeight;
      ctx.fillStyle =
        "hsla(" +
        hue[iZone] +
        "," +
        sat[iZone] +
        "%," +
        lightness[iZone] * keyScreenBrightness / 100 +
        "%, " +
        `${alpha}` +
        ")";

      ctx.fillRect(iZx, iZy, iWidth, iHeight);
    }
  }

  function hexToHSL(H) {
    // Convert hex to RGB first
    let r = 0, g = 0, b = 0;
    if (H.length == 4) {
      r = "0x" + H[1] + H[1];
      g = "0x" + H[2] + H[2];
      b = "0x" + H[3] + H[3];
    } else if (H.length == 7) {
      r = "0x" + H[1] + H[2];
      g = "0x" + H[3] + H[4];
      b = "0x" + H[5] + H[6];
    }
    // Then to HSL
    r /= 255;
    g /= 255;
    b /= 255;
    let cmin = Math.min(r, g, b),
      cmax = Math.max(r, g, b),
      delta = cmax - cmin,
      h = 0,
      s = 0,
      l = 0;

    if (delta == 0)
      h = 0;
    else if (cmax == r)
      h = ((g - b) / delta) % 6;
    else if (cmax == g)
      h = (b - r) / delta + 2;
    else
      h = (r - g) / delta + 4;

    h = Math.round(h * 60);

    if (h < 0)
      h += 360;

    l = (cmax + cmin) / 2;
    s = delta == 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));
    s = +(s * 100).toFixed(1);
    l = +(l * 100).toFixed(1);

    return [h, s, l];
  }

  function StateHandler() {
    var stack = [];
    var state = null;

    var updateState = function () {
      if (stack.length > 0) {
        state = stack[stack.length - 1];
      } else {
        state = null;
      }
    };

    this.Push = function (newState) {
      stack.push(newState);
      updateState();
    };

    this.Pop = function () {
      stack.pop();
      updateState();
    };

    this.Process = function () {
      if (state != null) {
        state.Process();
      }
    };
  }

  function Meter(size, callback) {
    this.size = size;
    this.value = 0;
    this.diff = 0;
    this.increased = false;
    this.decreased = false;
    var values = [];

    this.setValue = function (updatedValue) {
      values.push(updatedValue);
      if (values.length > this.size) {
        values.shift();
      }

      for (var i = 0; i < values.length - 1; i++) {
        if (values[i] !== values[i + 1]) return;
      }
      if (this.value !== values[0]) {
        this.diff = Math.abs(this.value - values[0]);
        this.increased = this.value < values[0];
        this.decreased = this.value > values[0];
        this.value = values[0];
        callback();
      }
    };
  }

  function timedMeter(size, callback) {
    this.size = size;
    this.value = 0;
    this.diff = 0;
    this.increased = false;
    this.decreased = false;
    this.start = Date.now();
    this.elapsed = 0;
    var values = [];

    this.setValue = function (updatedValue) {
      values.push(updatedValue);
      this.elapsed = Date.now() - this.start;
      if (values.length > this.size) {
        values.shift();
      }

      for (var i = 0; i < values.length - 1; i++) {
        if (values[i] !== values[i + 1]) return;
      }
      if (this.value !== values[0]) {
        this.diff = Math.abs(this.value - values[0]);
        this.increased = this.value < values[0];
        this.decreased = this.value > values[0];
        this.value = values[0];
        this.start = Date.now();
        callback();
      }
    };
  }
  window.requestAnimationFrame(update)
</script>
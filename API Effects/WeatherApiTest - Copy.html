<head>
    <title>WeatherEffect Working?</title>
    <meta description="Template" />
    <meta publisher="SignalRGB" />
    <meta property="City" label="City" type="textfield" default="">


</head>

<body style="margin: 0; padding: 0;">
    <canvas id="exCanvas" width="320" height="200"></canvas>
</body>

<script>

    var effects = [];
    var timeSinceLastRequest = Date.now();
    var elapsed;
    var updateSpeed = 30;
    var prevCity = "";
    var startTimer = -1;
    var queudRefresh = false;
    var currentCity;
    var prevTime = 0;
    var lat;
    var long;



    function update() {

        elapsed = Date.now() - timeSinceLastRequest;
        ctx.beginPath();
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, 320, 200);
        CheckTick();

        //Effects animation play
        if (effects.length) {
            effects.forEach((element, index) => {
                element.draw();
                if (element.lifetime <= 0) {
                    effects.splice(index, 1);
                }
            })
        }

        window.requestAnimationFrame(update);
    }


    function CheckTick() {
        if (elapsed > 60000 * updateSpeed) {
            GetData();
            timeSinceLastRequest = Date.now();
        }
        if (new Date() - prevTime >= 30000) {
            console.log(new Date().toLocaleTimeString('en-US', {
                hour12: false,
            }))
            prevTime = new Date();
        }
        if (queudRefresh && Date.now() - startTimer > 5000 && Date.now() - startTimer < 10000 || City == "") {
            startTimer = -1;
            queudRefresh = false;
            if (City != "") {
                GetData();
            }
        }
    }

    // function CheckCity() {
    //     currentCity = City;
    //     if (City == "") {
    //         ctx.beginPath();
    //         ctx.fillStyle = "white";
    //         ctx.font = '60px serif';
    //     }
    //     if (prevCity != City) {
    //         prevCity = City;
    //         startTimer = Date.now();
    //         if (!queudRefresh) {
    //             effects.push(new Sweep())
    //         }
    //         queudRefresh = true;
    //     }
    // }

    function GetData() {
        

         fetch(`https://api.bigdatacloud.net/data/reverse-geocode-client`).then(response => response.json())
            .then((position) => {
                lat = position.latitude;
                long = position.longitude;

                console.log(lat);
                console.log(long);
            })
            .catch(error => {
                console.log(error);
                effects.push(new ApiStateEffect("red"))
                timeSinceLastRequest = Date.now();
            });

        fetch(`https://cors-anywhere.herokuapp.com/https://www.7timer.info/bin/api.pl?lon=${long}&lat=${lat}&product=civil&output=json`).then(response => response.json())
            .then((weather) => {
                console.log(JSON.stringify(weather.dataseries[0].weather))
                weatherOBJ = weather;
                timeSinceLastRequest = Date.now();
                if (weather.message == undefined && weather.description != "") {
                    effects.push(new ApiStateEffect("hsla(104, 100%, 50%,1)"))
                } else {
                    effects.push(new ApiStateEffect("red"))
                }


            })
            .catch(error => {
                console.log(error);
                effects.push(new ApiStateEffect("red"))
                timeSinceLastRequest = Date.now();
            });
    }

    function successFunction(position) {
        lat = position.coords.latitude;
        long = position.coords.longitude;
        console.log('Your latitude is :' + lat + ' and longitude is ' + long);
    }

    function ApiStateEffect(color) {
        this.start = Date.now();
        this.draw = function () {
            this.elapsed = Date.now() - this.start;
            let gradient = ctx.createLinearGradient(0, -100, 0, 300)
            this.calculateVal = -1660 * Math.floor((this.elapsed / 1660) / 1) + ((this.elapsed / 1660) * (1660 / 1));
            gradient.addColorStop(SetRange((-0 + (this.calculateVal)), 0, 1000) / 1000, "hsla(0, 0%, 0%,0)");
            gradient.addColorStop(SetRange((-200 + (this.calculateVal)), 0, 1000) / 1000, color);
            gradient.addColorStop(SetRange((-400 + (this.calculateVal)), 0, 1000) / 1000, "hsla(0, 0%, 0%,0)")
            ctx.beginPath();
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 00, 320, 200)
            if (this.elapsed > 1500) {
                this.lifetime = 0;
            }
        }
    }

    function Sweep() {
        this.start = Date.now();
        this.draw = function () {
            this.elapsed = Date.now() - this.start;
            ctx.beginPath();
            ctx.fillStyle = "black";
            ctx.fillRect(0, 0, 320, 200);
            ctx.beginPath();
            ctx.fillStyle = "hsla(174, 100%, 58%, 1)";
            ctx.fillRect(0, 0, 320 * ((Date.now() - startTimer) / 4000), 200)
            if (startTimer == -1 || City == "") {
                this.lifetime = 0;
            }
        }
    }

    class GeneralBackgroundProp {
        constructor(x, y, BackgroundLevel, Direction, DoAnimation = false) {
            this.StartX = 0;
            this.StartY = y;
            this.MoveX = x;
            this.MoveY = DoAnimation ? y < 160 ? -50 : 250 : y;
            this.BackgroundLevel = BackgroundLevel;
            this.Direction = Direction;
            this.DoAnimation = DoAnimation;
            this.start = Date.now();
            this.elapsed = 0;
        }

        startUpAnim() {

            if (this.StartY < 160) {
                if (this.MoveY < this.StartY) {
                    this.MoveY += 1;
                }

            } else {
                if (this.StartY > 160) {
                    if (this.MoveY > this.StartY) {
                        this.MoveY -= 1;
                    }
                }
            }


        }
        calculateNewPos() {
            if (this.DoAnimation && this.elapsed < 1000) {
                this.startUpAnim();
            }

            this.elapsed = Date.now() - this.start;
            if (this.Direction == "Right") {
                this.MoveX += 1;
            } else {
                this.MoveX -= 1;
            }
            return { x: this.MoveX, y: this.MoveY };
        }
    }


    class Cloud extends GeneralBackgroundProp {
        constructor() {
            super(Math.random() > 0.5 ? 320 : 0, Math.random() * 60, Math.random() * 10, Math.random() > 0.5 ? "Right" : "Left", true)
        }
        draw() {
            let pos = super.calculateNewPos();
            ctx.beginPath();
            ctx.fillStyle = "hsla(0, 100%, 58%, 1)";
            ctx.fillRect(pos.x, pos.y, 50, 50);
        }
    }


    function SetRange(num, min, max) {

        return Math.min(Math.max(num, min), max)
    }




    function OnEngineReady() {
        c = document.getElementById("exCanvas");
        GetData();
        ctx = c.getContext("2d");
        effects.push(new Cloud())
        window.requestAnimationFrame(update);
    }

    OnEngineReady();
</script>
<head>
    <title>WeatherEffect</title>
    <meta description="Template" />
    <meta publisher="SignalRGB" />
    <meta property="UseIp" label="Use current IP" type="boolean" default="1">
    <meta property="City" label="City" type="textfield" default="">


</head>

<body style="margin: 0; padding: 0;">
    <canvas id="exCanvas" width="320" height="200"></canvas>
</body>

<script>

    var effects = [];
    var timeSinceLastRequest = Date.now();
    var elapsed;
    var updateSpeed = 30;
    var prevCity = "";
    var startTimer = -1;
    var queudRefresh = false;
    var currentCity = "";
    var prevTime = 0;
    var useIp;
    var boolChange = false;
    const SUNNYGRASSPALLETE = [
        "#70c725",
        "#44a318",
        "#328530",
        "#3d9815",
        "#58ac14"
    ]
    var stateMgr = new StateHandler();


    function update() {
        currentCity = City;
        if (UseIp != useIp) {
            useIp = UseIp;
            boolChange = true;
        }

        elapsed = Date.now() - timeSinceLastRequest;
        ctx.beginPath();
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, 320, 200);
        CheckCity();
        CheckTick();

        //Effects animation play
        if (effects.length) {
            effects.forEach((element, index) => {
                element.draw();
                if (element.lifetime <= 0) {
                    effects.splice(index, 1);
                }
            })
        }
        stateMgr.Process();
        window.requestAnimationFrame(update);
    }


    function CheckTick() {
        if (elapsed > 60000 * updateSpeed) {
            GetData();
            timeSinceLastRequest = Date.now();
        }
        if (new Date() - prevTime >= 30000) {
            console.log(new Date().toLocaleTimeString('en-US', {
                hour12: false,
            }))
            prevTime = new Date();
        }
        if (queudRefresh && Date.now() - startTimer > 5000 && Date.now() - startTimer < 10000 || useIp == false && currentCity == "") {
            startTimer = -1;
            queudRefresh = false;
            if (City != "" || useIp) {
                GetData();
            }
        }
    }

    function CheckCity() {

        if (prevCity != City || boolChange) {
            boolChange = false;
            prevCity = City;
            startTimer = Date.now();
            if (!queudRefresh) {
                effects.push(new Sweep())
            }
            queudRefresh = true;
        }
    }

    function GetData() {

        if (useIp) {
            fetch(`https://api.bigdatacloud.net/data/reverse-geocode-client`).then(response => response.json())
                .then((position) => {
                    console.log("here")
                    FetchWeather(position.locality);
                })
                .catch(error => {
                    console.log(error);
                    effects.push(new ApiStateEffect("red"))
                    timeSinceLastRequest = Date.now();
                });
        } else if (currentCity != "" && currentCity != null) {
            FetchWeather(currentCity)
        }
    }


    function FetchWeather(selectedcity) {
        console.log("Input city is =" + selectedcity)
        fetch(`https://api.codetabs.com/v1/proxy?quest=wttr.in/${selectedcity}?format=j1`).then(response => response.json())
            .then((weather) => {

                let area = weather.nearest_area[0].areaName[0].value;
                timeSinceLastRequest = Date.now();
                if (area != "Tong Not") {
                    weatherOBJ = weather;
                    console.log(JSON.stringify(weather.current_condition[0].weatherDesc[0]))
                    console.log("Temperature in celcius =" + JSON.stringify(weather.current_condition[0].temp_C))
                    console.log("Temperature in fahrenheit =" + JSON.stringify(weather.current_condition[0].temp_F))
                    console.log("Actual area = " + area)
                    console.log("Actual country = " + JSON.stringify(weather.nearest_area[0].country))

                    effects.push(new ApiStateEffect("hsla(104, 100%, 50%,1)"))
                } else {
                    console.log("City not found")
                    effects.push(new ApiStateEffect("red"))
                }


            })
            .catch(error => {
                console.log(error);
                effects.push(new ApiStateEffect("red"))
                timeSinceLastRequest = Date.now();
            });
    }
    function successFunction(position) {
        lat = position.coords.latitude;
        long = position.coords.longitude;
        console.log('Your latitude is :' + lat + ' and longitude is ' + long);
    }

    function ApiStateEffect(color) {
        this.start = Date.now();
        this.draw = function () {
            this.elapsed = Date.now() - this.start;
            let gradient = ctx.createLinearGradient(0, -100, 0, 300)
            this.calculateVal = -1660 * Math.floor((this.elapsed / 1660) / 1) + ((this.elapsed / 1660) * (1660 / 1));
            gradient.addColorStop(SetRange((-0 + (this.calculateVal)), 0, 1000) / 1000, "hsla(0, 0%, 0%,0)");
            gradient.addColorStop(SetRange((-200 + (this.calculateVal)), 0, 1000) / 1000, color);
            gradient.addColorStop(SetRange((-400 + (this.calculateVal)), 0, 1000) / 1000, "hsla(0, 0%, 0%,0)")
            ctx.beginPath();
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 00, 320, 200)
            if (this.elapsed > 1500) {
                this.lifetime = 0;
            }
        }
    }

    function Sweep() {
        this.start = Date.now();
        this.draw = function () {
            this.elapsed = Date.now() - this.start;
            ctx.beginPath();
            ctx.fillStyle = "black";
            ctx.fillRect(0, 0, 320, 200);
            ctx.beginPath();
            ctx.fillStyle = "hsla(174, 100%, 58%, 1)";
            ctx.fillRect(0, 0, 320 * ((Date.now() - startTimer) / 4000), 200)
            if (startTimer == -1) {
                this.lifetime = 0;
            }
        }
    }

    class GeneralBackgroundProp {
        constructor(x, y, Direction, moveSpeed, DoAnimation = false, loop = false) {
            this.StartX = 0;
            this.StartY = y;
            this.MoveX = x;
            this.MoveY = DoAnimation ? y < 160 ? -50 : 250 : y;
            this.moveSpeed = moveSpeed;
            this.Direction = Direction;
            this.DoAnimation = DoAnimation;
            this.start = Date.now();
            this.elapsed = 0;
            this.loop = loop;
        }

        startUpAnim() {

            if (this.StartY < 160) {
                if (this.MoveY < this.StartY) {
                    this.MoveY += 1;
                }

            } else {
                if (this.StartY > 160) {
                    if (this.MoveY > this.StartY) {
                        this.MoveY -= 1;
                    }
                }
            }


        }
        calculateNewPos() {
            if (this.DoAnimation && this.elapsed < 10000) {
                this.startUpAnim();
            }

            this.elapsed = Date.now() - this.start;
            if (this.Direction == "Right") {
                this.MoveX += this.moveSpeed;
            } else {
                this.MoveX -= this.moveSpeed;
            }

            if (this.MoveX > 350 && this.loop) {
                this.MoveX = -20
            } else if (this.MoveX < -30 && this.loop) {
                this.MoveX = 330
            }
            return { x: this.MoveX, y: this.MoveY };
        }
    }


    class Cloud extends GeneralBackgroundProp {
        constructor(direction, backgroundLevel, h, s, brightness, y = 35) {
            super(Math.random() * 320, Math.random() * y, direction, backgroundLevel / 5 + 0.1, true, true)
            this.balls = [];
            this.cloud = true;
            this.h = h;
            this.brightness = brightness;
            this.backgroundLevel = backgroundLevel;
            for (let index = 0; index < 5; index++) {
                this.balls.push(new cloudBall(Math.random() * 35, Math.random() * 35, Math.random() * 20 + 5, `hsl(${this.h},${s}%,${this.brightness + this.backgroundLevel * 10}%)`))
            }
        }
        draw() {
            let pos = super.calculateNewPos();
            this.balls.forEach((ball, index) => {
                this.balls[index].draw(pos.x, pos.y);

            })


        }
    }


    function cloudBall(xOffset, yOffset, radius, color) {
        this.xOffset = xOffset;
        this.yOffset = yOffset;
        this.radius = radius;
        this.color = color;
        this.start = Date.now();
        this.duration = Math.random() * 8000 + 3000;

        this.draw = function (x, y) {
            ctx.beginPath();
            ctx.globalAlpha = 0.8;
            DrawCircle(x + this.xOffset, y + this.yOffset, this.radius, this.color);
            ctx.globalAlpha = 1;
        }
    }

    function floatingPollen() {
        this.y = Math.random() * 100;
        this.x = 320 + Math.random() * 100;
        this.start = Date.now();
        this.elapsed = 0;
        this.lifetime = Math.random() * 8000 + 3000;
        this.randomCol = Math.random() * 50;
        this.speed = Math.random() * 2 + 0.4;
        this.offset = Math.random() * 5000;
        this.draw = function () {
            this.elapsed = Date.now() - this.start;

            ctx.beginPath();

            DrawCircle(this.x, this.y + Math.sin((this.elapsed + this.offset) / 2000) * 30, 2, `hsl(${67 + this.randomCol},85%,60%)`);
            this.x -= this.speed;
        }
    }

    function DrawSunnySky(sunH, sunBrightness, sunSize) {
        ctx.beginPath();
        let grad;
        grad = ctx.createRadialGradient(200, 40, 20, 200, 40, 200)
        grad.addColorStop(0, `hsl(${sunH},100%,${sunBrightness}%)`);
        grad.addColorStop(sunSize - 0.1, `hsl(${sunH},100%,${sunBrightness}%)`);
        grad.addColorStop(sunSize + 0.1, "hsl(210,80%,58%)")
        grad.addColorStop(1, "hsl(220,100%,17%)")
        ctx.globalAlpha = 1;
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, 320, 200)
    }


    function DrawRainySky() {
        ctx.beginPath();
        let grad;
        grad = ctx.createRadialGradient(200, 40, 20, 200, 40, 200)
        grad.addColorStop(0, "hsl(50,2%,35%)")
        grad.addColorStop(0.3, "hsl(72,2%,30%)")
        grad.addColorStop(0.7, "hsl(150,1%,15%)")
        grad.addColorStop(1, "hsl(192,6%,6%)")
        ctx.globalAlpha = 1;
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, 320, 200)
    }

    function SunnyHill(brightness) {
        this.grass = [];
        for (let index = 0; index < 50; index++) {
            let x = Math.random() * 320;
            this.grass.push(new grass(x, quadraticFormuleForHill((x - 160) * 2), hexToHSL(SUNNYGRASSPALLETE[Math.floor(Math.random() * SUNNYGRASSPALLETE.length)]), 0, brightness));

        }
        this.draw = function () {
            DrawCircle(160, 1025, 900, `hsla(98, 84%, ${brightness}%, 1)`)
            this.grass.forEach(grass => {
                grass.draw();
            });
        }
    }

    function quadraticFormuleForHill(x) {
        return 0.00015 * x * x + 0 * x + 125;
    }

    function grass(x, y, color, rotation, brightness) {
        this.x = x;
        this.y = y;
        this.lineWidth = Math.random() * 5 + 1;;
        this.color = color;
        this.height = Math.random() * 10 + 3;
        this.start = Date.now();
        this.speed = Math.random() * 0.8 + 0.5;
        this.rotation = rotation;;

        this.draw = function () {

            this.elapsed = Date.now() - this.start;
            ctx.beginPath();
            ctx.save();
            ctx.rotate(this.rotation)
            ctx.translate(this.x, this.y)
            ctx.moveTo(0, 0)
            ctx.bezierCurveTo(0, 0 - this.height, 0 + Math.sin(((this.elapsed / 500) * this.speed) + 100) * this.height * 1.5, 0 - this.height * 2, 0 + Math.sin(((this.elapsed / 500) * this.speed) + 200) * this.height * 2, 0 - this.height * 3)
            ctx.lineWidth = this.lineWidth;
            ctx.strokeStyle = `hsl(${this.color.h},${this.color.s}%,${brightness + (this.color.l) / 5}%)`;
            ctx.stroke();
            ctx.restore();
        }
    }





    function DrawCircle(x, y, radius, color) {
        ctx.beginPath();
        ctx.fillStyle = color;
        ctx.arc(x, y, radius, 0, 2 * Math.PI)
        ctx.fill();
    };

    function SetRange(num, min, max) {

        return Math.min(Math.max(num, min), max)
    }

    function CloudySkyState(intensity) {
        this.clouds = [];
        this.SunnyHill = new SunnyHill(50);
        this.cloudAmount = intensity == "partly" ? 5 : intensity == "heavy" ? 50 : 20

        for (let index = 0; index < this.cloudAmount; index++) {
            this.clouds.push(new Cloud("left", Math.floor(Math.random() * 6), 198, 76, 35));
        }
        this.clouds = SortClouds(this.clouds)

        this.Process = function () {
            if (!queudRefresh) {
                this.draw();
            }
        }

        this.draw = function () {

            DrawSunnySky(48, 50, 0.2);
            this.clouds.forEach(cloud => {
                cloud.draw();
            });
            this.SunnyHill.draw();
        }
    }

    function SunnyState() {

        this.SunnyHill = new SunnyHill(50);
        this.pollen = [];
        for (let index = 0; index < 50; index++) {

            this.pollen.push(new floatingPollen())
        }
        this.Process = function () {
            if (!queudRefresh) {
                this.draw();
            }
        }
        this.draw = function () {
            DrawSunnySky(34, 50, 0.35);
            this.SunnyHill.draw();
            this.pollen.forEach((pol, i) => {
                pol.draw();
                if (pol.x < -20) {
                    this.pollen.splice(i, 1)
                    this.pollen.push(new floatingPollen())
                }
            });
        }
    }

    function RainyState() {

        this.clouds = [];
        this.rainDrops = [];
        this.SunnyHill = new SunnyHill(10);
        this.cloudAmount = 50;

        for (let index = 0; index < this.cloudAmount; index++) {
            this.clouds.push(new Cloud("left", Math.floor(Math.random() * 6), 150, 2, 3, 20));
        }
        this.clouds = SortClouds(this.clouds)
        for (let index = 0; index < 100; index++) {
            let backgroundLevel = Math.floor(Math.random() * 5);
            this.rainDrops.push(new rainDrop(Math.random() * 320, 0 - Math.random() * -50, 5 - backgroundLevel, `hsla(212, 77%, ${50 - backgroundLevel * 10}%, 1`));
        }
        this.Process = function () {
            if (!queudRefresh) {
                this.draw();
            }
        }
        this.draw = function () {
            DrawRainySky();
            this.clouds.forEach(cloud => {
                cloud.draw();
            });

            this.rainDrops.forEach(raindrop => {
                raindrop.draw();
                if (raindrop.y > 220) {
                    let backgroundLevel = Math.floor(Math.random() * 5);
                    this.rainDrops.splice(this.rainDrops.indexOf(raindrop), 1)
                    this.rainDrops.push(new rainDrop(Math.random() * 320, 0 - Math.random() * -50, 5 - backgroundLevel, `hsla(212, 77%, ${50 - backgroundLevel * 5}%, 1`));
                }
            });
            this.SunnyHill.draw();


        }
    }

    class rainDrop {
        constructor(x, y, speed, color) {
            this.x = x;
            this.y = y;
            this.speed = speed;
            this.color = color;
        }

        draw() {
            ctx.beginPath();
            ctx.fillStyle = this.color;
            ctx.arc(this.x, this.y, 3, 0, 2 * Math.PI)
            ctx.fill();
            this.y += this.speed;
        }
    }



    function SortClouds(clouds) {
        clouds.sort((a, b) => {
            return a.backgroundLevel - b.backgroundLevel;
        });
        return clouds;
    }

    function renderPath(x, y, path, color, size, rotation) {
        ctx.fillStyle = color;
        ctx.save();
        ctx.transform(size / 10, 0, 0, size / 10, 160 - 10 * 16.5, 79 - size * 7.5);
        ctx.translate(x, y);
        ctx.rotate(rotation)
        let ex = new Path2D(path);
        ctx.fill(ex);
        ctx.restore();
    }

    function StateHandler() {
        var stack = [];
        var state = null;

        var updateState = function () {
            if (stack.length > 0) {
                state = stack[stack.length - 1];
            } else {
                state = null;
            }
        };

        this.Push = function (newState) {
            stack.push(newState);
            updateState();
        }

        this.Pop = function () {
            stack.pop();
            updateState();
        };

        this.Process = function () {
            if (state != null) {
                state.Process();
            }
        };
    }


    function OnEngineReady() {
        c = document.getElementById("exCanvas");
        stateMgr.Push(new RainyState())
        ctx = c.getContext("2d");
        window.requestAnimationFrame(update);
    }

    function hexToHSL(H) {
        // Convert hex to RGB first
        let r = 0, g = 0, b = 0;
        if (H.length == 4) {
            r = "0x" + H[1] + H[1];
            g = "0x" + H[2] + H[2];
            b = "0x" + H[3] + H[3];
        } else if (H.length == 7) {
            r = "0x" + H[1] + H[2];
            g = "0x" + H[3] + H[4];
            b = "0x" + H[5] + H[6];
        }
        // Then to HSL
        r /= 255;
        g /= 255;
        b /= 255;
        let cmin = Math.min(r, g, b),
            cmax = Math.max(r, g, b),
            delta = cmax - cmin,
            h = 0,
            s = 0,
            l = 0;

        if (delta == 0)
            h = 0;
        else if (cmax == r)
            h = ((g - b) / delta) % 6;
        else if (cmax == g)
            h = (b - r) / delta + 2;
        else
            h = (r - g) / delta + 4;

        h = Math.round(h * 60);

        if (h < 0)
            h += 360;

        l = (cmax + cmin) / 2;
        s = delta == 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));
        s = +(s * 100).toFixed(1);
        l = +(l * 100).toFixed(1);

        return { h: h, s: s, l: l };
    }

    OnEngineReady();
</script>
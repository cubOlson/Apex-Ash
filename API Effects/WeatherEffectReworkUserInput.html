<head>
    <title>WeatherEffect Sunset</title>
    <meta description="Weather effects based on location" />
    <meta publisher="SignalRGB" />
    <meta property="displayGrass" label="Show grass" type="boolean" default="1">
    <meta property="City" label="City" type="textfield" default="">
    <meta property="Override" label="Override weather" type="boolean" default="0">
    <meta property="weatherManual" label="Manual weather mode" type="combobox"
        values="Sunny,Cloudy,Rainy,Snowy,Foggy,Thunder, Drizzle" default="Sunny"
        tooltip="Controls the color of the bars" />
    <meta property="OverrideTime" label="Override time" type="boolean" default="0">
    <meta property="OverTime" label="Time override" type="number" default="95" min="0" max="320" />
    <meta property="foreGroundHeight" label="Foreground height" type="number" default="125" min="0" max="200" />
    <meta property="rainSize" label="Rain size" type="number" default="6" min="1" max="40" />
    <meta property="lowCPU" label="Low Cpu Mode" type="boolean" default="0">
</head>

<body style="margin: 0; padding: 0;">
    <canvas id="exCanvas" width="320" height="200"></canvas>
</body>

<script>
    //#region VariableDeclaration
    var effects = [];
    var FH = 70;
    var timeSinceLastRequest = Date.now();
    var elapsed;
    var updateSpeed = 30;
    var prevCity = "";
    var startTimer = -1;
    var queudRefresh = false;
    var currentCity = "";
    var prevTime = 0;
    var apiHasResponded = false;
    var boolChange = false;
    var needForegroundReload = false;
    var weatherOBJ;
    var basicWeatherString = "";
    var timeColorModifier = 0;
    var stars = [];
    let currentSunPos = 0;
    let validCityString = false;
    let foundCity = false;

    const SUNNYGRASSPALLETE = [
        "#70c725",
        "#44a318",
        "#328530",
        "#3d9815",
        "#58ac14"
    ]
    var stateMgr = new StateHandler();

    //#endregion

    //#region  UpdateLoop
    function update() {

        timeColorModifier = (currentSunPos < 160 ? Math.sin(currentSunPos / 50) : 0.1);
        if (OverrideTime) {
            currentSunPos = OverTime;
        } else {
            currentSunPos = calculateSunPosition();
        }
        detectInputChange();
        elapsed = Date.now() - timeSinceLastRequest;

        if (validCityString || Override) {
            CheckCity();
            CheckTick();
            GetCorrectWeather();
            if (effects.length) {
                effects.forEach((element, index) => {
                    element.draw();
                    if (element.lifetime <= 0) {
                        effects.splice(index, 1);
                    }
                })
            }
            if (foundCity || Override) {
                stateMgr.Process();
            } else if (!queudRefresh && apiHasResponded) {
                showText(`Can't find input city ${currentCity}`, 18, 0, 100)
            } else if (!queudRefresh && !apiHasResponded) {
                showText(`Loading weather for ${currentCity}`, 20, 0, 100)
            }



        } else {
            showText("Please input a city or override the weather", 18, 0, 100)
        }



        //Effects animation play

        window.requestAnimationFrame(update);
    }

    //#endregion

    //#region Calculate/InputMethods

    function showText(text, size, x, y) {
        ctx.beginPath();
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, 320, 200)
        ctx.beginPath();
        ctx.font = `${size}px serif`;
        ctx.fillStyle = "white";
        ctx.fillText(text, x, y);

    }

    function SetRange(num, min, max) {

        return Math.min(Math.max(num, min), max)
    }

    function detectInputChange() {
        if (foreGroundHeight != FH) {
            FH = foreGroundHeight;
            needForegroundReload = true;
        }
        currentCity = City;
        if (currentCity != "") {
            validCityString = true;
        } else {
            validCityString = false;
        }
    }

    function clearBackground() {
        ctx.beginPath();
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, 320, 200);
    }

    function SortClouds(clouds) {
        clouds.sort((a, b) => {
            return a.backgroundLevel - b.backgroundLevel;
        });
        return clouds;
    }


    function calculateSunPosition() {
        let time = new Date().toLocaleTimeString('en-US', {
            hour12: false,
        });
        let splitTime = time.split(`:`)
        let hour = parseInt(splitTime[0] * 60 * 60);
        let minute = parseInt(splitTime[1] * 60);
        let second = parseInt(splitTime[2]);

        let sunPosition = hour + minute + second;
        let calculatedSun = ((320 + (sunPosition / 270) - 120)) % 320;
        return calculatedSun;
    }

    function GetCorrectWeather() {
        if (Override && basicWeatherString != weatherManual || weatherOBJ != null && weatherOBJ != undefined && !Override) {

            if (Override) {
                basicWeatherString = weatherManual;
                stateMgr.Pop();
                if (basicWeatherString.includes("Sunny")) {
                    stateMgr.Push(new SunnyState());
                } else if (basicWeatherString.includes("Cloudy") || basicWeatherString.includes("Overcast")) {
                    stateMgr.Push(new CloudySkyState());
                } else if (basicWeatherString.includes("Rainy")) {
                    stateMgr.Push(new RainyState());
                } else if (basicWeatherString.includes("Snowy")) {
                    stateMgr.Push(new SnowyState());
                } else if (basicWeatherString.includes("Foggy")) {
                    stateMgr.Push(new FoggyState());
                } else if (basicWeatherString.includes("Thunder")) {
                    stateMgr.Push(new ThunderState());
                } else if (basicWeatherString.includes("Drizzle")) {
                    stateMgr.Push(new DrizzleState());
                }
            } else if (weatherOBJ != undefined && basicWeatherString != JSON.stringify(weatherOBJ.current_condition[0].weatherDesc[0].value.toLowerCase())) {
                basicWeatherString = JSON.stringify(weatherOBJ.current_condition[0].weatherDesc[0].value.toLowerCase());
                if (basicWeatherString.includes("sunny") || basicWeatherString.includes("clear")) {
                    stateMgr.Push(new SunnyState());
                } else if (basicWeatherString.includes("cloud")) {
                    stateMgr.Push(new CloudySkyState());
                } else if (basicWeatherString.includes("overcast")) {
                    stateMgr.Push(new CloudySkyState("heavy"));
                }
                else if (basicWeatherString.includes("snow") || basicWeatherString.includes("sleet")) {
                    stateMgr.Push(new SnowyState());
                } else if (basicWeatherString.includes("fog") || basicWeatherString.includes("mist")) {
                    stateMgr.Push(new FoggyState());
                } else if (basicWeatherString.includes("thunder")) {
                    stateMgr.Push(new ThunderState());
                } else if (basicWeatherString.includes("drizzle") || basicWeatherString.includes("patchy rain")) {
                    stateMgr.Push(new DrizzleState());
                } else if (basicWeatherString.includes("rain")) {
                    stateMgr.Push(new RainyState());
                }
            }

        }
    }


    function CheckTick() {
        if (elapsed > 60000 * updateSpeed) {
            GetData();
            timeSinceLastRequest = Date.now();
        }
        if (queudRefresh && Date.now() - startTimer > 5000 && Date.now() - startTimer < 10000) {
            startTimer = -1;
            queudRefresh = false;
            if (City != "") {
                GetData();
            }
        }
    }

    function CheckCity() {
        if (!Override)
            if (prevCity != City || boolChange) {
                boolChange = false;
                prevCity = City;
                startTimer = Date.now();
                if (!queudRefresh) {
                    effects.push(new Sweep())
                }
                apiHasResponded = false;
                queudRefresh = true;
                foundcity = false;
            }
    }

    function GetData() {
        FetchWeather(currentCity)
    }


    function FetchWeather(selectedcity) {
        console.log("Input city is =" + selectedcity)
        fetch(`https://api.codetabs.com/v1/proxy?quest=wttr.in/${selectedcity}?format=j1`).then(response => response.json())
            .then((weather) => {

                let area = weather.nearest_area[0].areaName[0].value;
                timeSinceLastRequest = Date.now();
                if (area != "Tong Not") {
                    weatherOBJ = weather;
                    console.log(JSON.stringify(weather.current_condition[0].weatherDesc[0]))
                    console.log(JSON.stringify(weather));
                    console.log("Temperature in celcius =" + JSON.stringify(weather.current_condition[0].temp_C))
                    console.log("Temperature in fahrenheit =" + JSON.stringify(weather.current_condition[0].temp_F))
                    console.log("Actual area = " + area)
                    console.log("Actual country = " + JSON.stringify(weather.nearest_area[0].country))

                    effects.push(new ApiStateEffect("hsla(104, 100%, 50%,1)"))
                    foundCity = true;
                    apiHasResponded = true;
                } else {

                    console.log("City not found")
                    effects.push(new ApiStateEffect("red"))
                    apiHasResponded = true;
                    foundCity = false;
                }


            })
            .catch(error => {
                console.log(error);
                effects.push(new ApiStateEffect("red"))
                timeSinceLastRequest = Date.now();
                foundCity = false;
                apiHasResponded = true;
            });
    }

    function quadraticFormuleForHill(x) {
        return 0.00015 * x * x + 0 * x + FH;
    }

    function quadraticFormuleForSky(x) {
        return 0.006 * x * x + 0 * x + 50;
    }





    //#endregion

    //#region BaseEffects
    function ApiStateEffect(color) {
        this.start = Date.now();
        this.draw = function () {
            this.elapsed = Date.now() - this.start;
            let gradient = ctx.createLinearGradient(0, -100, 0, 300)
            this.calculateVal = -1660 * Math.floor((this.elapsed / 1660) / 1) + ((this.elapsed / 1660) * (1660 / 1));
            gradient.addColorStop(SetRange((-0 + (this.calculateVal)), 0, 1000) / 1000, "hsla(0, 0%, 0%,0)");
            gradient.addColorStop(SetRange((-200 + (this.calculateVal)), 0, 1000) / 1000, color);
            gradient.addColorStop(SetRange((-400 + (this.calculateVal)), 0, 1000) / 1000, "hsla(0, 0%, 0%,0)")
            ctx.beginPath();
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 00, 320, 200)
            if (this.elapsed > 1500) {
                this.lifetime = 0;
            }
        }
    }

    function Sweep() {
        this.start = Date.now();
        this.draw = function () {
            this.elapsed = Date.now() - this.start;
            ctx.beginPath();
            ctx.fillStyle = "black";
            ctx.fillRect(0, 0, 320, 200);
            ctx.beginPath();
            ctx.fillStyle = "hsla(174, 100%, 58%, 1)";
            ctx.fillRect(0, 0, 320 * ((Date.now() - startTimer) / 4000), 200)
            if (startTimer == -1) {
                this.lifetime = 0;
            }
        }
    }
    //#endregion

    //#region EffectObjects


    class rainDrop {
        constructor(x, y, speed, color) {
            this.x = x;
            this.y = y;
            this.speed = speed;
            this.color = color;
        }

        draw() {
            ctx.beginPath();
            ctx.fillStyle = this.color;
            ctx.arc(this.x, this.y, rainSize / 2, 0, 2 * Math.PI)
            ctx.fill();
            this.y += this.speed;
        }
    }

    class star {
        constructor(x, y, color) {
            this.x = x;
            this.y = y;
            this.color = color;
            this.offset = Math.random() * 2000;
        }

        draw() {
            ctx.beginPath();
            let calcVal = Math.sin(Date.now() / 1000 + this.offset)
            ctx.globalAlpha = calcVal < 0 ? 0 : calcVal;
            ctx.fillStyle = `hsl(${this.color},0%,${calcVal * 100}%)`;
            ctx.arc(this.x, this.y, 1.3, 0, 2 * Math.PI)
            ctx.fill();
            ctx.globalAlpha = 1;
        }
    }

    class snowFlake {
        constructor(x, y, speed, color) {
            this.x = x;
            this.y = y;
            this.speed = speed;
            this.color = color;
            this.offset = Math.random() * 200;
            this.start = Date.now();
        }

        draw() {
            this.elapsed = Date.now() - this.start;
            ctx.beginPath();
            ctx.fillStyle = this.color;
            ctx.arc(this.x + Math.sin(this.elapsed / 1000 + this.offset) * 50, this.y, 3, 0, 2 * Math.PI)
            ctx.fill();
            this.y += this.speed;
        }
    }






    function Lightning(startx) {
        this.start = Date.now();
        this.lifetime = 1;
        if (startx == null || startx == "") {
            this.x = (Math.random() * 200) + 60;
        } else {
            this.x = startx;
        }

        this.y = 0;
        this.moveX = this.x;
        this.moveY = this.y;
        this.drawState = 0;
        this.randomVal = Math.random();
        this.point1 = {
            x: this.x + (Math.random() * -20) - 20,
            y: this.y + ((Math.random() * 30) + 100)
        }
        this.point2 = {
            x: this.x + (+ (Math.random() * 20) + 20),
            y: this.point1.y + ((Math.random() * -20) - 30)
        }
        this.point3 = {
            x: this.x + (+(Math.random() * 20) + 60),
            y: 200
        }
        this.angle1 = Math.atan2(this.y - this.point1.y, this.point1.x - this.x);
        this.angle2 = Math.atan2(this.point1.y - this.point2.y, this.point2.x - this.point1.x)
        this.angle3 = Math.atan2(this.point2.y - this.point3.y, this.point2.x - this.point3.x);
        this.speed = {
            x: Math.cos(this.angle1),
            y: Math.sin(-this.angle1)
        }
        this.draw = function () {
            ctx.strokeStyle = "Yellow";
            ctx.lineWidth = 20;
            ctx.beginPath();
            ctx.moveTo(this.x, this.y);
            if (this.drawState == 0) {
                ctx.lineTo(this.moveX, this.moveY);
            } else if (this.drawState == 1) {
                ctx.lineTo(this.point1.x, this.point1.y)
                ctx.lineTo(this.moveX, this.moveY);
            } else if (this.drawState == 2) {
                ctx.lineTo(this.point1.x, this.point1.y)
                ctx.lineTo(this.point2.x, this.point2.y)
                ctx.lineTo(this.moveX, this.moveY);
            }
            ctx.stroke();
            this.moveX += this.speed.x * 10;
            this.moveY += this.speed.y * 10;
            if (this.moveX < this.point1.x && this.drawState == 0) {
                this.drawState = 1;
                this.speed = {
                    x: Math.cos(this.angle2),
                    y: Math.sin(-this.angle2)
                }
            } else if (this.moveY < this.point2.y && this.drawState == 1) {
                this.drawState = 2;
                this.speed = {
                    x: Math.cos(this.angle3),
                    y: Math.sin(-this.angle3)
                }
            }
        }
    }


    function SunnyHill(brightness, hasGrass = true, sat = 84) {
        this.grass = [];
        this.hasGrass = hasGrass;
        this.sat = sat;
        for (let index = 0; index < 50; index++) {
            let x = Math.random() * 320;
            this.grass.push(new grass(x, quadraticFormuleForHill((x - 160) * 2), hexToHSL(SUNNYGRASSPALLETE[Math.floor(Math.random() * SUNNYGRASSPALLETE.length)]), brightness));

        }
        this.draw = function () {
            let grad = ctx.createRadialGradient(160, FH + 200, 10, 160, FH + 200, 200);
            grad.addColorStop(1, `hsla(98, ${this.sat}%, ${brightness * timeColorModifier}%, 1)`)
            grad.addColorStop(0.7, `hsla(98, ${this.sat}%, ${(brightness - 20) * timeColorModifier}%, 1)`)
            grad.addColorStop(0.4, `hsla(98, 100%, ${(brightness - 30) * timeColorModifier}%, 1)`)
            DrawCircle(160, 900 + FH, 900, grad)
            if (this.hasGrass && displayGrass) {
                this.grass.forEach(grass => {
                    grass.draw();
                });
            }

        }
    }

    function grass(x, y, color, brightness) {
        this.x = x;
        this.y = y;
        this.lineWidth = Math.random() * 5 + 1;;
        this.color = color;
        this.height = Math.random() * 10 + 3;
        this.start = Date.now();
        this.speed = Math.random() * 0.8 + 0.5;

        this.draw = function () {

            this.elapsed = Date.now() - this.start;
            if (!lowCPU) {
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.bezierCurveTo(this.x, this.y - this.height, this.x + Math.sin(((this.elapsed / 500) * this.speed) + 100) * this.height * 1.5, this.y - this.height * 2, this.x + Math.sin(((this.elapsed / 500) * this.speed) + 200) * this.height * 2, this.y - this.height * 3)
                ctx.lineWidth = this.lineWidth;
                ctx.strokeStyle = `hsl(${this.color.h},${this.color.s}%,${brightness * timeColorModifier + (this.color.l) / 5}%)`;
                ctx.stroke();
            } else {
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x + Math.sin(((this.elapsed / 500) * this.speed) + 200) * this.height * 2, this.y - this.height * 3)
                ctx.lineWidth = this.lineWidth;
                ctx.strokeStyle = `hsl(${this.color.h},${this.color.s}%,${brightness * timeColorModifier + (this.color.l) / 5}%)`;
                ctx.stroke();
            }
        }
    }

    class GeneralBackgroundProp {
        constructor(x, y, Direction, moveSpeed, DoAnimation = false, loop = false) {
            this.StartX = 0;
            this.StartY = y;
            this.MoveX = x;
            this.MoveY = DoAnimation ? y < 160 ? -50 : 250 : y;
            this.moveSpeed = moveSpeed;
            this.Direction = Direction;
            this.DoAnimation = DoAnimation;
            this.start = Date.now();
            this.elapsed = 0;
            this.loop = loop;
        }

        startUpAnim() {

            if (this.StartY < 160) {
                if (this.MoveY < this.StartY) {
                    this.MoveY += 1;
                }

            } else {
                if (this.StartY > 160) {
                    if (this.MoveY > this.StartY) {
                        this.MoveY -= 1;
                    }
                }
            }


        }
        calculateNewPos() {
            if (this.DoAnimation && this.elapsed < 10000) {
                this.startUpAnim();
            }

            this.elapsed = Date.now() - this.start;
            if (this.Direction == "Right") {
                this.MoveX += this.moveSpeed;
            } else {
                this.MoveX -= this.moveSpeed;
            }

            if (this.MoveX > 380 && this.loop) {
                this.MoveX = -20
            } else if (this.MoveX < -80 && this.loop) {
                this.MoveX = 330
            }
            return { x: this.MoveX, y: this.MoveY };
        }
    }


    class Cloud extends GeneralBackgroundProp {
        constructor(direction, backgroundLevel, h, s, brightness, y = 35) {
            super(Math.random() * 320, Math.random() * y, direction, backgroundLevel / 5 + 0.1, true, true)
            this.balls = [];
            this.cloud = true;
            this.h = h;
            this.s = s;
            this.brightness = brightness;
            this.lowCpuOffset = Math.random() * 30;
            this.backgroundLevel = backgroundLevel;
            for (let index = 0; index < 5; index++) {
                this.balls.push(new cloudBall(Math.random() * 35, Math.random() * 35, Math.random() * 20 + 5, { h: this.h, s: this.s, l: this.brightness + this.backgroundLevel * 10 }));
            }
        }
        draw() {
            let pos = super.calculateNewPos();
            ctx.globalAlpha = 0.8;
            if (!lowCPU) {
                this.balls.forEach((ball, index) => {
                    this.balls[index].draw(pos.x, pos.y);

                })
            } else {
                ctx.beginPath();
                ctx.fillStyle = `hsl(${this.h},${this.s}%,${(this.brightness + this.backgroundLevel * 10) * timeColorModifier}%)`;
                ctx.ellipse(pos.x, pos.y + this.lowCpuOffset, 30, 20, 0, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
        }
    }


    function cloudBall(xOffset, yOffset, radius, color) {
        this.xOffset = xOffset;
        this.yOffset = yOffset;
        this.radius = radius;
        this.color = color;
        this.start = Date.now();
        this.duration = Math.random() * 8000 + 3000;

        this.draw = function (x, y) {
            DrawCircle(x + this.xOffset, y + this.yOffset, this.radius, `hsl(${this.color.h},${this.color.s}%,${this.color.l * timeColorModifier}%)`);
        }
    }

    function floatingPollen() {
        this.y = Math.random() * 100;
        this.x = 320 + Math.random() * 100;
        this.start = Date.now();
        this.elapsed = 0;
        this.lifetime = Math.random() * 8000 + 3000;
        this.randomCol = Math.random() * 50;
        this.speed = Math.random() * 2 + 0.4;
        this.offset = Math.random() * 5000;
        this.draw = function () {
            this.elapsed = Date.now() - this.start;

            ctx.beginPath();

            DrawCircle(this.x, this.y + Math.sin((this.elapsed + this.offset) / 2000) * 30, 2, `hsl(${67 + this.randomCol},85%,60%)`);
            this.x -= this.speed;
        }
    }
    //#endregion

    //#region DrawFunctions

    function DrawSunnySky(sunH, sunBrightness, sunSize) {
        ctx.beginPath();

        let grad;
        if (currentSunPos < 160) {
            grad = ctx.createRadialGradient(currentSunPos * 2, quadraticFormuleForSky(currentSunPos * 2 - 160), 20, currentSunPos * 2, quadraticFormuleForSky(currentSunPos * 2 - 160), 400)

            if (timeColorModifier < 0.5) {
                grad.addColorStop(0, `hsl(${sunH - ((0.5 - timeColorModifier) * 70)},100%,${sunBrightness}%)`);
                grad.addColorStop(SetRange(sunSize - 0.1, 0, 1), `hsl(${sunH - ((0.5 - timeColorModifier) * 70)},100%,${sunBrightness}%)`);
                grad.addColorStop(SetRange(sunSize + 0.1 + ((0.5 - timeColorModifier) * 1.2), 0, 1), `hsl(40,80%,58%) `)
                grad.addColorStop(SetRange(sunSize + 0.2 + ((0.5 - timeColorModifier) * 1.1), 0, 1), `hsl(210,80%,58%) `)
                grad.addColorStop(1, "hsl(220,100%,17%)")
            } else {
                grad.addColorStop(0, `hsl(${sunH},100%,${sunBrightness}%)`);
                grad.addColorStop(sunSize - 0.1, `hsl(${sunH},100%,${sunBrightness}%)`);
                grad.addColorStop(sunSize + 0.1, `hsl(210,80%,58%) `)
                grad.addColorStop(1, "hsl(220,100%,17%)")
            }

        } else {
            grad = ctx.createRadialGradient((currentSunPos - 160) * 2, quadraticFormuleForSky((currentSunPos - 160) * 2 - 160), 20, (currentSunPos - 160) * 2, quadraticFormuleForSky((currentSunPos - 160) * 2 - 160), 200)
            grad.addColorStop(0, `hsl(0,100%,100%)`);
            grad.addColorStop(0.1, `hsl(0,100%,100%)`);
            grad.addColorStop(0.15, `hsl(170,80%,5%)`)
            grad.addColorStop(1, "hsl(220,100%,2%)")
        }

        ctx.globalAlpha = 1;
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, 320, 200)
        if (currentSunPos > 160) {
            stars.forEach(Star => {
                Star.draw();
            });
        }
    }


    function DrawRainySky() {
        ctx.beginPath();
        let grad;
        ctx.globalAlpha = 0.01;
        grad = ctx.createRadialGradient(200, 40, 20, 200, 40, 200)
        grad.addColorStop(0, "hsl(50,2%,30%)")
        grad.addColorStop(0.3, "hsl(72,2%,20%)")
        grad.addColorStop(0.7, "hsl(150,1%,10%)")
        grad.addColorStop(1, "hsl(192,6%,6%)")
        ctx.globalAlpha = 0.2;
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, 320, 200)
        ctx.globalAlpha = 1;
    }

    function DrawCircle(x, y, radius, color) {
        ctx.beginPath();
        ctx.fillStyle = color;
        ctx.arc(x, y, radius, 0, 2 * Math.PI)
        ctx.fill();
    };
    //#endregion

    //#region WeatherStates
    function CloudySkyState(intensity) {
        this.clouds = [];
        this.SunnyHill = new SunnyHill(50);
        this.cloudAmount = intensity == "partly" ? 5 : intensity == "heavy" ? 50 : 20

        for (let index = 0; index < this.cloudAmount; index++) {
            this.clouds.push(new Cloud("left", Math.floor(Math.random() * 6), 198, 76, 55));
        }
        this.clouds = SortClouds(this.clouds)

        this.Process = function () {
            if (needForegroundReload) {
                this.SunnyHill = new SunnyHill(50);
                needForegroundReload = false;
            }
            if (!queudRefresh) {
                this.draw();
            }
        }

        this.draw = function () {

            DrawSunnySky(48, 50, 0.15);
            this.clouds.forEach(cloud => {
                cloud.draw();
            });
            this.SunnyHill.draw();
        }
    }

    function SunnyState() {

        this.SunnyHill = new SunnyHill(50);
        this.pollen = [];
        for (let index = 0; index < 50; index++) {

            this.pollen.push(new floatingPollen())
        }
        this.Process = function () {
            if (needForegroundReload) {
                this.SunnyHill = new SunnyHill(50);
                needForegroundReload = false;
            }
            if (!queudRefresh) {
                this.draw();
            }
        }
        this.draw = function () {
            DrawSunnySky(34, 50, 0.21);
            this.SunnyHill.draw();
            if (currentSunPos < 160) {
                this.pollen.forEach((pol, i) => {
                    pol.draw();
                    if (pol.x < -20) {
                        this.pollen.splice(i, 1)
                        this.pollen.push(new floatingPollen())
                    }
                });
            }

        }
    }

    function DrizzleState() {
        this.rainDrops = [];
        this.SunnyHill = new SunnyHill(50);
        this.clouds = [];


        for (let index = 0; index < 30; index++) {
            this.clouds.push(new Cloud("left", Math.floor(Math.random() * 6), 198, 76, 35));
        }

        for (let index = 0; index < 60; index++) {
            let backgroundLevel = Math.floor(Math.random() * 5);
            this.rainDrops.push(new rainDrop(Math.random() * 320, 0 - Math.random() * -50, 5 - backgroundLevel, `hsla(212, 77%, ${70 - backgroundLevel * 10}%, 1`));
        }
        this.clouds = SortClouds(this.clouds)

        this.Process = function () {

            if (needForegroundReload) {
                this.SunnyHill = new SunnyHill(50);
                needForegroundReload = false;
            }
            if (!queudRefresh) {
                this.draw();
            }
        }

        this.draw = function () { 

            DrawSunnySky(48, 50, 0.15);
            this.clouds.forEach(cloud => {
                cloud.draw();
            });
            this.rainDrops.forEach(raindrop => {
                raindrop.draw();
                if (raindrop.y > 220) {
                    let backgroundLevel = Math.floor(Math.random() * 5);
                    this.rainDrops.splice(this.rainDrops.indexOf(raindrop), 1)
                    this.rainDrops.push(new rainDrop(Math.random() * 320, 0 - Math.random() * -50, 5 - backgroundLevel, `hsla(212, 77%, ${70 - backgroundLevel * 5}%, 1`));
                }
            });
            this.SunnyHill.draw();
        }
    }

    function RainyState() {
        this.clouds = [];
        this.rainDrops = [];
        this.SunnyHill = new SunnyHill(10);
        this.cloudAmount = 50;

        for (let index = 0; index < this.cloudAmount; index++) {
            this.clouds.push(new Cloud("left", Math.floor(Math.random() * 6), 150, 2, 3, 40));
        }
        this.clouds = SortClouds(this.clouds)
        for (let index = 0; index < 100; index++) {
            let backgroundLevel = Math.floor(Math.random() * 5);
            this.rainDrops.push(new rainDrop(Math.random() * 320, 0 - Math.random() * -50, 5 - backgroundLevel, `hsla(212, 77%, ${50 - backgroundLevel * 10}%, 1`));
        }
        this.Process = function () {
            if (needForegroundReload) {
                this.SunnyHill = new SunnyHill(10);
                needForegroundReload = false;
            }
            if (!queudRefresh) {
                this.draw();
            }
        }
        this.draw = function () {
            DrawRainySky();
            this.clouds.forEach(cloud => {
                cloud.draw();
            });

            this.rainDrops.forEach(raindrop => {
                raindrop.draw();
                if (raindrop.y > 220) {
                    let backgroundLevel = Math.floor(Math.random() * 5);
                    this.rainDrops.splice(this.rainDrops.indexOf(raindrop), 1)
                    this.rainDrops.push(new rainDrop(Math.random() * 320, 0 - Math.random() * -50, 5 - backgroundLevel, `hsla(212, 77%, ${50 - backgroundLevel * 5}%, 1`));
                }
            });
            this.SunnyHill.draw();
        }
    }

    function ThunderState() {
        this.clouds = [];
        this.lightning = [];
        this.rainDrops = [];
        this.SunnyHill = new SunnyHill(10);
        this.cloudAmount = 50;

        for (let index = 0; index < this.cloudAmount; index++) {
            this.clouds.push(new Cloud("left", Math.floor(Math.random() * 6), 150, 2, 3, 20));
        }
        this.clouds = SortClouds(this.clouds)
        for (let index = 0; index < 100; index++) {
            let backgroundLevel = Math.floor(Math.random() * 5);
            this.rainDrops.push(new rainDrop(Math.random() * 320, 0 - Math.random() * -50, 5 - backgroundLevel, `hsla(212, 77%, ${50 - backgroundLevel * 10}%, 1`));
        }
        this.Process = function () {
            if (needForegroundReload) {
                this.SunnyHill = new SunnyHill(10);
                needForegroundReload = false;
            }
            if (!queudRefresh) {
                this.draw();
            }
        }
        this.draw = function () {
            DrawRainySky();
            this.clouds.forEach(cloud => {
                cloud.draw();
            });
            if (Math.random() > 0.98) {
                this.lightning.push(new Lightning(Math.random() * 320))
            }

            this.rainDrops.forEach(raindrop => {
                raindrop.draw();
                if (raindrop.y > 220) {
                    let backgroundLevel = Math.floor(Math.random() * 5);
                    this.rainDrops.splice(this.rainDrops.indexOf(raindrop), 1)
                    this.rainDrops.push(new rainDrop(Math.random() * 320, 0 - Math.random() * -50, 5 - backgroundLevel, `hsla(212, 77%, ${50 - backgroundLevel * 5}%, 1`));
                }
            });
            this.lightning.forEach(light => {
                light.draw();
                if (light.moveY > 220) {
                    this.lightning.splice(this.lightning.indexOf(light), 1)
                }
            });
            this.SunnyHill.draw();
        }
    }

    function FoggyState() {
        this.clouds = [];
        this.SunnyHill = new SunnyHill(30);
        this.cloudAmount = 50;

        for (let index = 0; index < this.cloudAmount; index++) {
            this.clouds.push(new Cloud("left", Math.floor(Math.random() * 6), 150, 2, 3, 50));
        }
        this.clouds = SortClouds(this.clouds)
        this.Process = function () {
            if (needForegroundReload) {
                this.SunnyHill = new SunnyHill(30);
                needForegroundReload = false;
            }
            if (!queudRefresh) {
                this.draw();
            }
        }
        this.draw = function () {
            DrawRainySky();
            ctx.beginPath();
            ctx.fillStyle = "hsla(150,2%,40%,0.3)"
            ctx.fillRect(0, 0, 320, 200)
            this.clouds.forEach(cloud => {
                cloud.draw();
            });
            ctx.beginPath();
            ctx.fillStyle = "hsla(150,2%,40%,0.3)"
            ctx.fillRect(0, 0, 320, 200)

            this.SunnyHill.draw();
            ctx.beginPath();
            ctx.fillStyle = "hsla(150,2%,40%,0.4)"
            ctx.fillRect(0, 0, 320, 200)
        }
    }


    function SnowyState() {
        this.clouds = [];
        this.snowDrop = [];
        this.cloudAmount = 50;
        this.SunnyHill = new SunnyHill(100, false, 0);
        for (let index = 0; index < this.cloudAmount; index++) {
            this.clouds.push(new Cloud("left", Math.floor(Math.random() * 6), 197, 35, 30, 50));
        }
        this.clouds = SortClouds(this.clouds)
        for (let index = 0; index < 100; index++) {
            let backgroundLevel = Math.floor(Math.random() * 5);
            this.snowDrop.push(new snowFlake(Math.random() * 320, 0 - Math.random() * -50, SetRange(2 - backgroundLevel / 3, 0, 2), `hsla(0, 0%, 90%, 1`));
        }
        this.Process = function () {
            if (needForegroundReload) {
                this.SunnyHill = new SunnyHill(100, false, 0);
                needForegroundReload = false;
            }
            if (!queudRefresh) {
                this.draw();
            }
        }
        this.draw = function () {
            DrawSunnySky(50, 80, 0.2);
            ctx.beginPath();
            ctx.fillStyle = "hsla(150,2%,70%,0.1)"
            ctx.fillRect(0, 0, 320, 200)
            this.clouds.forEach(cloud => {
                cloud.draw();
            });

            this.snowDrop.forEach(SnowFlake => {
                SnowFlake.draw();
                if (SnowFlake.y > 220) {
                    let backgroundLevel = Math.floor(Math.random() * 5);
                    this.snowDrop.splice(this.snowDrop.indexOf(SnowFlake), 1)
                    this.snowDrop.push(new snowFlake(Math.random() * 320, 0 - Math.random() * -50, SetRange(2 - backgroundLevel / 3, 0, 2), `hsla(0, 0%, 90%, 1`));
                }
            });
            ctx.beginPath();
            ctx.fillStyle = "hsla(150,2%,70%,0.2)"
            ctx.fillRect(0, 0, 320, 200)
            this.SunnyHill.draw();
            ctx.beginPath();
            ctx.fillStyle = "hsla(150,2%,70%,0.2)"
            ctx.fillRect(0, 0, 320, 200)
        }
    }
    //#endregion








    function StateHandler() {
        var stack = [];
        var state = null;

        var updateState = function () {
            if (stack.length > 0) {
                state = stack[stack.length - 1];
            } else {
                state = null;
            }
        };

        this.Push = function (newState) {
            stack.push(newState);
            updateState();
        }

        this.Pop = function () {
            stack.pop();
            updateState();
        };

        this.Process = function () {
            if (state != null) {
                state.Process();
            }
        };
    }



    function hexToHSL(H) {
        // Convert hex to RGB first
        let r = 0, g = 0, b = 0;
        if (H.length == 4) {
            r = "0x" + H[1] + H[1];
            g = "0x" + H[2] + H[2];
            b = "0x" + H[3] + H[3];
        } else if (H.length == 7) {
            r = "0x" + H[1] + H[2];
            g = "0x" + H[3] + H[4];
            b = "0x" + H[5] + H[6];
        }
        // Then to HSL
        r /= 255;
        g /= 255;
        b /= 255;
        let cmin = Math.min(r, g, b),
            cmax = Math.max(r, g, b),
            delta = cmax - cmin,
            h = 0,
            s = 0,
            l = 0;

        if (delta == 0)
            h = 0;
        else if (cmax == r)
            h = ((g - b) / delta) % 6;
        else if (cmax == g)
            h = (b - r) / delta + 2;
        else
            h = (r - g) / delta + 4;

        h = Math.round(h * 60);

        if (h < 0)
            h += 360;

        l = (cmax + cmin) / 2;
        s = delta == 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));
        s = +(s * 100).toFixed(1);
        l = +(l * 100).toFixed(1);

        return { h: h, s: s, l: l };
    }



    function OnEngineReady() {
        c = document.getElementById("exCanvas");
        stateMgr.Push(new CloudySkyState())
        for (let index = 0; index < 30; index++) {
            stars.push(new star(Math.random() * 320, Math.random() * 100, 0));
        }
        ctx = c.getContext("2d");
        window.requestAnimationFrame(update);
    }
    OnEngineReady();
</script>